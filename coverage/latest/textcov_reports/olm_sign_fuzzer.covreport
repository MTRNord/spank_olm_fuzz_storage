_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EEC2Ev:
   63|  19.8k|      AlignmentBuffer() : m_position(0) {}
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE5clearEv:
   72|   247k|      void clear() {
   73|   247k|         clear_mem(m_buffer.data(), m_buffer.size());
   74|   247k|         m_position = 0;
   75|   247k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EED2Ev:
   65|  19.8k|      ~AlignmentBuffer() { secure_scrub_memory(m_buffer.data(), m_buffer.size()); }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE21handle_unaligned_dataERNS_12BufferSlicerE:
  167|   500k|      [[nodiscard]] std::optional<std::span<const T>> handle_unaligned_data(BufferSlicer& slicer) {
  168|       |         // When the final block is to be deferred, we would need to store and
  169|       |         // hold a buffer that contains exactly one block until more data is
  170|       |         // passed or it is explicitly consumed.
  171|   500k|         const size_t defer = (defers_final_block()) ? 1 : 0;
  ------------------
  |  Branch (171:31): [True: 0, False: 500k]
  ------------------
  172|       |
  173|   500k|         if(in_alignment() && slicer.remaining() >= m_buffer.size() + defer) {
  ------------------
  |  Branch (173:13): [True: 404k, False: 95.7k]
  |  Branch (173:31): [True: 209k, False: 194k]
  ------------------
  174|       |            // We are currently in alignment and the passed-in data source
  175|       |            // contains enough data to benefit from aligned processing.
  176|       |            // Therefore, we don't copy anything into the intermittent buffer.
  177|   209k|            return std::nullopt;
  178|   209k|         }
  179|       |
  180|       |         // Fill the buffer with as much input data as needed to reach alignment
  181|       |         // or until the input source is depleted.
  182|   290k|         const auto elements_to_consume = std::min(m_buffer.size() - m_position, slicer.remaining());
  183|   290k|         append(slicer.take(elements_to_consume));
  184|       |
  185|       |         // If we collected enough data, we push out one full block. When
  186|       |         // deferring the final block is enabled, we additionally check that
  187|       |         // more input data is available to continue processing a consecutive
  188|       |         // block.
  189|   290k|         if(ready_to_consume() && (!defers_final_block() || !slicer.empty())) {
  ------------------
  |  Branch (189:13): [True: 9.90k, False: 280k]
  |  Branch (189:36): [True: 9.90k, False: 0]
  |  Branch (189:61): [True: 0, False: 0]
  ------------------
  190|  9.90k|            return consume();
  191|   280k|         } else {
  192|   280k|            return std::nullopt;
  193|   280k|         }
  194|   290k|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE18defers_final_blockEv:
  234|   729k|      constexpr bool defers_final_block() const {
  235|   729k|         return FINAL_BLOCK_STRATEGY == AlignmentBufferFinalBlock::must_be_deferred;
  236|   729k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE6appendENSt3__14spanIKhLm18446744073709551615EEE:
   91|   478k|      void append(std::span<const T> elements) {
   92|   478k|         BOTAN_ASSERT_NOMSG(elements.size() <= elements_until_alignment());
  ------------------
  |  |   64|   478k|   do {                                                                     \
  |  |   65|   478k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 478k]
  |  |  ------------------
  |  |   66|   478k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   478k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   93|   478k|         std::copy(elements.begin(), elements.end(), m_buffer.begin() + m_position);
   94|   478k|         m_position += elements.size();
   95|   478k|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE24elements_until_alignmentEv:
  222|  1.04M|      size_t elements_until_alignment() const { return m_buffer.size() - m_position; }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE16ready_to_consumeEv:
  232|   865k|      bool ready_to_consume() const { return m_position == m_buffer.size(); }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE7consumeEv:
  201|   198k|      [[nodiscard]] std::span<const T> consume() {
  202|   198k|         BOTAN_ASSERT_NOMSG(ready_to_consume());
  ------------------
  |  |   64|   198k|   do {                                                                     \
  |  |   65|   198k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 198k]
  |  |  ------------------
  |  |   66|   198k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   198k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  203|   198k|         m_position = 0;
  204|   198k|         return m_buffer;
  205|   198k|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE12in_alignmentEv:
  227|  1.21M|      bool in_alignment() const { return m_position == 0; }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE23aligned_data_to_processERNS_12BufferSlicerE:
  127|   219k|      [[nodiscard]] std::tuple<std::span<const uint8_t>, size_t> aligned_data_to_process(BufferSlicer& slicer) const {
  128|   219k|         BOTAN_ASSERT_NOMSG(in_alignment());
  ------------------
  |  |   64|   219k|   do {                                                                     \
  |  |   65|   219k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 219k]
  |  |  ------------------
  |  |   66|   219k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   219k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  129|       |
  130|       |         // When the final block is to be deferred, the last block must not be
  131|       |         // selected for processing if there is no (unaligned) extra input data.
  132|   219k|         const size_t defer = (defers_final_block()) ? 1 : 0;
  ------------------
  |  Branch (132:31): [True: 0, False: 219k]
  ------------------
  133|   219k|         const size_t full_blocks_to_process = (slicer.remaining() - defer) / m_buffer.size();
  134|   219k|         return {slicer.take(full_blocks_to_process * m_buffer.size()), full_blocks_to_process};
  135|   219k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE18fill_up_with_zerosEv:
   80|   188k|      void fill_up_with_zeros() {
   81|   188k|         if(!ready_to_consume()) {
  ------------------
  |  Branch (81:13): [True: 188k, False: 22]
  ------------------
   82|   188k|            clear_mem(&m_buffer[m_position], elements_until_alignment());
   83|   188k|            m_position = m_buffer.size();
   84|   188k|         }
   85|   188k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE20directly_modify_lastEm:
  114|   188k|      std::span<T> directly_modify_last(size_t elements) {
  115|   188k|         BOTAN_ASSERT_NOMSG(size() >= elements);
  ------------------
  |  |   64|   188k|   do {                                                                     \
  |  |   65|   188k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 188k]
  |  |  ------------------
  |  |   66|   188k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   188k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  116|   188k|         return std::span(m_buffer).last(elements);
  117|   188k|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE4sizeEv:
  218|   188k|      constexpr size_t size() const { return m_buffer.size(); }

_ZN5Botan14expand_top_bitIjEET_S1_Qsr3stdE13is_integral_vIS1_E:
   28|  3.80M|{
   29|  3.80M|   return static_cast<T>(0) - (a >> (sizeof(T) * 8 - 1));
   30|  3.80M|}
_ZN5Botan10ct_is_zeroIjEET_S1_Qsr3stdE13is_integral_vIS1_E:
   38|  3.80M|{
   39|  3.80M|   return expand_top_bit<T>(~x & (x - 1));
   40|  3.80M|}
_ZN5Botan14expand_top_bitImEET_S1_Qsr3stdE13is_integral_vIS1_E:
   28|  1.68M|{
   29|  1.68M|   return static_cast<T>(0) - (a >> (sizeof(T) * 8 - 1));
   30|  1.68M|}
_ZN5Botan6chooseImEET_S1_S1_S1_:
  211|  82.9M|BOTAN_FORCE_INLINE constexpr T choose(T mask, T a, T b) {
  212|       |   //return (mask & a) | (~mask & b);
  213|  82.9M|   return (b ^ (mask & (a ^ b)));
  214|  82.9M|}
_ZN5Botan10ct_is_zeroIhEET_S1_Qsr3stdE13is_integral_vIS1_E:
   38|  19.8k|{
   39|  19.8k|   return expand_top_bit<T>(~x & (x - 1));
   40|  19.8k|}
_ZN5Botan14expand_top_bitIhEET_S1_Qsr3stdE13is_integral_vIS1_E:
   28|  19.8k|{
   29|  19.8k|   return static_cast<T>(0) - (a >> (sizeof(T) * 8 - 1));
   30|  19.8k|}
_ZN5Botan8majorityImEET_S1_S1_S1_:
  217|  41.4M|BOTAN_FORCE_INLINE constexpr T majority(T a, T b, T c) {
  218|       |   /*
  219|       |   Considering each bit of a, b, c individually
  220|       |
  221|       |   If a xor b is set, then c is the deciding vote.
  222|       |
  223|       |   If a xor b is not set then either a and b are both set or both unset.
  224|       |   In either case the value of c doesn't matter, and examining b (or a)
  225|       |   allows us to determine which case we are in.
  226|       |   */
  227|  41.4M|   return choose(a ^ b, c, b);
  228|  41.4M|}

_ZN5Botan13reverse_bytesITkNSt3__117unsigned_integralEmQooooooeqstT_Li1EeqstS2_Li2EeqstS2_Li4EeqstS2_Li8EEES2_S2_:
   27|  1.69M|inline constexpr T reverse_bytes(T x) {
   28|       |   if constexpr(sizeof(T) == 1) {
   29|       |      return x;
   30|       |   } else if constexpr(sizeof(T) == 2) {
   31|       |#if BOTAN_COMPILER_HAS_BUILTIN(__builtin_bswap16)
   32|       |      return static_cast<T>(__builtin_bswap16(x));
   33|       |#else
   34|       |      return static_cast<T>((x << 8) | (x >> 8));
   35|       |#endif
   36|       |   } else if constexpr(sizeof(T) == 4) {
   37|       |#if BOTAN_COMPILER_HAS_BUILTIN(__builtin_bswap32)
   38|       |      return static_cast<T>(__builtin_bswap32(x));
   39|       |#else
   40|       |      // MSVC at least recognizes this as a bswap
   41|       |      return static_cast<T>(((x & 0x000000FF) << 24) | ((x & 0x0000FF00) << 8) | ((x & 0x00FF0000) >> 8) |
   42|       |                            ((x & 0xFF000000) >> 24));
   43|       |#endif
   44|  1.69M|   } else if constexpr(sizeof(T) == 8) {
   45|  1.69M|#if BOTAN_COMPILER_HAS_BUILTIN(__builtin_bswap64)
   46|  1.69M|      return static_cast<T>(__builtin_bswap64(x));
   47|       |#else
   48|       |      uint32_t hi = static_cast<uint32_t>(x >> 32);
   49|       |      uint32_t lo = static_cast<uint32_t>(x);
   50|       |
   51|       |      hi = reverse_bytes(hi);
   52|       |      lo = reverse_bytes(lo);
   53|       |
   54|       |      return (static_cast<T>(lo) << 32) | hi;
   55|       |#endif
   56|  1.69M|   }
   57|  1.69M|}

_ZN5Botan5CPUID3hasENS_10CPUFeatureE:
   94|   407k|      static bool has(CPUID::Feature feat) { return state().has_bit(feat.as_u32()); }
_ZN5Botan5CPUID3hasENS_10CPUFeatureES1_:
   99|   815k|      static bool has(CPUID::Feature feat1, CPUID::Feature feat2) {
  100|   815k|         return state().has_bit(feat1.as_u32() | feat2.as_u32());
  101|   815k|      }
_ZNK5Botan5CPUID10CPUID_Data7has_bitEj:
  139|  1.22M|            bool has_bit(uint32_t bit) const { return (m_processor_features & bit) == bit; }
_ZN5Botan5CPUID5stateEv:
  151|  1.22M|      static CPUID_Data& state() {
  152|  1.22M|         static CPUID::CPUID_Data g_cpuid;
  153|  1.22M|         return g_cpuid;
  154|  1.22M|      }
cpuid_x86.cpp:_ZN5Botan5CPUID6if_setIZNS0_10CPUID_Data19detect_cpu_featuresEjE16x86_CPUID_1_bitsEEjmT_NS_10CPUFeatureEj:
  117|      6|      static inline uint32_t if_set(uint64_t cpuid, T flag, CPUID::Feature bit, uint32_t allowed) {
  118|      6|         const uint64_t flag64 = static_cast<uint64_t>(flag);
  119|      6|         if((cpuid & flag64) == flag64) {
  ------------------
  |  Branch (119:13): [True: 6, False: 0]
  ------------------
  120|      6|            return (bit.as_u32() & allowed);
  121|      6|         } else {
  122|      0|            return 0;
  123|      0|         }
  124|      6|      }
cpuid_x86.cpp:_ZN5Botan5CPUID6if_setIZNS0_10CPUID_Data19detect_cpu_featuresEjE16x86_CPUID_7_bitsEEjmT_NS_10CPUFeatureEj:
  117|      8|      static inline uint32_t if_set(uint64_t cpuid, T flag, CPUID::Feature bit, uint32_t allowed) {
  118|      8|         const uint64_t flag64 = static_cast<uint64_t>(flag);
  119|      8|         if((cpuid & flag64) == flag64) {
  ------------------
  |  Branch (119:13): [True: 7, False: 1]
  ------------------
  120|      7|            return (bit.as_u32() & allowed);
  121|      7|         } else {
  122|      1|            return 0;
  123|      1|         }
  124|      8|      }
cpuid_x86.cpp:_ZN5Botan5CPUID6if_setIZNS0_10CPUID_Data19detect_cpu_featuresEjE18x86_CPUID_7_1_bitsEEjmT_NS_10CPUFeatureEj:
  117|      3|      static inline uint32_t if_set(uint64_t cpuid, T flag, CPUID::Feature bit, uint32_t allowed) {
  118|      3|         const uint64_t flag64 = static_cast<uint64_t>(flag);
  119|      3|         if((cpuid & flag64) == flag64) {
  ------------------
  |  Branch (119:13): [True: 0, False: 3]
  ------------------
  120|      0|            return (bit.as_u32() & allowed);
  121|      3|         } else {
  122|      3|            return 0;
  123|      3|         }
  124|      3|      }

_ZN5Botan10CPUFeatureC2ENS0_3BitE:
   50|  2.03M|      CPUFeature(Bit b) : m_bit(b) {}
_ZNK5Botan10CPUFeature6as_u32Ev:
   52|  2.03M|      uint32_t as_u32() const { return static_cast<uint32_t>(m_bit); }

_ZN5Botan2CT13value_barrierIjEET_S2_Qaasr3stdE17unsigned_integralIS2_Entsr3stdE7same_asIbS2_E:
  278|  15.2M|{
  279|  15.2M|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (279:7): [Folded - Ignored]
  ------------------
  280|      0|      return x;
  281|  15.2M|   } else {
  282|  15.2M|#if defined(BOTAN_CT_VALUE_BARRIER_USE_ASM)
  283|       |      /*
  284|       |      * We may want a "stronger" statement such as
  285|       |      *     asm volatile("" : "+r,m"(x) : : "memory);
  286|       |      * (see https://theunixzoo.co.uk/blog/2021-10-14-preventing-optimisations.html)
  287|       |      * however the current approach seems sufficient with current compilers,
  288|       |      * and is minimally damaging with regards to degrading code generation.
  289|       |      */
  290|  15.2M|      asm("" : "+r"(x) : /* no input */);
  291|  15.2M|      return x;
  292|       |#elif defined(BOTAN_CT_VALUE_BARRIER_USE_VOLATILE)
  293|       |      volatile T vx = x;
  294|       |      return vx;
  295|       |#else
  296|       |      return x;
  297|       |#endif
  298|  15.2M|   }
  299|  15.2M|}
_ZN5Botan2CT13value_barrierImEET_S2_Qaasr3stdE17unsigned_integralIS2_Entsr3stdE7same_asIbS2_E:
  278|  23.6M|{
  279|  23.6M|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (279:7): [Folded - Ignored]
  ------------------
  280|      0|      return x;
  281|  23.6M|   } else {
  282|  23.6M|#if defined(BOTAN_CT_VALUE_BARRIER_USE_ASM)
  283|       |      /*
  284|       |      * We may want a "stronger" statement such as
  285|       |      *     asm volatile("" : "+r,m"(x) : : "memory);
  286|       |      * (see https://theunixzoo.co.uk/blog/2021-10-14-preventing-optimisations.html)
  287|       |      * however the current approach seems sufficient with current compilers,
  288|       |      * and is minimally damaging with regards to degrading code generation.
  289|       |      */
  290|  23.6M|      asm("" : "+r"(x) : /* no input */);
  291|  23.6M|      return x;
  292|       |#elif defined(BOTAN_CT_VALUE_BARRIER_USE_VOLATILE)
  293|       |      volatile T vx = x;
  294|       |      return vx;
  295|       |#else
  296|       |      return x;
  297|       |#endif
  298|  23.6M|   }
  299|  23.6M|}
_ZNK5Botan2CT4MaskImE5valueEv:
  643|  21.9M|      constexpr T value() const { return value_barrier<T>(m_mask); }
_ZN5Botan2CT8is_equalIhEENS0_4MaskIT_EEPKS3_S6_m:
  811|  9.90k|constexpr inline CT::Mask<T> is_equal(const T x[], const T y[], size_t len) {
  812|  9.90k|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (812:7): [Folded - Ignored]
  ------------------
  813|      0|      T difference = 0;
  814|       |
  815|      0|      for(size_t i = 0; i != len; ++i) {
  ------------------
  |  Branch (815:25): [True: 0, False: 0]
  ------------------
  816|      0|         difference = difference | (x[i] ^ y[i]);
  817|      0|      }
  818|       |
  819|      0|      return CT::Mask<T>::is_zero(difference);
  820|  9.90k|   } else {
  821|  9.90k|      volatile T difference = 0;
  822|       |
  823|   326k|      for(size_t i = 0; i != len; ++i) {
  ------------------
  |  Branch (823:25): [True: 316k, False: 9.90k]
  ------------------
  824|   316k|         difference = difference | (x[i] ^ y[i]);
  825|   316k|      }
  826|       |
  827|  9.90k|      return CT::Mask<T>::is_zero(difference);
  828|  9.90k|   }
  829|  9.90k|}
_ZN5Botan2CT4MaskIhE7is_zeroEh:
  456|  19.8k|      static constexpr Mask<T> is_zero(T x) { return Mask<T>(ct_is_zero<T>(value_barrier<T>(x))); }
_ZN5Botan2CT13value_barrierIhEET_S2_Qaasr3stdE17unsigned_integralIS2_Entsr3stdE7same_asIbS2_E:
  278|  39.7k|{
  279|  39.7k|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (279:7): [Folded - Ignored]
  ------------------
  280|      0|      return x;
  281|  39.7k|   } else {
  282|  39.7k|#if defined(BOTAN_CT_VALUE_BARRIER_USE_ASM)
  283|       |      /*
  284|       |      * We may want a "stronger" statement such as
  285|       |      *     asm volatile("" : "+r,m"(x) : : "memory);
  286|       |      * (see https://theunixzoo.co.uk/blog/2021-10-14-preventing-optimisations.html)
  287|       |      * however the current approach seems sufficient with current compilers,
  288|       |      * and is minimally damaging with regards to degrading code generation.
  289|       |      */
  290|  39.7k|      asm("" : "+r"(x) : /* no input */);
  291|  39.7k|      return x;
  292|       |#elif defined(BOTAN_CT_VALUE_BARRIER_USE_VOLATILE)
  293|       |      volatile T vx = x;
  294|       |      return vx;
  295|       |#else
  296|       |      return x;
  297|       |#endif
  298|  39.7k|   }
  299|  39.7k|}
_ZN5Botan2CT4MaskIhEC2Eh:
  650|  19.8k|      constexpr Mask(T m) : m_mask(m) {}
_ZNK5Botan2CT4MaskIhE7as_boolEv:
  633|  19.8k|      constexpr bool as_bool() const { return unpoisoned_value() != 0; }
_ZNK5Botan2CT4MaskIhE16unpoisoned_valueEv:
  617|  19.8k|      constexpr T unpoisoned_value() const {
  618|  19.8k|         T r = value();
  619|  19.8k|         CT::unpoison(r);
  620|  19.8k|         return r;
  621|  19.8k|      }
_ZNK5Botan2CT4MaskIhE5valueEv:
  643|  19.8k|      constexpr T value() const { return value_barrier<T>(m_mask); }
_ZN5Botan2CT8unpoisonITkNSt3__18integralEhEEvRKT_:
  110|  19.8k|constexpr void unpoison(const T& p) {
  111|  19.8k|   unpoison(&p, 1);
  112|  19.8k|}
_ZN5Botan2CT8unpoisonIhEEvPKT_m:
   65|  52.8k|constexpr inline void unpoison(const T* p, size_t n) {
   66|       |#if defined(BOTAN_HAS_VALGRIND)
   67|       |   if(!std::is_constant_evaluated()) {
   68|       |      VALGRIND_MAKE_MEM_DEFINED(p, n * sizeof(T));
   69|       |   }
   70|       |#endif
   71|       |
   72|  52.8k|   BOTAN_UNUSED(p, n);
  ------------------
  |  |  122|  52.8k|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
   73|  52.8k|}
_ZN5Botan2CT6poisonIhEEvPKT_m:
   54|  19.8k|constexpr inline void poison(const T* p, size_t n) {
   55|       |#if defined(BOTAN_HAS_VALGRIND)
   56|       |   if(!std::is_constant_evaluated()) {
   57|       |      VALGRIND_MAKE_MEM_UNDEFINED(p, n * sizeof(T));
   58|       |   }
   59|       |#endif
   60|       |
   61|  19.8k|   BOTAN_UNUSED(p, n);
  ------------------
  |  |  122|  19.8k|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
   62|  19.8k|}
_ZN5Botan2CT4MaskIjE8is_equalEjj:
  461|  3.80M|      static constexpr Mask<T> is_equal(T x, T y) {
  462|  3.80M|         const T diff = value_barrier(x) ^ value_barrier(y);
  463|  3.80M|         return Mask<T>::is_zero(diff);
  464|  3.80M|      }
_ZN5Botan2CT4MaskIjE7is_zeroEj:
  456|  3.80M|      static constexpr Mask<T> is_zero(T x) { return Mask<T>(ct_is_zero<T>(value_barrier<T>(x))); }
_ZN5Botan2CT4MaskIjEC2Ej:
  650|  3.80M|      constexpr Mask(T m) : m_mask(m) {}
_ZNK5Botan2CT4MaskIjE5valueEv:
  643|  3.80M|      constexpr T value() const { return value_barrier<T>(m_mask); }
_ZN5Botan2CT8unpoisonITkNS_6ranges14spanable_rangeENSt3__14spanIhLm32EEEQaasr3stdE23is_trivially_copyable_vINS3_11conditionalIXsr21__is_primary_templateINS3_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS3_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS3_26indirectly_readable_traitsISD_EESE_E4type10value_typeEEnt19custom_unpoisonableISA_EEEvRKSA_:
  126|  6.60k|constexpr void unpoison(const R& r) {
  127|  6.60k|   std::span s{r};
  128|  6.60k|   unpoison(s.data(), s.size());
  129|  6.60k|}
_ZN5Botan2CT9all_zerosIhEENS0_4MaskIT_EEPKS3_m:
  798|  9.97k|constexpr inline CT::Mask<T> all_zeros(const T elem[], size_t len) {
  799|  9.97k|   T sum = 0;
  800|   329k|   for(size_t i = 0; i != len; ++i) {
  ------------------
  |  Branch (800:22): [True: 319k, False: 9.97k]
  ------------------
  801|   319k|      sum |= elem[i];
  802|   319k|   }
  803|  9.97k|   return CT::Mask<T>::is_zero(sum);
  804|  9.97k|}
_ZN5Botan2CT4MaskImEC2Em:
  650|  3.16M|      constexpr Mask(T m) : m_mask(m) {}
_ZN5Botan2CT4MaskImE14expand_top_bitEm:
  434|  1.68M|      static constexpr Mask<T> expand_top_bit(T v) { return Mask<T>(Botan::expand_top_bit<T>(value_barrier<T>(v))); }
_ZNK5Botan2CT4MaskImE13if_set_returnEm:
  557|  19.0M|      constexpr T if_set_return(T x) const { return value() & x; }
_ZN5Botan2CT4MaskImE10expand_bitEmm:
  440|  1.68M|      static constexpr Mask<T> expand_bit(T v, size_t bit) {
  441|  1.68M|         return CT::Mask<T>::expand_top_bit(v << (sizeof(v) * 8 - 1 - bit));
  442|  1.68M|      }
_ZN5Botan2CTeoENS0_4MaskImEES2_:
  542|  1.47M|      friend Mask<T> operator^(Mask<T> x, Mask<T> y) { return Mask<T>(x.value() ^ y.value()); }

_ZN5Botan11carry_shiftEom:
  143|  93.2M|inline uint64_t carry_shift(const uint128_t a, size_t shift) {
  144|  93.2M|   return static_cast<uint64_t>(a >> shift);
  145|  93.2M|}
_ZN5Botan13combine_lowerEomom:
  147|  26.4k|inline uint64_t combine_lower(const uint128_t a, size_t s1, const uint128_t b, size_t s2) {
  148|  26.4k|   return static_cast<uint64_t>((a >> s1) | (b << s2));
  149|  26.4k|}

_ZN5Botan20Ed25519_FieldElementC2Ev:
   34|  36.4M|      constexpr Ed25519_FieldElement() { clear_mem(m_fe, 10); }
_ZN5Botan20Ed25519_FieldElement4zeroEv:
   36|   455k|      constexpr static Ed25519_FieldElement zero() { return Ed25519_FieldElement(); }
_ZN5Botan20Ed25519_FieldElement3oneEv:
   38|   891k|      constexpr static Ed25519_FieldElement one() {
   39|   891k|         auto o = Ed25519_FieldElement();
   40|   891k|         o.m_fe[0] = 1;
   41|   891k|         return o;
   42|   891k|      }
_ZN5BotanmlERKNS_20Ed25519_FieldElementES2_:
  143|  11.4M|inline Ed25519_FieldElement operator*(const Ed25519_FieldElement& x, const Ed25519_FieldElement& y) {
  144|  11.4M|   return Ed25519_FieldElement::mul(x, y);
  145|  11.4M|}
_ZN5BotanplERKNS_20Ed25519_FieldElementES2_:
  135|  6.75M|inline Ed25519_FieldElement operator+(const Ed25519_FieldElement& x, const Ed25519_FieldElement& y) {
  136|  6.75M|   return Ed25519_FieldElement::add(x, y);
  137|  6.75M|}
_ZN5Botan20Ed25519_FieldElement3addERKS0_S2_:
   89|  6.75M|      static Ed25519_FieldElement add(const Ed25519_FieldElement& a, const Ed25519_FieldElement& b) {
   90|  6.75M|         Ed25519_FieldElement z;
   91|  74.3M|         for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (91:28): [True: 67.5M, False: 6.75M]
  ------------------
   92|  67.5M|            z.m_fe[i] = a.m_fe[i] + b.m_fe[i];
   93|  67.5M|         }
   94|  6.75M|         return z;
   95|  6.75M|      }
_ZN5BotanmiERKNS_20Ed25519_FieldElementES2_:
  139|  7.63M|inline Ed25519_FieldElement operator-(const Ed25519_FieldElement& x, const Ed25519_FieldElement& y) {
  140|  7.63M|   return Ed25519_FieldElement::sub(x, y);
  141|  7.63M|}
_ZN5Botan20Ed25519_FieldElement3subERKS0_S2_:
   97|  7.63M|      static Ed25519_FieldElement sub(const Ed25519_FieldElement& a, const Ed25519_FieldElement& b) {
   98|  7.63M|         Ed25519_FieldElement z;
   99|  83.9M|         for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (99:28): [True: 76.3M, False: 7.63M]
  ------------------
  100|  76.3M|            z.m_fe[i] = a.m_fe[i] - b.m_fe[i];
  101|  76.3M|         }
  102|  7.63M|         return z;
  103|  7.63M|      }
_ZN5Botan20Ed25519_FieldElementixEm:
  129|   177M|      int32_t& operator[](size_t i) { return m_fe[i]; }
_ZNK5Botan20Ed25519_FieldElementixEm:
  127|   101M|      int32_t operator[](size_t i) const { return m_fe[i]; }
_ZN5BotanngERKNS_20Ed25519_FieldElementE:
  147|   425k|inline Ed25519_FieldElement operator-(const Ed25519_FieldElement& x) {
  148|   425k|   return Ed25519_FieldElement::negate(x);
  149|   425k|}
_ZN5Botan20Ed25519_FieldElement6negateERKS0_:
  105|   425k|      static Ed25519_FieldElement negate(const Ed25519_FieldElement& a) {
  106|   425k|         Ed25519_FieldElement z;
  107|  4.68M|         for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (107:28): [True: 4.25M, False: 425k]
  ------------------
  108|  4.25M|            z.m_fe[i] = -a.m_fe[i];
  109|  4.25M|         }
  110|   425k|         return z;
  111|   425k|      }
_ZNK5Botan20Ed25519_FieldElement3sqrEv:
  117|  5.15M|      Ed25519_FieldElement sqr() const { return sqr_iter(1); }
_ZNK5Botan20Ed25519_FieldElement11is_negativeEv:
   82|  19.8k|      bool is_negative() const {
   83|       |         // TODO could avoid most of the serialize computation here
   84|  19.8k|         std::array<uint8_t, 32> s;
   85|  19.8k|         this->serialize_to(s);
   86|  19.8k|         return s[0] & 1;
   87|  19.8k|      }
_ZNK5Botan20Ed25519_FieldElement7is_zeroEv:
   72|  9.97k|      bool is_zero() const {
   73|  9.97k|         std::array<uint8_t, 32> value;
   74|  9.97k|         this->serialize_to(value);
   75|  9.97k|         return CT::all_zeros(value.data(), value.size()).as_bool();
   76|  9.97k|      }
_ZN5Botan20Ed25519_FieldElementC2Ellllllllll:
   55|  18.5M|                                     int64_t h9) {
   56|  18.5M|         m_fe[0] = static_cast<int32_t>(h0);
   57|  18.5M|         m_fe[1] = static_cast<int32_t>(h1);
   58|  18.5M|         m_fe[2] = static_cast<int32_t>(h2);
   59|  18.5M|         m_fe[3] = static_cast<int32_t>(h3);
   60|  18.5M|         m_fe[4] = static_cast<int32_t>(h4);
   61|  18.5M|         m_fe[5] = static_cast<int32_t>(h5);
   62|  18.5M|         m_fe[6] = static_cast<int32_t>(h6);
   63|  18.5M|         m_fe[7] = static_cast<int32_t>(h7);
   64|  18.5M|         m_fe[8] = static_cast<int32_t>(h8);
   65|  18.5M|         m_fe[9] = static_cast<int32_t>(h9);
   66|  18.5M|      }

_ZN5Botan6load_3EPKh:
   18|   221k|inline uint64_t load_3(const uint8_t in[3]) {
   19|   221k|   return static_cast<uint64_t>(in[0]) | (static_cast<uint64_t>(in[1]) << 8) | (static_cast<uint64_t>(in[2]) << 16);
   20|   221k|}
_ZN5Botan6load_4EPKh:
   22|   201k|inline uint64_t load_4(const uint8_t* in) {
   23|   201k|   return load_le<uint32_t>(in, 0);
   24|   201k|}
_ZN5Botan8redc_mulERlS0_S0_S0_S0_S0_S0_:
   57|   184k|inline void redc_mul(int64_t& s1, int64_t& s2, int64_t& s3, int64_t& s4, int64_t& s5, int64_t& s6, int64_t& X) {
   58|   184k|   s1 += X * 666643;
   59|   184k|   s2 += X * 470296;
   60|   184k|   s3 += X * 654183;
   61|   184k|   s4 -= X * 997805;
   62|   184k|   s5 += X * 136657;
   63|   184k|   s6 -= X * 683901;
   64|   184k|   X = 0;
   65|   184k|}
_ZN5Botan5carryILm26ELl1EEEvRlS1_QaagtT_Li0EltT_Li64E:
   29|   163M|{
   30|   163M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   31|   163M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   32|   163M|   int64_t c = (h0 + X2) >> S;
   33|   163M|   h1 += c * MUL;
   34|   163M|   h0 -= c * X1;
   35|   163M|}
_ZN5Botan5carryILm25ELl1EEEvRlS1_QaagtT_Li0EltT_Li64E:
   29|  93.3M|{
   30|  93.3M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   31|  93.3M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   32|  93.3M|   int64_t c = (h0 + X2) >> S;
   33|  93.3M|   h1 += c * MUL;
   34|  93.3M|   h0 -= c * X1;
   35|  93.3M|}
_ZN5Botan5carryILm25ELl19EEEvRlS1_QaagtT_Li0EltT_Li64E:
   29|  23.3M|{
   30|  23.3M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   31|  23.3M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   32|  23.3M|   int64_t c = (h0 + X2) >> S;
   33|  23.3M|   h1 += c * MUL;
   34|  23.3M|   h0 -= c * X1;
   35|  23.3M|}
_ZN5Botan6carry0ILm26EEEvRiS1_QaagtT_Li0EltT_Li32E:
   50|   214k|{
   51|   214k|   const int32_t X1 = (static_cast<int64_t>(1) << S);
   52|   214k|   int32_t c = h0 >> S;
   53|   214k|   h1 += c;
   54|   214k|   h0 -= c * X1;
   55|   214k|}
_ZN5Botan6carry0ILm25EEEvRiS1_QaagtT_Li0EltT_Li32E:
   50|   171k|{
   51|   171k|   const int32_t X1 = (static_cast<int64_t>(1) << S);
   52|   171k|   int32_t c = h0 >> S;
   53|   171k|   h1 += c;
   54|   171k|   h0 -= c * X1;
   55|   171k|}
_ZN5Botan5carryILm21ELl1EEEvRlS1_QaagtT_Li0EltT_Li64E:
   29|   379k|{
   30|   379k|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   31|   379k|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   32|   379k|   int64_t c = (h0 + X2) >> S;
   33|   379k|   h1 += c * MUL;
   34|   379k|   h0 -= c * X1;
   35|   379k|}
_ZN5Botan6carry0ILm21EEEvRlS1_QaagtT_Li0EltT_Li64E:
   40|   313k|{
   41|   313k|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   42|   313k|   int64_t c = h0 >> S;
   43|   313k|   h1 += c;
   44|   313k|   h0 -= c * X1;
   45|   313k|}

_ZN5Botan11checked_mulITkNSt3__117unsigned_integralEmEENS1_8optionalIT_EES3_S3_:
   46|   148k|constexpr inline std::optional<T> checked_mul(T a, T b) {
   47|       |   // Multiplication by 1U is a hack to work around C's insane
   48|       |   // integer promotion rules.
   49|       |   // https://stackoverflow.com/questions/24795651
   50|   148k|   const T r = (1U * a) * b;
   51|       |   // If a == 0 then the multiply certainly did not overflow
   52|       |   // Otherwise r / a == b unless overflow occured
   53|   148k|   if(a != 0 && r / a != b) {
  ------------------
  |  Branch (53:7): [True: 148k, False: 0]
  |  Branch (53:17): [True: 0, False: 148k]
  ------------------
   54|      0|      return {};
   55|      0|   }
   56|   148k|   return r;
   57|   148k|}

_ZN5Botan6detail24wrap_strong_type_or_enumITkNS0_20unsigned_integralishEjTkNSt3__117unsigned_integralEjEEDaT0_:
  200|   201k|constexpr auto wrap_strong_type_or_enum(T t) {
  201|       |   if constexpr(std::is_enum_v<OutT>) {
  202|       |      return static_cast<OutT>(t);
  203|   201k|   } else {
  204|   201k|      return Botan::wrap_strong_type<OutT>(t);
  205|   201k|   }
  206|   201k|}
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm4EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_:
  278|   201k|inline constexpr WrappedOutT load_any(InR&& in_range) {
  279|   201k|   using OutT = detail::wrapped_type<WrappedOutT>;
  280|   201k|   ranges::assert_exact_byte_length<sizeof(OutT)>(in_range);
  281|       |
  282|   201k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|   201k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  287|   201k|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|   201k|      } else {
  289|   201k|         std::span in{in_range};
  290|   201k|         if constexpr(sizeof(OutT) == 1) {
  291|   201k|            return static_cast<OutT>(in[0]);
  292|   201k|         } else if constexpr(endianness == std::endian::native) {
  293|   201k|            return typecast_copy<OutT>(in);
  294|   201k|         } else {
  295|   201k|            static_assert(opposite(endianness) == std::endian::native);
  296|   201k|            return reverse_bytes(typecast_copy<OutT>(in));
  297|   201k|         }
  298|   201k|      }
  299|   201k|   }());
  300|   201k|}
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjEET0_PKhm:
  454|   201k|inline constexpr OutT load_any(const uint8_t in[], size_t off) {
  455|       |   // asserts that *in points to enough bytes to read at offset off
  456|   201k|   constexpr size_t out_size = sizeof(OutT);
  457|   201k|   return load_any<endianness, OutT>(std::span<const uint8_t, out_size>(in + off * out_size, out_size));
  458|   201k|}
_ZN5Botan7load_leIjJRPKhiEEEDaDpOT0_:
  495|   201k|inline constexpr auto load_le(ParamTs&&... params) {
  496|   201k|   return detail::load_any<std::endian::little, OutT>(std::forward<ParamTs>(params)...);
  497|   201k|}
_ZN5Botan8store_leINS_6detail10AutoDetectEJNSt3__14spanIhLm8EEEmEEEDaDpOT0_:
  736|  6.60k|inline constexpr auto store_le(ParamTs&&... params) {
  737|  6.60k|   return detail::store_any<std::endian::little, ModifierT>(std::forward<ParamTs>(params)...);
  738|  6.60k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  6.60k|inline constexpr void store_any(OutR&& out /* NOLINT(*-std-forward) */, Ts... ins) {
  583|  6.60k|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  6.60k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  6.60k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  6.60k|      off += sizeof(T);
  587|  6.60k|   };
  588|       |
  589|  6.60k|   (store_one(std::span{out}, ins), ...);
  590|  6.60k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clImS8_EEDaS9_SE_:
  584|  6.60k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  6.60k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  6.60k|      off += sizeof(T);
  587|  6.60k|   };
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEEQnt15custom_storableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEEvS9_OT1_:
  525|  33.0k|inline constexpr void store_any(WrappedInT wrapped_in, OutR&& out_range) {
  526|  33.0k|   const auto in = detail::unwrap_strong_type_or_enum(wrapped_in);
  527|  33.0k|   using InT = decltype(in);
  528|  33.0k|   ranges::assert_exact_byte_length<sizeof(in)>(out_range);
  529|  33.0k|   std::span out{out_range};
  530|       |
  531|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  532|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  533|       |   // in a `constexpr` context.
  534|  33.0k|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (534:7): [Folded - Ignored]
  ------------------
  535|      0|      return fallback_store_any<endianness, InT>(in, std::forward<OutR>(out_range));
  536|  33.0k|   } else {
  537|       |      if constexpr(sizeof(InT) == 1) {
  538|       |         out[0] = static_cast<uint8_t>(in);
  539|  33.0k|      } else if constexpr(endianness == std::endian::native) {
  540|  33.0k|         typecast_copy(out, in);
  541|       |      } else {
  542|       |         static_assert(opposite(endianness) == std::endian::native);
  543|       |         typecast_copy(out, reverse_bytes(in));
  544|       |      }
  545|  33.0k|   }
  546|  33.0k|}
_ZN5Botan6detail26unwrap_strong_type_or_enumITkNS0_20unsigned_integralishEmEEDaT_:
  190|  1.72M|constexpr auto unwrap_strong_type_or_enum(InT t) {
  191|       |   if constexpr(std::is_enum_v<InT>) {
  192|       |      // TODO: C++23: use std::to_underlying(in) instead
  193|       |      return static_cast<std::underlying_type_t<InT>>(t);
  194|  1.72M|   } else {
  195|  1.72M|      return Botan::unwrap_strong_type(t);
  196|  1.72M|   }
  197|  1.72M|}
_ZN5Botan8store_leINS_6detail10AutoDetectEJNSt3__14spanIhLm4EEEjEEEDaDpOT0_:
  736|  6.60k|inline constexpr auto store_le(ParamTs&&... params) {
  737|  6.60k|   return detail::store_any<std::endian::little, ModifierT>(std::forward<ParamTs>(params)...);
  738|  6.60k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm4EEETpTkNS0_20unsigned_integralishEJjEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  6.60k|inline constexpr void store_any(OutR&& out /* NOLINT(*-std-forward) */, Ts... ins) {
  583|  6.60k|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  6.60k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  6.60k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  6.60k|      off += sizeof(T);
  587|  6.60k|   };
  588|       |
  589|  6.60k|   (store_one(std::span{out}, ins), ...);
  590|  6.60k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm4EEETpTkNS0_20unsigned_integralishEJjEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clIjS8_EEDaS9_SE_:
  584|  6.60k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  6.60k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  6.60k|      off += sizeof(T);
  587|  6.60k|   };
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm4EEEQnt15custom_storableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEEvS9_OT1_:
  525|  6.60k|inline constexpr void store_any(WrappedInT wrapped_in, OutR&& out_range) {
  526|  6.60k|   const auto in = detail::unwrap_strong_type_or_enum(wrapped_in);
  527|  6.60k|   using InT = decltype(in);
  528|  6.60k|   ranges::assert_exact_byte_length<sizeof(in)>(out_range);
  529|  6.60k|   std::span out{out_range};
  530|       |
  531|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  532|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  533|       |   // in a `constexpr` context.
  534|  6.60k|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (534:7): [Folded - Ignored]
  ------------------
  535|      0|      return fallback_store_any<endianness, InT>(in, std::forward<OutR>(out_range));
  536|  6.60k|   } else {
  537|       |      if constexpr(sizeof(InT) == 1) {
  538|       |         out[0] = static_cast<uint8_t>(in);
  539|  6.60k|      } else if constexpr(endianness == std::endian::native) {
  540|  6.60k|         typecast_copy(out, in);
  541|       |      } else {
  542|       |         static_assert(opposite(endianness) == std::endian::native);
  543|       |         typecast_copy(out, reverse_bytes(in));
  544|       |      }
  545|  6.60k|   }
  546|  6.60k|}
_ZN5Botan6detail26unwrap_strong_type_or_enumITkNS0_20unsigned_integralishEjEEDaT_:
  190|  6.60k|constexpr auto unwrap_strong_type_or_enum(InT t) {
  191|       |   if constexpr(std::is_enum_v<InT>) {
  192|       |      // TODO: C++23: use std::to_underlying(in) instead
  193|       |      return static_cast<std::underlying_type_t<InT>>(t);
  194|  6.60k|   } else {
  195|  6.60k|      return Botan::unwrap_strong_type(t);
  196|  6.60k|   }
  197|  6.60k|}
_ZN5Botan8store_beINS_6detail10AutoDetectEJRKmPhEEEDaDpOT0_:
  745|   188k|inline constexpr auto store_be(ParamTs&&... params) {
  746|   188k|   return detail::store_any<std::endian::big, ModifierT>(std::forward<ParamTs>(params)...);
  747|   188k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206ENS0_10AutoDetectETkNS0_20unsigned_integralishEmQoosr3stdE7same_asIS4_T0_Esr3stdE7same_asIT1_S5_EEEvS6_Ph:
  711|   188k|inline constexpr void store_any(T in, uint8_t out[]) {
  712|       |   // asserts that *out points to enough bytes to write into
  713|   188k|   store_any<endianness, InT>(in, std::span<uint8_t, sizeof(T)>(out, sizeof(T)));
  714|   188k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206ENS0_10AutoDetectETkNS0_20unsigned_integralishEmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEEQsr3stdE7same_asIS4_T0_EEEvT1_OT2_:
  646|   188k|inline constexpr void store_any(T in, OutR&& out_range) {
  647|   188k|   store_any<endianness, T>(in, std::forward<OutR>(out_range));
  648|   188k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206ETkNS0_20unsigned_integralishEmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEEQnt15custom_storableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEEvS9_OT1_:
  525|  1.69M|inline constexpr void store_any(WrappedInT wrapped_in, OutR&& out_range) {
  526|  1.69M|   const auto in = detail::unwrap_strong_type_or_enum(wrapped_in);
  527|  1.69M|   using InT = decltype(in);
  528|  1.69M|   ranges::assert_exact_byte_length<sizeof(in)>(out_range);
  529|  1.69M|   std::span out{out_range};
  530|       |
  531|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  532|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  533|       |   // in a `constexpr` context.
  534|  1.69M|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (534:7): [Folded - Ignored]
  ------------------
  535|      0|      return fallback_store_any<endianness, InT>(in, std::forward<OutR>(out_range));
  536|  1.69M|   } else {
  537|       |      if constexpr(sizeof(InT) == 1) {
  538|       |         out[0] = static_cast<uint8_t>(in);
  539|       |      } else if constexpr(endianness == std::endian::native) {
  540|       |         typecast_copy(out, in);
  541|  1.69M|      } else {
  542|  1.69M|         static_assert(opposite(endianness) == std::endian::native);
  543|  1.69M|         typecast_copy(out, reverse_bytes(in));
  544|  1.69M|      }
  545|  1.69M|   }
  546|  1.69M|}
_ZN5Botan6detail24wrap_strong_type_or_enumITkNS0_20unsigned_integralishEmTkNSt3__117unsigned_integralEmEEDaT0_:
  200|  46.2k|constexpr auto wrap_strong_type_or_enum(T t) {
  201|       |   if constexpr(std::is_enum_v<OutT>) {
  202|       |      return static_cast<OutT>(t);
  203|  46.2k|   } else {
  204|  46.2k|      return Botan::wrap_strong_type<OutT>(t);
  205|  46.2k|   }
  206|  46.2k|}
_ZN5Botan11copy_out_beITkNS_6ranges14spanable_rangeENSt3__16vectorImNS_16secure_allocatorImEEEEEEvNS2_4spanIhLm18446744073709551615EEERKT_:
  773|   188k|inline void copy_out_be(std::span<uint8_t> out, const InR& in) {
  774|   188k|   using T = std::ranges::range_value_t<InR>;
  775|   188k|   std::span<const T> in_s{in};
  776|   188k|   const auto remaining_bytes = detail::copy_out_any_word_aligned_portion<std::endian::big>(out, in_s);
  777|       |
  778|       |   // copy remaining bytes as a partial word
  779|   188k|   for(size_t i = 0; i < remaining_bytes; ++i) {
  ------------------
  |  Branch (779:22): [True: 0, False: 188k]
  ------------------
  780|      0|      out[i] = get_byte_var(i, in_s.front());
  781|      0|   }
  782|   188k|}
_ZN5Botan6detail33copy_out_any_word_aligned_portionILNSt3__16endianE64206ETkNS0_20unsigned_integralishEmEEmRNS2_4spanIhLm18446744073709551615EEERNS4_IKT0_Lm18446744073709551615EEE:
  752|   188k|inline size_t copy_out_any_word_aligned_portion(std::span<uint8_t>& out, std::span<const T>& in) {
  753|   188k|   const size_t full_words = out.size() / sizeof(T);
  754|   188k|   const size_t full_word_bytes = full_words * sizeof(T);
  755|   188k|   const size_t remaining_bytes = out.size() - full_word_bytes;
  756|   188k|   BOTAN_ASSERT_NOMSG(in.size_bytes() >= full_word_bytes + remaining_bytes);
  ------------------
  |  |   64|   188k|   do {                                                                     \
  |  |   65|   188k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 188k]
  |  |  ------------------
  |  |   66|   188k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   188k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  757|       |
  758|       |   // copy full words
  759|   188k|   store_any<endianness, T>(out.first(full_word_bytes), in.first(full_words));
  760|   188k|   out = out.subspan(full_word_bytes);
  761|   188k|   in = in.subspan(full_words);
  762|       |
  763|   188k|   return remaining_bytes;
  764|   188k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm18446744073709551615EEETkNS4_14spanable_rangeENS6_IKmLm18446744073709551615EEEQoosr3stdE7same_asINS0_10AutoDetectET0_Esr3stdE7same_asISB_NS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT2_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISJ_EESK_E4type10value_typeEEEEvOT1_RKSG_:
  603|   188k|inline constexpr void store_any(OutR&& out /* NOLINT(*-std-forward) */, const InR& in) {
  604|   188k|   ranges::assert_equal_byte_lengths(out, in);
  605|   188k|   using element_type = std::ranges::range_value_t<InR>;
  606|       |
  607|   188k|   auto store_elementwise = [&] {
  608|   188k|      constexpr size_t bytes_per_element = sizeof(element_type);
  609|   188k|      std::span<uint8_t> out_s(out);
  610|   188k|      for(auto in_elem : in) {
  611|   188k|         store_any<endianness, element_type>(out_s.template first<bytes_per_element>(), in_elem);
  612|   188k|         out_s = out_s.subspan(bytes_per_element);
  613|   188k|      }
  614|   188k|   };
  615|       |
  616|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  617|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  618|       |   // in a `constexpr` context.
  619|   188k|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (619:7): [Folded - Ignored]
  ------------------
  620|      0|      store_elementwise();
  621|   188k|   } else {
  622|       |      if constexpr(endianness == std::endian::native && !custom_storable<element_type>) {
  623|       |         typecast_copy(out, in);
  624|   188k|      } else {
  625|   188k|         store_elementwise();
  626|   188k|      }
  627|   188k|   }
  628|   188k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm18446744073709551615EEETkNS4_14spanable_rangeENS6_IKmLm18446744073709551615EEEQoosr3stdE7same_asINS0_10AutoDetectET0_Esr3stdE7same_asISB_NS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT2_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISJ_EESK_E4type10value_typeEEEEvOT1_RKSG_ENKUlvE_clEv:
  607|   188k|   auto store_elementwise = [&] {
  608|   188k|      constexpr size_t bytes_per_element = sizeof(element_type);
  609|   188k|      std::span<uint8_t> out_s(out);
  610|  1.50M|      for(auto in_elem : in) {
  ------------------
  |  Branch (610:24): [True: 1.50M, False: 188k]
  ------------------
  611|  1.50M|         store_any<endianness, element_type>(out_s.template first<bytes_per_element>(), in_elem);
  612|  1.50M|         out_s = out_s.subspan(bytes_per_element);
  613|  1.50M|      }
  614|   188k|   };
_ZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  1.50M|inline constexpr void store_any(OutR&& out /* NOLINT(*-std-forward) */, Ts... ins) {
  583|  1.50M|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  1.50M|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  1.50M|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  1.50M|      off += sizeof(T);
  587|  1.50M|   };
  588|       |
  589|  1.50M|   (store_one(std::span{out}, ins), ...);
  590|  1.50M|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clImS7_EEDaS9_SE_:
  584|  1.50M|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  1.50M|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  1.50M|      off += sizeof(T);
  587|  1.50M|   };
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm8EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_:
  278|  46.2k|inline constexpr WrappedOutT load_any(InR&& in_range) {
  279|  46.2k|   using OutT = detail::wrapped_type<WrappedOutT>;
  280|  46.2k|   ranges::assert_exact_byte_length<sizeof(OutT)>(in_range);
  281|       |
  282|  46.2k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|  46.2k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  287|  46.2k|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|  46.2k|      } else {
  289|  46.2k|         std::span in{in_range};
  290|  46.2k|         if constexpr(sizeof(OutT) == 1) {
  291|  46.2k|            return static_cast<OutT>(in[0]);
  292|  46.2k|         } else if constexpr(endianness == std::endian::native) {
  293|  46.2k|            return typecast_copy<OutT>(in);
  294|  46.2k|         } else {
  295|  46.2k|            static_assert(opposite(endianness) == std::endian::native);
  296|  46.2k|            return reverse_bytes(typecast_copy<OutT>(in));
  297|  46.2k|         }
  298|  46.2k|      }
  299|  46.2k|   }());
  300|  46.2k|}
_ZN5Botan7load_leImJRPKhiEEEDaDpOT0_:
  495|  6.60k|inline constexpr auto load_le(ParamTs&&... params) {
  496|  6.60k|   return detail::load_any<std::endian::little, OutT>(std::forward<ParamTs>(params)...);
  497|  6.60k|}
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmEET0_PKhm:
  454|  46.2k|inline constexpr OutT load_any(const uint8_t in[], size_t off) {
  455|       |   // asserts that *in points to enough bytes to read at offset off
  456|  46.2k|   constexpr size_t out_size = sizeof(OutT);
  457|  46.2k|   return load_any<endianness, OutT>(std::span<const uint8_t, out_size>(in + off * out_size, out_size));
  458|  46.2k|}
_ZZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm8EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_ENKUlvE_clEv:
  282|  46.2k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|  46.2k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (286:10): [Folded - Ignored]
  ------------------
  287|      0|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|  46.2k|      } else {
  289|  46.2k|         std::span in{in_range};
  290|       |         if constexpr(sizeof(OutT) == 1) {
  291|       |            return static_cast<OutT>(in[0]);
  292|  46.2k|         } else if constexpr(endianness == std::endian::native) {
  293|  46.2k|            return typecast_copy<OutT>(in);
  294|       |         } else {
  295|       |            static_assert(opposite(endianness) == std::endian::native);
  296|       |            return reverse_bytes(typecast_copy<OutT>(in));
  297|       |         }
  298|  46.2k|      }
  299|  46.2k|   }());
_ZN5Botan7load_leImJPKhiEEEDaDpOT0_:
  495|  39.6k|inline constexpr auto load_le(ParamTs&&... params) {
  496|  39.6k|   return detail::load_any<std::endian::little, OutT>(std::forward<ParamTs>(params)...);
  497|  39.6k|}
_ZZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm4EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_ENKUlvE_clEv:
  282|   201k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|   201k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (286:10): [Folded - Ignored]
  ------------------
  287|      0|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|   201k|      } else {
  289|   201k|         std::span in{in_range};
  290|       |         if constexpr(sizeof(OutT) == 1) {
  291|       |            return static_cast<OutT>(in[0]);
  292|   201k|         } else if constexpr(endianness == std::endian::native) {
  293|   201k|            return typecast_copy<OutT>(in);
  294|       |         } else {
  295|       |            static_assert(opposite(endianness) == std::endian::native);
  296|       |            return reverse_bytes(typecast_copy<OutT>(in));
  297|       |         }
  298|   201k|      }
  299|   201k|   }());
_ZN5Botan8store_leINS_6detail10AutoDetectEJRPhmmmmEEEDaDpOT0_:
  736|  6.60k|inline constexpr auto store_le(ParamTs&&... params) {
  737|  6.60k|   return detail::store_any<std::endian::little, ModifierT>(std::forward<ParamTs>(params)...);
  738|  6.60k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS0_20unsigned_integralishEmTpTkNS0_20unsigned_integralishEJmmmEQaaoosr3stdE7same_asIS4_T0_Esr3stdE7same_asIT1_S5_E10all_same_vIS6_DpT2_EEEvPhS6_S8_:
  723|  6.60k|inline constexpr void store_any(uint8_t out[], T0 in0, Ts... ins) {
  724|  6.60k|   constexpr auto bytes = sizeof(in0) + (sizeof(ins) + ... + 0);
  725|       |   // asserts that *out points to the correct amount of memory
  726|  6.60k|   store_any<endianness, T0>(std::span<uint8_t, bytes>(out, bytes), in0, ins...);
  727|  6.60k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm32EEETpTkNS0_20unsigned_integralishEJmmmmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  6.60k|inline constexpr void store_any(OutR&& out /* NOLINT(*-std-forward) */, Ts... ins) {
  583|  6.60k|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  6.60k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  6.60k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  6.60k|      off += sizeof(T);
  587|  6.60k|   };
  588|       |
  589|  6.60k|   (store_one(std::span{out}, ins), ...);
  590|  6.60k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE57005EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm32EEETpTkNS0_20unsigned_integralishEJmmmmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clImS7_EEDaS9_SE_:
  584|  26.4k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  26.4k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  26.4k|      off += sizeof(T);
  587|  26.4k|   };

_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EEC2Ev:
   42|  19.8k|      MerkleDamgard_Hash() { clear(); }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE5clearEv:
   70|   247k|      void clear() {
   71|   247k|         MD::init(m_digest);
   72|   247k|         m_buffer.clear();
   73|   247k|         m_count = 0;
   74|   247k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE6updateENSt3__14spanIKhLm18446744073709551615EEE:
   44|   488k|      void update(std::span<const uint8_t> input) {
   45|   488k|         BufferSlicer in(input);
   46|       |
   47|   988k|         while(!in.empty()) {
  ------------------
  |  Branch (47:16): [True: 500k, False: 488k]
  ------------------
   48|   500k|            if(const auto one_block = m_buffer.handle_unaligned_data(in)) {
  ------------------
  |  Branch (48:27): [True: 9.90k, False: 490k]
  ------------------
   49|  9.90k|               MD::compress_n(m_digest, one_block.value(), 1);
   50|  9.90k|            }
   51|       |
   52|   500k|            if(m_buffer.in_alignment()) {
  ------------------
  |  Branch (52:16): [True: 219k, False: 280k]
  ------------------
   53|   219k|               const auto [aligned_data, full_blocks] = m_buffer.aligned_data_to_process(in);
   54|   219k|               if(full_blocks > 0) {
  ------------------
  |  Branch (54:19): [True: 209k, False: 9.90k]
  ------------------
   55|   209k|                  MD::compress_n(m_digest, aligned_data, full_blocks);
   56|   209k|               }
   57|   219k|            }
   58|   500k|         }
   59|       |
   60|   488k|         m_count += input.size();
   61|   488k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE5finalENSt3__14spanIhLm18446744073709551615EEE:
   63|   188k|      void final(std::span<uint8_t> output) {
   64|   188k|         append_padding_bit();
   65|   188k|         append_counter_and_finalize();
   66|   188k|         copy_output(output);
   67|   188k|         clear();
   68|   188k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE18append_padding_bitEv:
   77|   188k|      void append_padding_bit() {
   78|   188k|         BOTAN_ASSERT_NOMSG(!m_buffer.ready_to_consume());
  ------------------
  |  |   64|   188k|   do {                                                                     \
  |  |   65|   188k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 188k]
  |  |  ------------------
  |  |   66|   188k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   188k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|   188k|         if constexpr(MD::bit_endianness == MD_Endian::Big) {
   80|   188k|            const uint8_t final_byte = 0x80;
   81|   188k|            m_buffer.append({&final_byte, 1});
   82|       |         } else {
   83|       |            const uint8_t final_byte = 0x01;
   84|       |            m_buffer.append({&final_byte, 1});
   85|       |         }
   86|   188k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE27append_counter_and_finalizeEv:
   88|   188k|      void append_counter_and_finalize() {
   89|       |         // Compress the remaining data if the final data block does not provide
   90|       |         // enough space for the counter bytes.
   91|   188k|         if(m_buffer.elements_until_alignment() < MD::ctr_bytes) {
  ------------------
  |  Branch (91:13): [True: 264, False: 187k]
  ------------------
   92|    264|            m_buffer.fill_up_with_zeros();
   93|    264|            MD::compress_n(m_digest, m_buffer.consume(), 1);
   94|    264|         }
   95|       |
   96|       |         // Make sure that any remaining bytes in the very last block are zero.
   97|   188k|         BOTAN_ASSERT_NOMSG(m_buffer.elements_until_alignment() >= MD::ctr_bytes);
  ------------------
  |  |   64|   188k|   do {                                                                     \
  |  |   65|   188k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 188k]
  |  |  ------------------
  |  |   66|   188k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   188k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   98|   188k|         m_buffer.fill_up_with_zeros();
   99|       |
  100|       |         // Replace a bunch of the right-most zero-padding with the counter bytes.
  101|   188k|         const uint64_t bit_count = m_count * 8;
  102|   188k|         auto last_bytes = m_buffer.directly_modify_last(sizeof(bit_count));
  103|   188k|         if constexpr(MD::byte_endianness == MD_Endian::Big) {
  104|   188k|            store_be(bit_count, last_bytes.data());
  105|       |         } else {
  106|       |            store_le(bit_count, last_bytes.data());
  107|       |         }
  108|       |
  109|       |         // Compress the very last block.
  110|   188k|         MD::compress_n(m_digest, m_buffer.consume(), 1);
  111|   188k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE11copy_outputENSt3__14spanIhLm18446744073709551615EEE:
  113|   188k|      void copy_output(std::span<uint8_t> output) {
  114|   188k|         BOTAN_ASSERT_NOMSG(output.size() >= MD::output_bytes);
  ------------------
  |  |   64|   188k|   do {                                                                     \
  |  |   65|   188k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 188k]
  |  |  ------------------
  |  |   66|   188k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|   188k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  115|       |
  116|   188k|         if constexpr(MD::byte_endianness == MD_Endian::Big) {
  117|   188k|            copy_out_be(output.first(MD::output_bytes), m_digest);
  118|       |         } else {
  119|       |            copy_out_le(output.first(MD::output_bytes), m_digest);
  120|       |         }
  121|   188k|      }

_ZN5Botan3rhoILm14ELm18ELm41EmEET2_S1_:
   52|  41.4M|BOTAN_FORCE_INLINE constexpr T rho(T x) {
   53|  41.4M|   return rotr<R1>(x) ^ rotr<R2>(x) ^ rotr<R3>(x);
   54|  41.4M|}
_ZN5Botan4rotrILm14EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   36|  41.4M|{
   37|  41.4M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   38|  41.4M|}
_ZN5Botan4rotrILm18EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   36|  41.4M|{
   37|  41.4M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   38|  41.4M|}
_ZN5Botan4rotrILm41EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   36|  41.4M|{
   37|  41.4M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   38|  41.4M|}
_ZN5Botan3rhoILm28ELm34ELm39EmEET2_S1_:
   52|  41.4M|BOTAN_FORCE_INLINE constexpr T rho(T x) {
   53|  41.4M|   return rotr<R1>(x) ^ rotr<R2>(x) ^ rotr<R3>(x);
   54|  41.4M|}
_ZN5Botan4rotrILm28EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   36|  41.4M|{
   37|  41.4M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   38|  41.4M|}
_ZN5Botan4rotrILm34EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   36|  41.4M|{
   37|  41.4M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   38|  41.4M|}
_ZN5Botan4rotrILm39EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   36|  41.4M|{
   37|  41.4M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   38|  41.4M|}

_ZNK5Botan9SCAN_Name9algo_nameEv:
   44|  13.2k|      const std::string& algo_name() const { return m_alg_name; }
_ZNK5Botan9SCAN_Name9arg_countEv:
   49|  6.60k|      size_t arg_count() const { return m_args.size(); }

_ZNK5Botan7SHA_51213output_lengthEv:
   74|   198k|      size_t output_length() const override { return output_bytes; }
_ZNK5Botan7SHA_51215hash_block_sizeEv:
   76|  3.30k|      size_t hash_block_size() const override { return block_bytes; }
_ZN5Botan7SHA_5125clearEv:
   84|  39.6k|      void clear() override { m_md.clear(); }

_ZN5Botan9SHA2_64_FEmmmRmmmmS0_m:
   46|  41.4M|   uint64_t A, uint64_t B, uint64_t C, uint64_t& D, uint64_t E, uint64_t F, uint64_t G, uint64_t& H, uint64_t M) {
   47|  41.4M|   const uint64_t E_rho = rho<14, 18, 41>(E);
   48|  41.4M|   const uint64_t A_rho = rho<28, 34, 39>(A);
   49|  41.4M|   H += E_rho + choose(E, F, G) + M;
   50|  41.4M|   D += H;
   51|  41.4M|   H += A_rho + majority(A, B, C);
   52|  41.4M|}

_ZN5Botan9SIMD_2x64C2Ev:
   34|  3.22M|      SIMD_2x64() { m_simd = _mm_setzero_si128(); }
_ZN5Botan9SIMD_2x647load_beEPKv:
   40|  3.22M|      static SIMD_2x64 load_be(const void* in) { return SIMD_2x64::load_le(in).bswap(); }
_ZNK5Botan9SIMD_2x645bswapEv:
   42|  3.22M|      SIMD_2x64 BOTAN_FN_ISA_SIMD_2X64 bswap() const {
   43|  3.22M|         const auto idx = _mm_set_epi8(8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7);
   44|  3.22M|         return SIMD_2x64(_mm_shuffle_epi8(m_simd, idx));
   45|  3.22M|      }
_ZN5Botan9SIMD_2x64C2EDv2_x:
  147|   125M|      explicit SIMD_2x64(__m128i x) : m_simd(x) {}
_ZNK5Botan9SIMD_2x64plERKS0_:
   51|  54.8M|      SIMD_2x64 operator+(const SIMD_2x64& other) const {
   52|  54.8M|         SIMD_2x64 retval(*this);
   53|  54.8M|         retval += other;
   54|  54.8M|         return retval;
   55|  54.8M|      }
_ZN5Botan9SIMD_2x64pLERKS0_:
   63|  54.8M|      void operator+=(const SIMD_2x64& other) { m_simd = _mm_add_epi64(m_simd, other.m_simd); }
_ZN5Botan9SIMD_2x647load_leEPKv:
   36|  19.3M|      static SIMD_2x64 load_le(const void* in) {
   37|  19.3M|         return SIMD_2x64(_mm_loadu_si128(reinterpret_cast<const __m128i*>(in)));
   38|  19.3M|      }
_ZNK5Botan9SIMD_2x648store_leEPm:
   47|  16.1M|      void store_le(uint64_t out[2]) const { this->store_le(reinterpret_cast<uint8_t*>(out)); }
_ZNK5Botan9SIMD_2x648store_leEPh:
   49|  16.1M|      void store_le(uint8_t out[]) const { _mm_storeu_si128(reinterpret_cast<__m128i*>(out), m_simd); }
_ZN5Botan9SIMD_2x647alignr8ERKS0_S2_:
   99|  25.8M|      static SIMD_2x64 BOTAN_FN_ISA_SIMD_2X64 alignr8(const SIMD_2x64& a, const SIMD_2x64& b) {
  100|  25.8M|         return SIMD_2x64(_mm_alignr_epi8(a.m_simd, b.m_simd, 8));
  101|  25.8M|      }
_ZNK5Botan9SIMD_2x644rotrILm1EEES0_vQaagtT_Li0EltT_Li64E:
   70|  12.9M|      {
   71|       |         if constexpr(ROT == 8) {
   72|       |            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|  12.9M|         } else {
   84|  12.9M|            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|  12.9M|                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|  12.9M|         }
   87|  12.9M|      }
_ZNK5Botan9SIMD_2x64eoERKS0_:
   57|  51.6M|      SIMD_2x64 operator^(const SIMD_2x64& other) const {
   58|  51.6M|         SIMD_2x64 retval(*this);
   59|  51.6M|         retval ^= other;
   60|  51.6M|         return retval;
   61|  51.6M|      }
_ZN5Botan9SIMD_2x64eOERKS0_:
   65|  51.6M|      void operator^=(const SIMD_2x64& other) { m_simd = _mm_xor_si128(m_simd, other.m_simd); }
_ZNK5Botan9SIMD_2x644rotrILm8EEES0_vQaagtT_Li0EltT_Li64E:
   70|  12.9M|      {
   71|  12.9M|         if constexpr(ROT == 8) {
   72|  12.9M|            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|  12.9M|            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|       |         } else {
   84|       |            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|       |                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|       |         }
   87|  12.9M|      }
_ZNK5Botan9SIMD_2x643shrILi7EEES0_v:
   95|  12.9M|      SIMD_2x64 shr() const noexcept {
   96|  12.9M|         return SIMD_2x64(_mm_srli_epi64(m_simd, SHIFT));
   97|  12.9M|      }
_ZNK5Botan9SIMD_2x644rotrILm19EEES0_vQaagtT_Li0EltT_Li64E:
   70|  12.9M|      {
   71|       |         if constexpr(ROT == 8) {
   72|       |            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|  12.9M|         } else {
   84|  12.9M|            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|  12.9M|                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|  12.9M|         }
   87|  12.9M|      }
_ZNK5Botan9SIMD_2x644rotrILm61EEES0_vQaagtT_Li0EltT_Li64E:
   70|  12.9M|      {
   71|       |         if constexpr(ROT == 8) {
   72|       |            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|  12.9M|         } else {
   84|  12.9M|            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|  12.9M|                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|  12.9M|         }
   87|  12.9M|      }
_ZNK5Botan9SIMD_2x643shrILi6EEES0_v:
   95|  12.9M|      SIMD_2x64 shr() const noexcept {
   96|  12.9M|         return SIMD_2x64(_mm_srli_epi64(m_simd, SHIFT));
   97|  12.9M|      }

_ZN5Botan9SIMD_4x32C2Ejjjj:
   92|     96|      SIMD_4x32(uint32_t B0, uint32_t B1, uint32_t B2, uint32_t B3) noexcept {
   93|     96|#if defined(BOTAN_SIMD_USE_SSSE3)
   94|     96|         m_simd = _mm_set_epi32(B3, B2, B1, B0);
   95|       |#elif defined(BOTAN_SIMD_USE_ALTIVEC)
   96|       |         __vector unsigned int val = {B0, B1, B2, B3};
   97|       |         m_simd = val;
   98|       |#elif defined(BOTAN_SIMD_USE_NEON)
   99|       |         // Better way to do this?
  100|       |         const uint32_t B[4] = {B0, B1, B2, B3};
  101|       |         m_simd = vld1q_u32(B);
  102|       |#elif defined(BOTAN_SIMD_USE_LSX)
  103|       |         // Better way to do this?
  104|       |         const uint32_t B[4] = {B0, B1, B2, B3};
  105|       |         m_simd = __lsx_vld(B, 0);
  106|       |#endif
  107|     96|      }
_ZN5Botan9SIMD_4x328splat_u8Eh:
  127|      2|      static SIMD_4x32 splat_u8(uint8_t B) noexcept {
  128|      2|#if defined(BOTAN_SIMD_USE_SSSE3)
  129|      2|         return SIMD_4x32(_mm_set1_epi8(B));
  130|       |#elif defined(BOTAN_SIMD_USE_NEON)
  131|       |         return SIMD_4x32(vreinterpretq_u32_u8(vdupq_n_u8(B)));
  132|       |#elif defined(BOTAN_SIMD_USE_LSX)
  133|       |         return SIMD_4x32(__lsx_vreplgr2vr_b(B));
  134|       |#else
  135|       |         const uint32_t B4 = make_uint32(B, B, B, B);
  136|       |         return SIMD_4x32(B4, B4, B4, B4);
  137|       |#endif
  138|      2|      }
_ZN5Botan9SIMD_4x32C2EDv2_x:
  756|      2|      explicit SIMD_4x32(native_simd_type x) noexcept : m_simd(x) {}

_ZN5Botan9SIMD_4x64C2Ev:
   32|   460k|      BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64() { m_simd = _mm256_setzero_si256(); }
_ZN5Botan9SIMD_4x648load_be2EPKvS2_:
   40|   460k|      static BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64 load_be2(const void* inl, const void* inh) {
   41|   460k|         return SIMD_4x64::load_le2(inl, inh).bswap();
   42|   460k|      }
_ZN5Botan9SIMD_4x648load_le2EPKvS2_:
   35|   460k|      static BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64 load_le2(const void* inl, const void* inh) {
   36|   460k|         return SIMD_4x64(
   37|   460k|            _mm256_loadu2_m128i(reinterpret_cast<const __m128i*>(inl), reinterpret_cast<const __m128i*>(inh)));
   38|   460k|      }
_ZN5Botan9SIMD_4x64C2EDv4_x:
  160|  17.9M|      explicit BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64(__m256i x) : m_simd(x) {}
_ZNK5Botan9SIMD_4x645bswapEv:
   50|   460k|      SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 bswap() const {
   51|   460k|         const auto idx = _mm256_set_epi8(
   52|   460k|            8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7);
   53|       |
   54|   460k|         return SIMD_4x64(_mm256_shuffle_epi8(m_simd, idx));
   55|   460k|      }
_ZNK5Botan9SIMD_4x64plERKS0_:
   67|  7.82M|      SIMD_4x64 operator+(const SIMD_4x64& other) const {
   68|  7.82M|         SIMD_4x64 retval(*this);
   69|  7.82M|         retval += other;
   70|  7.82M|         return retval;
   71|  7.82M|      }
_ZN5Botan9SIMD_4x64pLERKS0_:
   79|  7.82M|      BOTAN_FN_ISA_SIMD_4X64 void operator+=(const SIMD_4x64& other) {
   80|  7.82M|         m_simd = _mm256_add_epi64(m_simd, other.m_simd);
   81|  7.82M|      }
_ZN5Botan9SIMD_4x647load_leEPKv:
   44|  2.30M|      static BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64 load_le(const void* in) {
   45|  2.30M|         return SIMD_4x64(_mm256_loadu_si256(reinterpret_cast<const __m256i*>(in)));
   46|  2.30M|      }
_ZN5Botan9SIMD_4x649store_le2EPvS1_:
   63|  2.30M|      BOTAN_FN_ISA_SIMD_4X64 void store_le2(void* outh, void* outl) {
   64|  2.30M|         _mm256_storeu2_m128i(reinterpret_cast<__m128i*>(outh), reinterpret_cast<__m128i*>(outl), m_simd);
   65|  2.30M|      }
_ZN5Botan9SIMD_4x647alignr8ERKS0_S2_:
  131|  3.68M|      static SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 alignr8(const SIMD_4x64& a, const SIMD_4x64& b) {
  132|  3.68M|         return SIMD_4x64(_mm256_alignr_epi8(a.m_simd, b.m_simd, 8));
  133|  3.68M|      }
_ZNK5Botan9SIMD_4x644rotrILm1EEES0_vQaagtT_Li0EltT_Li64E:
   90|  1.84M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|       |         if constexpr(ROT == 8) {
   95|       |            auto shuf_rot_8 =
   96|       |               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|  1.84M|         } else {
  115|  1.84M|            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|  1.84M|                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|  1.84M|         }
  118|  1.84M|#endif
  119|  1.84M|      }
_ZNK5Botan9SIMD_4x64eoERKS0_:
   73|  7.36M|      SIMD_4x64 operator^(const SIMD_4x64& other) const {
   74|  7.36M|         SIMD_4x64 retval(*this);
   75|  7.36M|         retval ^= other;
   76|  7.36M|         return retval;
   77|  7.36M|      }
_ZN5Botan9SIMD_4x64eOERKS0_:
   83|  7.36M|      BOTAN_FN_ISA_SIMD_4X64 void operator^=(const SIMD_4x64& other) {
   84|  7.36M|         m_simd = _mm256_xor_si256(m_simd, other.m_simd);
   85|  7.36M|      }
_ZNK5Botan9SIMD_4x644rotrILm8EEES0_vQaagtT_Li0EltT_Li64E:
   90|  1.84M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|  1.84M|         if constexpr(ROT == 8) {
   95|  1.84M|            auto shuf_rot_8 =
   96|  1.84M|               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|  1.84M|            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|       |         } else {
  115|       |            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|       |                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|       |         }
  118|  1.84M|#endif
  119|  1.84M|      }
_ZNK5Botan9SIMD_4x643shrILi7EEES0_v:
  127|  1.84M|      SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 shr() const noexcept {
  128|  1.84M|         return SIMD_4x64(_mm256_srli_epi64(m_simd, SHIFT));
  129|  1.84M|      }
_ZNK5Botan9SIMD_4x644rotrILm19EEES0_vQaagtT_Li0EltT_Li64E:
   90|  1.84M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|       |         if constexpr(ROT == 8) {
   95|       |            auto shuf_rot_8 =
   96|       |               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|  1.84M|         } else {
  115|  1.84M|            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|  1.84M|                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|  1.84M|         }
  118|  1.84M|#endif
  119|  1.84M|      }
_ZNK5Botan9SIMD_4x644rotrILm61EEES0_vQaagtT_Li0EltT_Li64E:
   90|  1.84M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|       |         if constexpr(ROT == 8) {
   95|       |            auto shuf_rot_8 =
   96|       |               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|  1.84M|         } else {
  115|  1.84M|            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|  1.84M|                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|  1.84M|         }
  118|  1.84M|#endif
  119|  1.84M|      }
_ZNK5Botan9SIMD_4x643shrILi6EEES0_v:
  127|  1.84M|      SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 shr() const noexcept {
  128|  1.84M|         return SIMD_4x64(_mm256_srli_epi64(m_simd, SHIFT));
  129|  1.84M|      }

_ZN5Botan12BufferSlicerC2ENSt3__14spanIKhLm18446744073709551615EEE:
   87|   488k|      BufferSlicer(std::span<const uint8_t> buffer) : m_remaining(buffer) {}
_ZN5Botan12BufferSlicer4takeEm:
   99|   509k|      std::span<const uint8_t> take(const size_t count) {
  100|   509k|         BOTAN_STATE_CHECK(remaining() >= count);
  ------------------
  |  |   46|   509k|   do {                                                         \
  |  |   47|   509k|      if(!(expr))                                               \
  |  |  ------------------
  |  |  |  Branch (47:10): [True: 0, False: 509k]
  |  |  ------------------
  |  |   48|   509k|         Botan::throw_invalid_state(#expr, __func__, __FILE__); \
  |  |   49|   509k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (49:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  101|   509k|         auto result = m_remaining.first(count);
  102|   509k|         m_remaining = m_remaining.subspan(count);
  103|   509k|         return result;
  104|   509k|      }
_ZNK5Botan12BufferSlicer9remainingEv:
  128|  1.42M|      size_t remaining() const { return m_remaining.size(); }
_ZNK5Botan12BufferSlicer5emptyEv:
  130|   988k|      bool empty() const { return m_remaining.empty(); }

_ZN5Botan13ignore_paramsIJRPKhRmEEEvDpOT_:
  118|  72.6k|constexpr void ignore_params(T&&... args) {
  119|  72.6k|   (ignore_param(args), ...);
  120|  72.6k|}
_ZN5Botan12ignore_paramIRPKhEEvOT_:
  115|  72.6k|constexpr void ignore_param(T&&) {}
_ZN5Botan12ignore_paramIRmEEvOT_:
  115|  72.9k|constexpr void ignore_param(T&&) {}
_ZN5Botan13ignore_paramsIJRPvRmEEEvDpOT_:
  118|    256|constexpr void ignore_params(T&&... args) {
  119|    256|   (ignore_param(args), ...);
  120|    256|}
_ZN5Botan12ignore_paramIRPvEEvOT_:
  115|    256|constexpr void ignore_param(T&&) {}

_ZN5Botan20Buffered_Computation6updateENSt3__14spanIKhLm18446744073709551615EEE:
   40|   561k|      void update(std::span<const uint8_t> in) { add_data(in); }
_ZN5Botan20Buffered_Computation5finalEPh:
   69|  23.1k|      void final(uint8_t out[]) { final_result({out, output_length()}); }
_ZN5Botan20Buffered_Computation6updateEPKhm:
   34|  42.9k|      void update(const uint8_t in[], size_t length) { add_data({in, length}); }
_ZN5Botan20Buffered_Computation6updateEh:
   61|  36.3k|      void update(uint8_t in) { add_data({&in, 1}); }
_ZN5Botan20Buffered_ComputationD2Ev:
  130|  23.1k|      virtual ~Buffered_Computation() = default;
_ZN5Botan20Buffered_Computation5finalITkNS_8concepts21resizable_byte_bufferENSt3__16vectorIhNS_16secure_allocatorIhEEEEEEvRT_:
   88|  82.5k|      void final(T& out) {
   89|  82.5k|         out.resize(output_length());
   90|  82.5k|         final_result(out);
   91|  82.5k|      }

_ZN5Botan6ranges24assert_exact_byte_lengthILm32ETkNS0_14spanable_rangeENSt3__14spanIhLm32EEEEEvRKT0_:
  107|  6.60k|inline constexpr void assert_exact_byte_length(const R& r) {
  108|  6.60k|   const std::span s{r};
  109|  6.60k|   if constexpr(statically_spanable_range<R>) {
  110|  6.60k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|  6.60k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeENSt3__14spanIhLm18446744073709551615EEETpTkNS0_14spanable_rangeEJNS3_IKhLm18446744073709551615EEEEEEvRKT_DpRKT0_QgtsZT0_Li0E:
  130|  39.6k|{
  131|  39.6k|   const std::span s0{r0};
  132|       |
  133|       |   if constexpr(statically_spanable_range<R0>) {
  134|       |      constexpr size_t expected_size = s0.size_bytes();
  135|       |      (assert_exact_byte_length<expected_size>(rs), ...);
  136|  39.6k|   } else {
  137|  39.6k|      const size_t expected_size = s0.size_bytes();
  138|  39.6k|      const bool correct_size =
  139|  39.6k|         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  140|       |
  141|  39.6k|      if(!correct_size) {
  ------------------
  |  Branch (141:10): [True: 0, False: 39.6k]
  ------------------
  142|      0|         throw Invalid_Argument("Memory regions did not have equal lengths");
  143|      0|      }
  144|  39.6k|   }
  145|  39.6k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm4ETkNS0_14spanable_rangeENSt3__14spanIKhLm4EEEEEvRKT0_:
  107|   402k|inline constexpr void assert_exact_byte_length(const R& r) {
  108|   402k|   const std::span s{r};
  109|   402k|   if constexpr(statically_spanable_range<R>) {
  110|   402k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|   402k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeENSt3__14spanIjLm1EEETpTkNS0_14spanable_rangeEJNS3_IKhLm4EEEEEEvRKT_DpRKT0_QgtsZT0_Li0E:
  130|   201k|{
  131|   201k|   const std::span s0{r0};
  132|       |
  133|   201k|   if constexpr(statically_spanable_range<R0>) {
  134|   201k|      constexpr size_t expected_size = s0.size_bytes();
  135|   201k|      (assert_exact_byte_length<expected_size>(rs), ...);
  136|       |   } else {
  137|       |      const size_t expected_size = s0.size_bytes();
  138|       |      const bool correct_size =
  139|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  140|       |
  141|       |      if(!correct_size) {
  142|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  143|       |      }
  144|       |   }
  145|   201k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeENSt3__14spanIjLm1EEEEEmRKT_:
   94|   201k|inline constexpr size_t size_bytes(const spanable_range auto& r) {
   95|   201k|   return std::span{r}.size_bytes();
   96|   201k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm8ETkNS0_14spanable_rangeENSt3__14spanIhLm8EEEEEvRKT0_:
  107|  3.23M|inline constexpr void assert_exact_byte_length(const R& r) {
  108|  3.23M|   const std::span s{r};
  109|  3.23M|   if constexpr(statically_spanable_range<R>) {
  110|  3.23M|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|  3.23M|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeENSt3__14spanIhLm8EEETpTkNS0_14spanable_rangeEJNS3_IKmLm1EEEEEEvRKT_DpRKT0_QgtsZT0_Li0E:
  130|  1.72M|{
  131|  1.72M|   const std::span s0{r0};
  132|       |
  133|  1.72M|   if constexpr(statically_spanable_range<R0>) {
  134|  1.72M|      constexpr size_t expected_size = s0.size_bytes();
  135|  1.72M|      (assert_exact_byte_length<expected_size>(rs), ...);
  136|       |   } else {
  137|       |      const size_t expected_size = s0.size_bytes();
  138|       |      const bool correct_size =
  139|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  140|       |
  141|       |      if(!correct_size) {
  142|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  143|       |      }
  144|       |   }
  145|  1.72M|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm8ETkNS0_14spanable_rangeENSt3__14spanIKmLm1EEEEEvRKT0_:
  107|  1.72M|inline constexpr void assert_exact_byte_length(const R& r) {
  108|  1.72M|   const std::span s{r};
  109|  1.72M|   if constexpr(statically_spanable_range<R>) {
  110|  1.72M|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|  1.72M|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeENSt3__14spanIhLm8EEEEEmRKT_:
   94|  1.72M|inline constexpr size_t size_bytes(const spanable_range auto& r) {
   95|  1.72M|   return std::span{r}.size_bytes();
   96|  1.72M|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm4ETkNS0_14spanable_rangeENSt3__14spanIhLm4EEEEEvRKT0_:
  107|  13.2k|inline constexpr void assert_exact_byte_length(const R& r) {
  108|  13.2k|   const std::span s{r};
  109|  13.2k|   if constexpr(statically_spanable_range<R>) {
  110|  13.2k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|  13.2k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeENSt3__14spanIhLm4EEETpTkNS0_14spanable_rangeEJNS3_IKjLm1EEEEEEvRKT_DpRKT0_QgtsZT0_Li0E:
  130|  6.60k|{
  131|  6.60k|   const std::span s0{r0};
  132|       |
  133|  6.60k|   if constexpr(statically_spanable_range<R0>) {
  134|  6.60k|      constexpr size_t expected_size = s0.size_bytes();
  135|  6.60k|      (assert_exact_byte_length<expected_size>(rs), ...);
  136|       |   } else {
  137|       |      const size_t expected_size = s0.size_bytes();
  138|       |      const bool correct_size =
  139|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  140|       |
  141|       |      if(!correct_size) {
  142|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  143|       |      }
  144|       |   }
  145|  6.60k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm4ETkNS0_14spanable_rangeENSt3__14spanIKjLm1EEEEEvRKT0_:
  107|  6.60k|inline constexpr void assert_exact_byte_length(const R& r) {
  108|  6.60k|   const std::span s{r};
  109|  6.60k|   if constexpr(statically_spanable_range<R>) {
  110|  6.60k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|  6.60k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeENSt3__14spanIhLm4EEEEEmRKT_:
   94|  6.60k|inline constexpr size_t size_bytes(const spanable_range auto& r) {
   95|  6.60k|   return std::span{r}.size_bytes();
   96|  6.60k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeENSt3__14spanIhLm18446744073709551615EEEEEmRKT_:
   94|  79.2k|inline constexpr size_t size_bytes(const spanable_range auto& r) {
   95|  79.2k|   return std::span{r}.size_bytes();
   96|  79.2k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm8ETkNS0_14spanable_rangeENSt3__14spanIKhLm8EEEEEvRKT0_:
  107|  92.4k|inline constexpr void assert_exact_byte_length(const R& r) {
  108|  92.4k|   const std::span s{r};
  109|  92.4k|   if constexpr(statically_spanable_range<R>) {
  110|  92.4k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  111|       |   } else {
  112|       |      if(s.size_bytes() != expected) {
  113|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  114|       |      }
  115|       |   }
  116|  92.4k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeENSt3__14spanImLm1EEETpTkNS0_14spanable_rangeEJNS3_IKhLm8EEEEEEvRKT_DpRKT0_QgtsZT0_Li0E:
  130|  46.2k|{
  131|  46.2k|   const std::span s0{r0};
  132|       |
  133|  46.2k|   if constexpr(statically_spanable_range<R0>) {
  134|  46.2k|      constexpr size_t expected_size = s0.size_bytes();
  135|  46.2k|      (assert_exact_byte_length<expected_size>(rs), ...);
  136|       |   } else {
  137|       |      const size_t expected_size = s0.size_bytes();
  138|       |      const bool correct_size =
  139|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  140|       |
  141|       |      if(!correct_size) {
  142|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  143|       |      }
  144|       |   }
  145|  46.2k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeENSt3__14spanImLm1EEEEEmRKT_:
   94|  46.2k|inline constexpr size_t size_bytes(const spanable_range auto& r) {
   95|  46.2k|   return std::span{r}.size_bytes();
   96|  46.2k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeENSt3__14spanIhLm18446744073709551615EEETpTkNS0_14spanable_rangeEJNS3_IKmLm18446744073709551615EEEEEEvRKT_DpRKT0_QgtsZT0_Li0E:
  130|   188k|{
  131|   188k|   const std::span s0{r0};
  132|       |
  133|       |   if constexpr(statically_spanable_range<R0>) {
  134|       |      constexpr size_t expected_size = s0.size_bytes();
  135|       |      (assert_exact_byte_length<expected_size>(rs), ...);
  136|   188k|   } else {
  137|   188k|      const size_t expected_size = s0.size_bytes();
  138|   188k|      const bool correct_size =
  139|   188k|         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  140|       |
  141|   188k|      if(!correct_size) {
  ------------------
  |  Branch (141:10): [True: 0, False: 188k]
  ------------------
  142|      0|         throw Invalid_Argument("Memory regions did not have equal lengths");
  143|      0|      }
  144|   188k|   }
  145|   188k|}

_ZNK5Botan17Ed25519_PublicKey14get_public_keyEv:
   37|  6.60k|      BOTAN_DEPRECATED("Use raw_public_key_bits") const std::vector<uint8_t>& get_public_key() const {
   38|  6.60k|         return m_public;
   39|  6.60k|      }
_ZN5Botan17Ed25519_PublicKeyC2Ev:
   59|  3.30k|      Ed25519_PublicKey() = default;
_ZN5Botan17Ed25519_PublicKeyC1ENSt3__14spanIKhLm18446744073709551615EEE:
   48|  3.30k|      Ed25519_PublicKey(std::span<const uint8_t> pub) : Ed25519_PublicKey(pub.data(), pub.size()) {}

_ZN5Botan12HashFunctionC2Ev:
   53|  19.8k|      HashFunction() = default;

_ZNK5Botan9HMAC_DRBG31max_number_of_bytes_per_requestEv:
  130|  9.90k|      size_t max_number_of_bytes_per_request() const override { return m_max_number_of_bytes_per_request; }

_ZN5Botan25MessageAuthenticationCodeD2Ev:
   50|  3.30k|      ~MessageAuthenticationCode() override = default;

_ZN5Botan9clear_memIhEEvPT_m:
  123|   515k|inline constexpr void clear_mem(T* ptr, size_t n) {
  124|   515k|   clear_bytes(ptr, sizeof(T) * n);
  125|   515k|}
_ZN5Botan11clear_bytesEPvm:
  106|  36.9M|inline constexpr void clear_bytes(void* ptr, size_t bytes) {
  107|  36.9M|   if(bytes > 0) {
  ------------------
  |  Branch (107:7): [True: 36.9M, False: 0]
  ------------------
  108|  36.9M|      std::memset(ptr, 0, bytes);
  109|  36.9M|   }
  110|  36.9M|}
_ZN5Botan22cast_char_ptr_to_uint8EPKc:
  276|  6.60k|inline const uint8_t* cast_char_ptr_to_uint8(const char* s) {
  277|  6.60k|   return reinterpret_cast<const uint8_t*>(s);
  278|  6.60k|}
_ZN5Botan8copy_memIhQsr3stdE12is_trivial_vIu7__decayIT_EEEEvPS1_PKS1_m:
  149|  26.4k|inline constexpr void copy_mem(T* out, const T* in, size_t n) {
  150|  26.4k|   BOTAN_ASSERT_IMPLICATION(n > 0, in != nullptr && out != nullptr, "If n > 0 then args are not null");
  ------------------
  |  |   82|  26.4k|   do {                                                                                          \
  |  |   83|  52.8k|      if((expr1) && !(expr2))                                                                    \
  |  |  ------------------
  |  |  |  Branch (83:10): [True: 26.4k, False: 0]
  |  |  |  Branch (83:23): [True: 26.4k, False: 0]
  |  |  |  Branch (83:23): [True: 26.4k, False: 0]
  |  |  ------------------
  |  |   84|  26.4k|         Botan::assertion_failure(#expr1 " implies " #expr2, msg, __func__, __FILE__, __LINE__); \
  |  |   85|  26.4k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (85:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  151|       |
  152|  26.4k|   if(in != nullptr && out != nullptr && n > 0) {
  ------------------
  |  Branch (152:7): [True: 26.4k, False: 0]
  |  Branch (152:24): [True: 26.4k, False: 0]
  |  Branch (152:42): [True: 26.4k, False: 0]
  ------------------
  153|  26.4k|      std::memmove(out, in, sizeof(T) * n);
  154|  26.4k|   }
  155|  26.4k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeENSt3__14spanIjLm1EEETkNS1_16contiguous_rangeENS3_IKhLm4EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS7_IXsr21__is_primary_templateINS8_Iu14__remove_cvrefIDTclL_ZNSA_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSG_ISO_EESP_E4type10value_typeEEEEvOSL_RKSB_:
  181|   201k|inline constexpr void typecast_copy(ToR&& out /* NOLINT(*-std-forward) */, const FromR& in) {
  182|   201k|   ranges::assert_equal_byte_lengths(out, in);
  183|   201k|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|   201k|}
_ZN5Botan13typecast_copyIjTkNS_6ranges16contiguous_rangeENSt3__14spanIKhLm4EEEQaaaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISD_EESE_E4type10value_typeEEsr3stdE23is_trivially_copyable_vIT_Entsr3std6rangesE5rangeISK_EEEvRSK_RKSA_:
  193|   201k|inline constexpr void typecast_copy(ToT& out, const FromR& in) noexcept {
  194|   201k|   typecast_copy(std::span<ToT, 1>(&out, 1), in);
  195|   201k|}
_ZN5Botan13typecast_copyIjTkNS_6ranges16contiguous_rangeENSt3__14spanIKhLm4EEEQaaaasr3stdE26is_default_constructible_vIT_Esr3stdE23is_trivially_copyable_vIS6_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEEES6_RKSB_:
  215|   201k|inline constexpr ToT typecast_copy(const FromR& src) noexcept {
  216|   201k|   ToT dst;
  217|   201k|   typecast_copy(dst, src);
  218|   201k|   return dst;
  219|   201k|}
_ZN5Botan9clear_memIiEEvPT_m:
  123|  36.4M|inline constexpr void clear_mem(T* ptr, size_t n) {
  124|  36.4M|   clear_bytes(ptr, sizeof(T) * n);
  125|  36.4M|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm8EEEmQaaaasr3stdE23is_trivially_copyable_vIT0_Entsr3std6rangesE5rangeIS6_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEEEvOSB_RKS6_:
  204|  1.72M|inline constexpr void typecast_copy(ToR&& out /* NOLINT(*-std-forward) */, const FromT& in) {
  205|  1.72M|   typecast_copy(out, std::span<const FromT, 1>(&in, 1));
  206|  1.72M|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm8EEETkNS1_16contiguous_rangeENS3_IKmLm1EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEEEvOSM_RKSC_:
  181|  1.72M|inline constexpr void typecast_copy(ToR&& out /* NOLINT(*-std-forward) */, const FromR& in) {
  182|  1.72M|   ranges::assert_equal_byte_lengths(out, in);
  183|  1.72M|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|  1.72M|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm4EEEjQaaaasr3stdE23is_trivially_copyable_vIT0_Entsr3std6rangesE5rangeIS6_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEEEvOSB_RKS6_:
  204|  6.60k|inline constexpr void typecast_copy(ToR&& out /* NOLINT(*-std-forward) */, const FromT& in) {
  205|  6.60k|   typecast_copy(out, std::span<const FromT, 1>(&in, 1));
  206|  6.60k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm4EEETkNS1_16contiguous_rangeENS3_IKjLm1EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEEEvOSM_RKSC_:
  181|  6.60k|inline constexpr void typecast_copy(ToR&& out /* NOLINT(*-std-forward) */, const FromR& in) {
  182|  6.60k|   ranges::assert_equal_byte_lengths(out, in);
  183|  6.60k|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|  6.60k|}
_ZN5Botan13typecast_copyImTkNS_6ranges16contiguous_rangeENSt3__14spanIKhLm8EEEQaaaasr3stdE26is_default_constructible_vIT_Esr3stdE23is_trivially_copyable_vIS6_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEEES6_RKSB_:
  215|  46.2k|inline constexpr ToT typecast_copy(const FromR& src) noexcept {
  216|  46.2k|   ToT dst;
  217|  46.2k|   typecast_copy(dst, src);
  218|  46.2k|   return dst;
  219|  46.2k|}
_ZN5Botan13typecast_copyImTkNS_6ranges16contiguous_rangeENSt3__14spanIKhLm8EEEQaaaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISD_EESE_E4type10value_typeEEsr3stdE23is_trivially_copyable_vIT_Entsr3std6rangesE5rangeISK_EEEvRSK_RKSA_:
  193|  46.2k|inline constexpr void typecast_copy(ToT& out, const FromR& in) noexcept {
  194|  46.2k|   typecast_copy(std::span<ToT, 1>(&out, 1), in);
  195|  46.2k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeENSt3__14spanImLm1EEETkNS1_16contiguous_rangeENS3_IKhLm8EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS7_IXsr21__is_primary_templateINS8_Iu14__remove_cvrefIDTclL_ZNSA_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSG_ISO_EESP_E4type10value_typeEEEEvOSL_RKSB_:
  181|  46.2k|inline constexpr void typecast_copy(ToR&& out /* NOLINT(*-std-forward) */, const FromR& in) {
  182|  46.2k|   ranges::assert_equal_byte_lengths(out, in);
  183|  46.2k|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|  46.2k|}
_ZN5Botan8copy_memImQsr3stdE12is_trivial_vIu7__decayIT_EEEEvPS1_PKS1_m:
  149|  5.08M|inline constexpr void copy_mem(T* out, const T* in, size_t n) {
  150|  5.08M|   BOTAN_ASSERT_IMPLICATION(n > 0, in != nullptr && out != nullptr, "If n > 0 then args are not null");
  ------------------
  |  |   82|  5.08M|   do {                                                                                          \
  |  |   83|  10.1M|      if((expr1) && !(expr2))                                                                    \
  |  |  ------------------
  |  |  |  Branch (83:10): [True: 5.08M, False: 0]
  |  |  |  Branch (83:23): [True: 5.08M, False: 0]
  |  |  |  Branch (83:23): [True: 5.08M, False: 0]
  |  |  ------------------
  |  |   84|  5.08M|         Botan::assertion_failure(#expr1 " implies " #expr2, msg, __func__, __FILE__, __LINE__); \
  |  |   85|  5.08M|   } while(0)
  |  |  ------------------
  |  |  |  Branch (85:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  151|       |
  152|  5.08M|   if(in != nullptr && out != nullptr && n > 0) {
  ------------------
  |  Branch (152:7): [True: 5.08M, False: 0]
  |  Branch (152:24): [True: 5.08M, False: 0]
  |  Branch (152:42): [True: 5.08M, False: 0]
  ------------------
  153|  5.08M|      std::memmove(out, in, sizeof(T) * n);
  154|  5.08M|   }
  155|  5.08M|}
_ZN5Botan8copy_memITkNS_6ranges23contiguous_output_rangeENSt3__14spanIhLm18446744073709551615EEETkNS1_16contiguous_rangeENS3_IKhLm18446744073709551615EEEQaasr3stdE9is_same_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeENS7_IXsr21__is_primary_templateINS8_Iu14__remove_cvrefIDTclL_ZNSA_5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENSG_ISO_EESP_E4type10value_typeEEsr3stdE23is_trivially_copyable_vIST_EEEvOSB_RKSL_:
  165|  39.6k|inline constexpr void copy_mem(OutR&& out /* NOLINT(*-std-forward) */, const InR& in) {
  166|  39.6k|   ranges::assert_equal_byte_lengths(out, in);
  167|  39.6k|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (167:7): [Folded - Ignored]
  ------------------
  168|      0|      std::copy(std::ranges::begin(in), std::ranges::end(in), std::ranges::begin(out));
  169|  39.6k|   } else if(ranges::size_bytes(out) > 0) {
  ------------------
  |  Branch (169:14): [True: 39.6k, False: 0]
  ------------------
  170|  39.6k|      std::memmove(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  171|  39.6k|   }
  172|  39.6k|}
_ZN5Botan9clear_memIjEEvPT_m:
  123|      6|inline constexpr void clear_mem(T* ptr, size_t n) {
  124|      6|   clear_bytes(ptr, sizeof(T) * n);
  125|      6|}

_ZNK5Botan14Asymmetric_Key40_signature_element_size_for_DER_encodingEv:
  137|  6.60k|      virtual std::optional<size_t> _signature_element_size_for_DER_encoding() const { return {}; }

_ZN5Botan6PK_Ops12VerificationD2Ev:
   99|  3.30k|      virtual ~Verification() = default;
_ZN5Botan6PK_Ops9SignatureD2Ev:
  136|  3.30k|      virtual ~Signature() = default;

_ZN5Botan21RandomNumberGenerator9randomizeENSt3__14spanIhLm18446744073709551615EEE:
   68|  16.5k|      void randomize(std::span<uint8_t> output) { this->fill_bytes_with_input(output, {}); }
_ZN5Botan21RandomNumberGenerator11add_entropyENSt3__14spanIKhLm18446744073709551615EEE:
   91|  3.30k|      void add_entropy(std::span<const uint8_t> input) { this->fill_bytes_with_input({}, input); }
_ZN5Botan21RandomNumberGenerator10random_vecENSt3__14spanIhLm18446744073709551615EEE:
  196|  9.90k|      void random_vec(std::span<uint8_t> v) { this->randomize(v); }
_ZN5Botan21RandomNumberGenerator9next_byteEv:
  244|  3.30k|      uint8_t next_byte() {
  245|  3.30k|         uint8_t b;
  246|  3.30k|         this->fill_bytes_with_input(std::span(&b, 1), {});
  247|  3.30k|         return b;
  248|  3.30k|      }
_ZN5Botan21RandomNumberGenerator10random_vecITkNS_8concepts21resizable_byte_bufferENSt3__16vectorIhNS_16secure_allocatorIhEEEEQsr3stdE21default_initializableIT_EEES8_m:
  222|  9.90k|      T random_vec(size_t bytes) {
  223|  9.90k|         T result;
  224|  9.90k|         random_vec(result, bytes);
  225|  9.90k|         return result;
  226|  9.90k|      }
_ZN5Botan21RandomNumberGenerator10random_vecITkNS_8concepts21resizable_byte_bufferENSt3__16vectorIhNS_16secure_allocatorIhEEEEEEvRT_m:
  207|  9.90k|      void random_vec(T& v, size_t bytes) {
  208|  9.90k|         v.resize(bytes);
  209|  9.90k|         random_vec(v);
  210|  9.90k|      }
_ZN5Botan21RandomNumberGeneratorD2Ev:
   48|  6.60k|      virtual ~RandomNumberGenerator() = default;
_ZN5Botan21RandomNumberGeneratorC2Ev:
   50|  6.60k|      RandomNumberGenerator() = default;

_ZN5Botan16secure_allocatorImE10deallocateEPmm:
   54|  19.8k|      void deallocate(T* p, std::size_t n) { deallocate_memory(p, n, sizeof(T)); }
_ZN5Botan16secure_allocatorImE8allocateEm:
   52|  19.8k|      T* allocate(std::size_t n) { return static_cast<T*>(allocate_memory(n, sizeof(T))); }

_ZN5Botan12Stateful_RNGC2ERNS_21RandomNumberGeneratorEm:
   45|  3.30k|            m_underlying_rng(&rng), m_reseed_interval(reseed_interval) {}
_ZNK5Botan12Stateful_RNG13accepts_inputEv:
   71|  9.90k|      bool accepts_input() const final { return true; }

_ZN5Botan16wrap_strong_typeIjRjQoosr3stdE18constructible_fromIT_T0_Eaasr8conceptsE11strong_typeIS2_Esr3stdE18constructible_fromINS2_12wrapped_typeES3_EEEDcOS3_:
  249|   201k|[[nodiscard]] constexpr decltype(auto) wrap_strong_type(ParamT&& t) {
  250|   201k|   if constexpr(std::same_as<std::remove_cvref_t<ParamT>, T>) {
  251|       |      // Noop, if the parameter type already is the desired return type.
  252|   201k|      return std::forward<ParamT>(t);
  253|       |   } else if constexpr(std::constructible_from<T, ParamT>) {
  254|       |      // Implicit conversion from the parameter type to the return type.
  255|       |      return T{std::forward<ParamT>(t)};
  256|       |   } else {
  257|       |      // Explicitly calling the wrapped type's constructor to support
  258|       |      // implicit conversions on types that mark their constructors as explicit.
  259|       |      static_assert(concepts::strong_type<T> && std::constructible_from<typename T::wrapped_type, ParamT>);
  260|       |      return T{typename T::wrapped_type{std::forward<ParamT>(t)}};
  261|       |   }
  262|   201k|}
_ZN5Botan18unwrap_strong_typeIRmEEDcOT_:
  224|  1.72M|[[nodiscard]] constexpr decltype(auto) unwrap_strong_type(T&& t) {
  225|  1.72M|   if constexpr(!concepts::strong_type<std::remove_cvref_t<T>>) {
  226|       |      // If the parameter type isn't a strong type, return it as is.
  227|  1.72M|      return std::forward<T>(t);
  228|       |   } else {
  229|       |      // Unwrap the strong type and return the underlying value.
  230|       |      return std::forward<T>(t).get();
  231|       |   }
  232|  1.72M|}
_ZN5Botan18unwrap_strong_typeIRjEEDcOT_:
  224|  6.60k|[[nodiscard]] constexpr decltype(auto) unwrap_strong_type(T&& t) {
  225|  6.60k|   if constexpr(!concepts::strong_type<std::remove_cvref_t<T>>) {
  226|       |      // If the parameter type isn't a strong type, return it as is.
  227|  6.60k|      return std::forward<T>(t);
  228|       |   } else {
  229|       |      // Unwrap the strong type and return the underlying value.
  230|       |      return std::forward<T>(t).get();
  231|       |   }
  232|  6.60k|}
_ZN5Botan16wrap_strong_typeImRmQoosr3stdE18constructible_fromIT_T0_Eaasr8conceptsE11strong_typeIS2_Esr3stdE18constructible_fromINS2_12wrapped_typeES3_EEEDcOS3_:
  249|  46.2k|[[nodiscard]] constexpr decltype(auto) wrap_strong_type(ParamT&& t) {
  250|  46.2k|   if constexpr(std::same_as<std::remove_cvref_t<ParamT>, T>) {
  251|       |      // Noop, if the parameter type already is the desired return type.
  252|  46.2k|      return std::forward<ParamT>(t);
  253|       |   } else if constexpr(std::constructible_from<T, ParamT>) {
  254|       |      // Implicit conversion from the parameter type to the return type.
  255|       |      return T{std::forward<ParamT>(t)};
  256|       |   } else {
  257|       |      // Explicitly calling the wrapped type's constructor to support
  258|       |      // implicit conversions on types that mark their constructors as explicit.
  259|       |      static_assert(concepts::strong_type<T> && std::constructible_from<typename T::wrapped_type, ParamT>);
  260|       |      return T{typename T::wrapped_type{std::forward<ParamT>(t)}};
  261|       |   }
  262|  46.2k|}

_ZN5Botan24Key_Length_SpecificationC2Emmm:
   38|  39.6k|            m_min_keylen(min_k), m_max_keylen(max_k ? max_k : min_k), m_keylen_mod(k_mod) {}
  ------------------
  |  Branch (38:47): [True: 39.6k, False: 0]
  ------------------
_ZNK5Botan24Key_Length_Specification15valid_keylengthEm:
   44|  39.6k|      bool valid_keylength(size_t length) const {
   45|  39.6k|         return ((length >= m_min_keylen) && (length <= m_max_keylen) && (length % m_keylen_mod == 0));
  ------------------
  |  Branch (45:18): [True: 39.6k, False: 0]
  |  Branch (45:46): [True: 39.6k, False: 0]
  |  Branch (45:74): [True: 39.6k, False: 0]
  ------------------
   46|  39.6k|      }
_ZNK5Botan18SymmetricAlgorithm15valid_keylengthEm:
  114|  39.6k|      bool valid_keylength(size_t length) const { return key_spec().valid_keylength(length); }
_ZNK5Botan18SymmetricAlgorithm23assert_key_material_setEv:
  146|   234k|      void assert_key_material_set() const { assert_key_material_set(has_keying_material()); }
_ZNK5Botan18SymmetricAlgorithm23assert_key_material_setEb:
  148|   234k|      void assert_key_material_set(bool predicate) const {
  149|   234k|         if(!predicate) {
  ------------------
  |  Branch (149:13): [True: 0, False: 234k]
  ------------------
  150|      0|            throw_key_not_set_error();
  151|      0|         }
  152|   234k|      }
_ZN5Botan18SymmetricAlgorithmD2Ev:
   82|  3.30k|      virtual ~SymmetricAlgorithm() = default;
_ZN5Botan18SymmetricAlgorithmC2Ev:
   81|  3.30k|      SymmetricAlgorithm() = default;

_ZNK5Botan17X25519_PrivateKey12public_valueEv:
   82|  3.30k|      std::vector<uint8_t> public_value() const override { return raw_public_key_bits(); }
_ZN5Botan16X25519_PublicKeyC2Ev:
   52|  3.30k|      X25519_PublicKey() = default;

_ZN5Botan20Buffered_Computation5finalENSt3__14spanIhLm18446744073709551615EEE:
   53|   165k|void Buffered_Computation::final(std::span<uint8_t> out) {
   54|   165k|   BOTAN_ARG_CHECK(out.size() >= output_length(), "provided output buffer has insufficient capacity");
  ------------------
  |  |   34|   165k|   do {                                                          \
  |  |   35|   165k|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (35:10): [True: 0, False: 165k]
  |  |  ------------------
  |  |   36|   165k|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   37|   165k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (37:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   55|   165k|   final_result(out);
   56|   165k|}

_ZN5Botan18SymmetricAlgorithm7set_keyENSt3__14spanIKhLm18446744073709551615EEE:
   22|  39.6k|void SymmetricAlgorithm::set_key(std::span<const uint8_t> key) {
   23|  39.6k|   if(!valid_keylength(key.size())) {
  ------------------
  |  Branch (23:7): [True: 0, False: 39.6k]
  ------------------
   24|      0|      throw Invalid_Key_Length(name(), key.size());
   25|      0|   }
   26|  39.6k|   key_schedule(key);
   27|  39.6k|}

_ZN5Botan12HashFunction6createENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
  107|  19.8k|std::unique_ptr<HashFunction> HashFunction::create(std::string_view algo_spec, std::string_view provider) {
  108|       |#if defined(BOTAN_HAS_COMMONCRYPTO)
  109|       |   if(provider.empty() || provider == "commoncrypto") {
  110|       |      if(auto hash = make_commoncrypto_hash(algo_spec))
  111|       |         return hash;
  112|       |
  113|       |      if(!provider.empty())
  114|       |         return nullptr;
  115|       |   }
  116|       |#endif
  117|       |
  118|  19.8k|   if(provider.empty() == false && provider != "base") {
  ------------------
  |  Branch (118:7): [True: 0, False: 19.8k]
  |  Branch (118:36): [True: 0, False: 0]
  ------------------
  119|      0|      return nullptr;  // unknown provider
  120|      0|   }
  121|       |
  122|  19.8k|#if defined(BOTAN_HAS_SHA1)
  123|  19.8k|   if(algo_spec == "SHA-1") {
  ------------------
  |  Branch (123:7): [True: 0, False: 19.8k]
  ------------------
  124|      0|      return std::make_unique<SHA_1>();
  125|      0|   }
  126|  19.8k|#endif
  127|       |
  128|  19.8k|#if defined(BOTAN_HAS_SHA2_32)
  129|  19.8k|   if(algo_spec == "SHA-224") {
  ------------------
  |  Branch (129:7): [True: 0, False: 19.8k]
  ------------------
  130|      0|      return std::make_unique<SHA_224>();
  131|      0|   }
  132|       |
  133|  19.8k|   if(algo_spec == "SHA-256") {
  ------------------
  |  Branch (133:7): [True: 0, False: 19.8k]
  ------------------
  134|      0|      return std::make_unique<SHA_256>();
  135|      0|   }
  136|  19.8k|#endif
  137|       |
  138|  19.8k|#if defined(BOTAN_HAS_SHA2_64)
  139|  19.8k|   if(algo_spec == "SHA-384") {
  ------------------
  |  Branch (139:7): [True: 0, False: 19.8k]
  ------------------
  140|      0|      return std::make_unique<SHA_384>();
  141|      0|   }
  142|       |
  143|  19.8k|   if(algo_spec == "SHA-512") {
  ------------------
  |  Branch (143:7): [True: 19.8k, False: 0]
  ------------------
  144|  19.8k|      return std::make_unique<SHA_512>();
  145|  19.8k|   }
  146|       |
  147|      0|   if(algo_spec == "SHA-512-256") {
  ------------------
  |  Branch (147:7): [True: 0, False: 0]
  ------------------
  148|      0|      return std::make_unique<SHA_512_256>();
  149|      0|   }
  150|      0|#endif
  151|       |
  152|      0|#if defined(BOTAN_HAS_RIPEMD_160)
  153|      0|   if(algo_spec == "RIPEMD-160") {
  ------------------
  |  Branch (153:7): [True: 0, False: 0]
  ------------------
  154|      0|      return std::make_unique<RIPEMD_160>();
  155|      0|   }
  156|      0|#endif
  157|       |
  158|      0|#if defined(BOTAN_HAS_WHIRLPOOL)
  159|      0|   if(algo_spec == "Whirlpool") {
  ------------------
  |  Branch (159:7): [True: 0, False: 0]
  ------------------
  160|      0|      return std::make_unique<Whirlpool>();
  161|      0|   }
  162|      0|#endif
  163|       |
  164|      0|#if defined(BOTAN_HAS_MD5)
  165|      0|   if(algo_spec == "MD5") {
  ------------------
  |  Branch (165:7): [True: 0, False: 0]
  ------------------
  166|      0|      return std::make_unique<MD5>();
  167|      0|   }
  168|      0|#endif
  169|       |
  170|      0|#if defined(BOTAN_HAS_MD4)
  171|      0|   if(algo_spec == "MD4") {
  ------------------
  |  Branch (171:7): [True: 0, False: 0]
  ------------------
  172|      0|      return std::make_unique<MD4>();
  173|      0|   }
  174|      0|#endif
  175|       |
  176|      0|#if defined(BOTAN_HAS_GOST_34_11)
  177|      0|   if(algo_spec == "GOST-R-34.11-94" || algo_spec == "GOST-34.11") {
  ------------------
  |  Branch (177:7): [True: 0, False: 0]
  |  Branch (177:41): [True: 0, False: 0]
  ------------------
  178|      0|      return std::make_unique<GOST_34_11>();
  179|      0|   }
  180|      0|#endif
  181|       |
  182|      0|#if defined(BOTAN_HAS_ADLER32)
  183|      0|   if(algo_spec == "Adler32") {
  ------------------
  |  Branch (183:7): [True: 0, False: 0]
  ------------------
  184|      0|      return std::make_unique<Adler32>();
  185|      0|   }
  186|      0|#endif
  187|       |
  188|      0|#if defined(BOTAN_HAS_CRC24)
  189|      0|   if(algo_spec == "CRC24") {
  ------------------
  |  Branch (189:7): [True: 0, False: 0]
  ------------------
  190|      0|      return std::make_unique<CRC24>();
  191|      0|   }
  192|      0|#endif
  193|       |
  194|      0|#if defined(BOTAN_HAS_CRC32)
  195|      0|   if(algo_spec == "CRC32") {
  ------------------
  |  Branch (195:7): [True: 0, False: 0]
  ------------------
  196|      0|      return std::make_unique<CRC32>();
  197|      0|   }
  198|      0|#endif
  199|       |
  200|      0|#if defined(BOTAN_HAS_STREEBOG)
  201|      0|   if(algo_spec == "Streebog-256") {
  ------------------
  |  Branch (201:7): [True: 0, False: 0]
  ------------------
  202|      0|      return std::make_unique<Streebog>(256);
  203|      0|   }
  204|      0|   if(algo_spec == "Streebog-512") {
  ------------------
  |  Branch (204:7): [True: 0, False: 0]
  ------------------
  205|      0|      return std::make_unique<Streebog>(512);
  206|      0|   }
  207|      0|#endif
  208|       |
  209|      0|#if defined(BOTAN_HAS_SM3)
  210|      0|   if(algo_spec == "SM3") {
  ------------------
  |  Branch (210:7): [True: 0, False: 0]
  ------------------
  211|      0|      return std::make_unique<SM3>();
  212|      0|   }
  213|      0|#endif
  214|       |
  215|      0|   const SCAN_Name req(algo_spec);
  216|       |
  217|      0|#if defined(BOTAN_HAS_SKEIN_512)
  218|      0|   if(req.algo_name() == "Skein-512") {
  ------------------
  |  Branch (218:7): [True: 0, False: 0]
  ------------------
  219|      0|      return std::make_unique<Skein_512>(req.arg_as_integer(0, 512), req.arg(1, ""));
  220|      0|   }
  221|      0|#endif
  222|       |
  223|      0|#if defined(BOTAN_HAS_BLAKE2B)
  224|      0|   if(req.algo_name() == "Blake2b" || req.algo_name() == "BLAKE2b") {
  ------------------
  |  Branch (224:7): [True: 0, False: 0]
  |  Branch (224:39): [True: 0, False: 0]
  ------------------
  225|      0|      return std::make_unique<BLAKE2b>(req.arg_as_integer(0, 512));
  226|      0|   }
  227|      0|#endif
  228|       |
  229|      0|#if defined(BOTAN_HAS_BLAKE2S)
  230|      0|   if(req.algo_name() == "Blake2s" || req.algo_name() == "BLAKE2s") {
  ------------------
  |  Branch (230:7): [True: 0, False: 0]
  |  Branch (230:39): [True: 0, False: 0]
  ------------------
  231|      0|      return std::make_unique<BLAKE2s>(req.arg_as_integer(0, 256));
  232|      0|   }
  233|      0|#endif
  234|       |
  235|      0|#if defined(BOTAN_HAS_KECCAK)
  236|      0|   if(req.algo_name() == "Keccak-1600") {
  ------------------
  |  Branch (236:7): [True: 0, False: 0]
  ------------------
  237|      0|      return std::make_unique<Keccak_1600>(req.arg_as_integer(0, 512));
  238|      0|   }
  239|      0|#endif
  240|       |
  241|      0|#if defined(BOTAN_HAS_SHA3)
  242|      0|   if(req.algo_name() == "SHA-3") {
  ------------------
  |  Branch (242:7): [True: 0, False: 0]
  ------------------
  243|      0|      return std::make_unique<SHA_3>(req.arg_as_integer(0, 512));
  244|      0|   }
  245|      0|#endif
  246|       |
  247|      0|#if defined(BOTAN_HAS_SHAKE)
  248|      0|   if(req.algo_name() == "SHAKE-128" && req.arg_count() == 1) {
  ------------------
  |  Branch (248:7): [True: 0, False: 0]
  |  Branch (248:41): [True: 0, False: 0]
  ------------------
  249|      0|      return std::make_unique<SHAKE_128>(req.arg_as_integer(0));
  250|      0|   }
  251|      0|   if(req.algo_name() == "SHAKE-256" && req.arg_count() == 1) {
  ------------------
  |  Branch (251:7): [True: 0, False: 0]
  |  Branch (251:41): [True: 0, False: 0]
  ------------------
  252|      0|      return std::make_unique<SHAKE_256>(req.arg_as_integer(0));
  253|      0|   }
  254|      0|#endif
  255|       |
  256|      0|#if defined(BOTAN_HAS_PARALLEL_HASH)
  257|      0|   if(req.algo_name() == "Parallel") {
  ------------------
  |  Branch (257:7): [True: 0, False: 0]
  ------------------
  258|      0|      std::vector<std::unique_ptr<HashFunction>> hashes;
  259|       |
  260|      0|      for(size_t i = 0; i != req.arg_count(); ++i) {
  ------------------
  |  Branch (260:25): [True: 0, False: 0]
  ------------------
  261|      0|         auto h = HashFunction::create(req.arg(i));
  262|      0|         if(!h) {
  ------------------
  |  Branch (262:13): [True: 0, False: 0]
  ------------------
  263|      0|            return nullptr;
  264|      0|         }
  265|      0|         hashes.push_back(std::move(h));
  266|      0|      }
  267|       |
  268|      0|      return std::make_unique<Parallel>(hashes);
  269|      0|   }
  270|      0|#endif
  271|       |
  272|      0|#if defined(BOTAN_HAS_TRUNCATED_HASH)
  273|      0|   if(req.algo_name() == "Truncated" && req.arg_count() == 2) {
  ------------------
  |  Branch (273:7): [True: 0, False: 0]
  |  Branch (273:41): [True: 0, False: 0]
  ------------------
  274|      0|      auto hash = HashFunction::create(req.arg(0));
  275|      0|      if(!hash) {
  ------------------
  |  Branch (275:10): [True: 0, False: 0]
  ------------------
  276|      0|         return nullptr;
  277|      0|      }
  278|       |
  279|      0|      return std::make_unique<Truncated_Hash>(std::move(hash), req.arg_as_integer(1));
  280|      0|   }
  281|      0|#endif
  282|       |
  283|      0|#if defined(BOTAN_HAS_COMB4P)
  284|      0|   if(req.algo_name() == "Comb4P" && req.arg_count() == 2) {
  ------------------
  |  Branch (284:7): [True: 0, False: 0]
  |  Branch (284:38): [True: 0, False: 0]
  ------------------
  285|      0|      auto h1 = HashFunction::create(req.arg(0));
  286|      0|      auto h2 = HashFunction::create(req.arg(1));
  287|       |
  288|      0|      if(h1 && h2) {
  ------------------
  |  Branch (288:10): [True: 0, False: 0]
  |  Branch (288:16): [True: 0, False: 0]
  ------------------
  289|      0|         return std::make_unique<Comb4P>(std::move(h1), std::move(h2));
  290|      0|      }
  291|      0|   }
  292|      0|#endif
  293|       |
  294|      0|   return nullptr;
  295|      0|}
_ZN5Botan12HashFunction15create_or_throwENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
  298|  16.5k|std::unique_ptr<HashFunction> HashFunction::create_or_throw(std::string_view algo, std::string_view provider) {
  299|  16.5k|   if(auto hash = HashFunction::create(algo, provider)) {
  ------------------
  |  Branch (299:12): [True: 16.5k, False: 0]
  ------------------
  300|  16.5k|      return hash;
  301|  16.5k|   }
  302|      0|   throw Lookup_Error("Hash", algo, provider);
  303|  16.5k|}

_ZN5Botan7SHA_51215compress_digestERNSt3__16vectorImNS_16secure_allocatorImEEEENS1_4spanIKhLm18446744073709551615EEEm:
   58|   407k|void SHA_512::compress_digest(digest_type& digest, std::span<const uint8_t> input, size_t blocks) {
   59|   407k|#if defined(BOTAN_HAS_SHA2_64_X86)
   60|   407k|   if(CPUID::has(CPUID::Feature::SHA512)) {
  ------------------
  |  Branch (60:7): [True: 0, False: 407k]
  ------------------
   61|      0|      return compress_digest_x86(digest, input, blocks);
   62|      0|   }
   63|   407k|#endif
   64|       |
   65|       |#if defined(BOTAN_HAS_SHA2_64_ARMV8)
   66|       |   if(CPUID::has(CPUID::Feature::SHA2_512)) {
   67|       |      return compress_digest_armv8(digest, input, blocks);
   68|       |   }
   69|       |#endif
   70|       |
   71|   407k|#if defined(BOTAN_HAS_SHA2_64_X86_AVX512)
   72|   407k|   if(CPUID::has(CPUID::Feature::AVX512, CPUID::Feature::BMI)) {
  ------------------
  |  Branch (72:7): [True: 0, False: 407k]
  ------------------
   73|      0|      return compress_digest_x86_avx512(digest, input, blocks);
   74|      0|   }
   75|   407k|#endif
   76|       |
   77|   407k|#if defined(BOTAN_HAS_SHA2_64_X86_AVX2)
   78|   407k|   if(CPUID::has(CPUID::Feature::AVX2, CPUID::Feature::BMI)) {
  ------------------
  |  Branch (78:7): [True: 407k, False: 0]
  ------------------
   79|   407k|      return compress_digest_x86_avx2(digest, input, blocks);
   80|   407k|   }
   81|      0|#endif
   82|       |
   83|      0|   uint64_t A = digest[0], B = digest[1], C = digest[2], D = digest[3], E = digest[4], F = digest[5], G = digest[6],
   84|      0|            H = digest[7];
   85|       |
   86|      0|   std::array<uint64_t, 16> W;
   87|       |
   88|      0|   BufferSlicer in(input);
   89|       |
   90|      0|   for(size_t i = 0; i != blocks; ++i) {
  ------------------
  |  Branch (90:22): [True: 0, False: 0]
  ------------------
   91|      0|      load_be(W, in.take<block_bytes>());
   92|       |
   93|       |      // clang-format off
   94|       |
   95|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0x428A2F98D728AE22);
   96|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0x7137449123EF65CD);
   97|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0xB5C0FBCFEC4D3B2F);
   98|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0xE9B5DBA58189DBBC);
   99|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x3956C25BF348B538);
  100|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x59F111F1B605D019);
  101|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x923F82A4AF194F9B);
  102|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0xAB1C5ED5DA6D8118);
  103|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0xD807AA98A3030242);
  104|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0x12835B0145706FBE);
  105|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0x243185BE4EE4B28C);
  106|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0x550C7DC3D5FFB4E2);
  107|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0x72BE5D74F27B896F);
  108|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0x80DEB1FE3B1696B1);
  109|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0x9BDC06A725C71235);
  110|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0xC19BF174CF692694);
  111|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0xE49B69C19EF14AD2);
  112|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0xEFBE4786384F25E3);
  113|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0x0FC19DC68B8CD5B5);
  114|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0x240CA1CC77AC9C65);
  115|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x2DE92C6F592B0275);
  116|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x4A7484AA6EA6E483);
  117|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x5CB0A9DCBD41FBD4);
  118|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x76F988DA831153B5);
  119|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0x983E5152EE66DFAB);
  120|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0xA831C66D2DB43210);
  121|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0xB00327C898FB213F);
  122|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0xBF597FC7BEEF0EE4);
  123|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0xC6E00BF33DA88FC2);
  124|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0xD5A79147930AA725);
  125|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0x06CA6351E003826F);
  126|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0x142929670A0E6E70);
  127|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0x27B70A8546D22FFC);
  128|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0x2E1B21385C26C926);
  129|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0x4D2C6DFC5AC42AED);
  130|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0x53380D139D95B3DF);
  131|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x650A73548BAF63DE);
  132|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x766A0ABB3C77B2A8);
  133|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x81C2C92E47EDAEE6);
  134|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x92722C851482353B);
  135|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0xA2BFE8A14CF10364);
  136|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0xA81A664BBC423001);
  137|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0xC24B8B70D0F89791);
  138|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0xC76C51A30654BE30);
  139|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0xD192E819D6EF5218);
  140|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0xD69906245565A910);
  141|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0xF40E35855771202A);
  142|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0x106AA07032BBD1B8);
  143|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0x19A4C116B8D2D0C8);
  144|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0x1E376C085141AB53);
  145|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0x2748774CDF8EEB99);
  146|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0x34B0BCB5E19B48A8);
  147|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x391C0CB3C5C95A63);
  148|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x4ED8AA4AE3418ACB);
  149|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x5B9CCA4F7763E373);
  150|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x682E6FF3D6B2B8A3);
  151|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0x748F82EE5DEFB2FC);
  152|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0x78A5636F43172F60);
  153|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0x84C87814A1F0AB72);
  154|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0x8CC702081A6439EC);
  155|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0x90BEFFFA23631E28);
  156|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0xA4506CEBDE82BDE9);
  157|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0xBEF9A3F7B2C67915);
  158|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0xC67178F2E372532B);
  159|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0xCA273ECEEA26619C);
  160|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0xD186B8C721C0C207);
  161|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0xEADA7DD6CDE0EB1E);
  162|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0xF57D4F7FEE6ED178);
  163|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x06F067AA72176FBA);
  164|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x0A637DC5A2C898A6);
  165|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x113F9804BEF90DAE);
  166|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x1B710B35131C471B);
  167|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0x28DB77F523047D84);
  168|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0x32CAAB7B40C72493);
  169|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0x3C9EBE0A15C9BEBC);
  170|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0x431D67C49C100D4C);
  171|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0x4CC5D4BECB3E42B6);
  172|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0x597F299CFC657E2A);
  173|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0x5FCB6FAB3AD6FAEC);
  174|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0x6C44198C4A475817);
  175|       |
  176|       |      // clang-format on
  177|       |
  178|      0|      A = (digest[0] += A);
  179|      0|      B = (digest[1] += B);
  180|      0|      C = (digest[2] += C);
  181|      0|      D = (digest[3] += D);
  182|      0|      E = (digest[4] += E);
  183|      0|      F = (digest[5] += F);
  184|      0|      G = (digest[6] += G);
  185|      0|      H = (digest[7] += H);
  186|      0|   }
  187|      0|}
_ZN5Botan7SHA_51210compress_nERNSt3__16vectorImNS_16secure_allocatorImEEEENS1_4spanIKhLm18446744073709551615EEEm:
  209|   407k|void SHA_512::compress_n(digest_type& digest, std::span<const uint8_t> input, size_t blocks) {
  210|   407k|   SHA_512::compress_digest(digest, input, blocks);
  211|   407k|}
_ZN5Botan7SHA_5124initERNSt3__16vectorImNS_16secure_allocatorImEEEE:
  235|   247k|void SHA_512::init(digest_type& digest) {
  236|   247k|   digest.assign({0x6A09E667F3BCC908,
  237|   247k|                  0xBB67AE8584CAA73B,
  238|   247k|                  0x3C6EF372FE94F82B,
  239|   247k|                  0xA54FF53A5F1D36F1,
  240|   247k|                  0x510E527FADE682D1,
  241|   247k|                  0x9B05688C2B3E6C1F,
  242|   247k|                  0x1F83D9ABFB41BD6B,
  243|   247k|                  0x5BE0CD19137E2179});
  244|   247k|}
_ZN5Botan7SHA_5128add_dataENSt3__14spanIKhLm18446744073709551615EEE:
  274|   488k|void SHA_512::add_data(std::span<const uint8_t> input) {
  275|   488k|   m_md.update(input);
  276|   488k|}
_ZN5Botan7SHA_51212final_resultENSt3__14spanIhLm18446744073709551615EEE:
  286|   188k|void SHA_512::final_result(std::span<uint8_t> output) {
  287|   188k|   m_md.final(output);
  288|   188k|}

_ZN5Botan7SHA_51224compress_digest_x86_avx2ERNSt3__16vectorImNS_16secure_allocatorImEEEENS1_4spanIKhLm18446744073709551615EEEm:
   46|   407k|                                                              size_t blocks) {
   47|       |   // clang-format off
   48|   407k|   alignas(64) const uint64_t K[80] = {
   49|   407k|      0x428A2F98D728AE22, 0x7137449123EF65CD, 0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC,
   50|   407k|      0x3956C25BF348B538, 0x59F111F1B605D019, 0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118,
   51|   407k|      0xD807AA98A3030242, 0x12835B0145706FBE, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
   52|   407k|      0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x9BDC06A725C71235, 0xC19BF174CF692694,
   53|   407k|      0xE49B69C19EF14AD2, 0xEFBE4786384F25E3, 0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65,
   54|   407k|      0x2DE92C6F592B0275, 0x4A7484AA6EA6E483, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
   55|   407k|      0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0xB00327C898FB213F, 0xBF597FC7BEEF0EE4,
   56|   407k|      0xC6E00BF33DA88FC2, 0xD5A79147930AA725, 0x06CA6351E003826F, 0x142929670A0E6E70,
   57|   407k|      0x27B70A8546D22FFC, 0x2E1B21385C26C926, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
   58|   407k|      0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x81C2C92E47EDAEE6, 0x92722C851482353B,
   59|   407k|      0xA2BFE8A14CF10364, 0xA81A664BBC423001, 0xC24B8B70D0F89791, 0xC76C51A30654BE30,
   60|   407k|      0xD192E819D6EF5218, 0xD69906245565A910, 0xF40E35855771202A, 0x106AA07032BBD1B8,
   61|   407k|      0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8,
   62|   407k|      0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB, 0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3,
   63|   407k|      0x748F82EE5DEFB2FC, 0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
   64|   407k|      0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0xBEF9A3F7B2C67915, 0xC67178F2E372532B,
   65|   407k|      0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178,
   66|   407k|      0x06F067AA72176FBA, 0x0A637DC5A2C898A6, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
   67|   407k|      0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C,
   68|   407k|      0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A, 0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817,
   69|   407k|   };
   70|       |
   71|       |   // K2 is each pair of elements in K repeated since we are performing 2 parallel
   72|       |   // message expansions
   73|   407k|   alignas(64) const uint64_t K2[2 * 80] = {
   74|   407k|      0x428A2F98D728AE22, 0x7137449123EF65CD, 0x428A2F98D728AE22, 0x7137449123EF65CD,
   75|   407k|      0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC, 0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC,
   76|   407k|      0x3956C25BF348B538, 0x59F111F1B605D019, 0x3956C25BF348B538, 0x59F111F1B605D019,
   77|   407k|      0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118, 0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118,
   78|   407k|      0xD807AA98A3030242, 0x12835B0145706FBE, 0xD807AA98A3030242, 0x12835B0145706FBE,
   79|   407k|      0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
   80|   407k|      0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1,
   81|   407k|      0x9BDC06A725C71235, 0xC19BF174CF692694, 0x9BDC06A725C71235, 0xC19BF174CF692694,
   82|   407k|      0xE49B69C19EF14AD2, 0xEFBE4786384F25E3, 0xE49B69C19EF14AD2, 0xEFBE4786384F25E3,
   83|   407k|      0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65, 0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65,
   84|   407k|      0x2DE92C6F592B0275, 0x4A7484AA6EA6E483, 0x2DE92C6F592B0275, 0x4A7484AA6EA6E483,
   85|   407k|      0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
   86|   407k|      0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0x983E5152EE66DFAB, 0xA831C66D2DB43210,
   87|   407k|      0xB00327C898FB213F, 0xBF597FC7BEEF0EE4, 0xB00327C898FB213F, 0xBF597FC7BEEF0EE4,
   88|   407k|      0xC6E00BF33DA88FC2, 0xD5A79147930AA725, 0xC6E00BF33DA88FC2, 0xD5A79147930AA725,
   89|   407k|      0x06CA6351E003826F, 0x142929670A0E6E70, 0x06CA6351E003826F, 0x142929670A0E6E70,
   90|   407k|      0x27B70A8546D22FFC, 0x2E1B21385C26C926, 0x27B70A8546D22FFC, 0x2E1B21385C26C926,
   91|   407k|      0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
   92|   407k|      0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x650A73548BAF63DE, 0x766A0ABB3C77B2A8,
   93|   407k|      0x81C2C92E47EDAEE6, 0x92722C851482353B, 0x81C2C92E47EDAEE6, 0x92722C851482353B,
   94|   407k|      0xA2BFE8A14CF10364, 0xA81A664BBC423001, 0xA2BFE8A14CF10364, 0xA81A664BBC423001,
   95|   407k|      0xC24B8B70D0F89791, 0xC76C51A30654BE30, 0xC24B8B70D0F89791, 0xC76C51A30654BE30,
   96|   407k|      0xD192E819D6EF5218, 0xD69906245565A910, 0xD192E819D6EF5218, 0xD69906245565A910,
   97|   407k|      0xF40E35855771202A, 0x106AA07032BBD1B8, 0xF40E35855771202A, 0x106AA07032BBD1B8,
   98|   407k|      0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x19A4C116B8D2D0C8, 0x1E376C085141AB53,
   99|   407k|      0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8, 0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8,
  100|   407k|      0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB, 0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB,
  101|   407k|      0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3, 0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3,
  102|   407k|      0x748F82EE5DEFB2FC, 0x78A5636F43172F60, 0x748F82EE5DEFB2FC, 0x78A5636F43172F60,
  103|   407k|      0x84C87814A1F0AB72, 0x8CC702081A6439EC, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
  104|   407k|      0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9,
  105|   407k|      0xBEF9A3F7B2C67915, 0xC67178F2E372532B, 0xBEF9A3F7B2C67915, 0xC67178F2E372532B,
  106|   407k|      0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xCA273ECEEA26619C, 0xD186B8C721C0C207,
  107|   407k|      0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178,
  108|   407k|      0x06F067AA72176FBA, 0x0A637DC5A2C898A6, 0x06F067AA72176FBA, 0x0A637DC5A2C898A6,
  109|   407k|      0x113F9804BEF90DAE, 0x1B710B35131C471B, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
  110|   407k|      0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x28DB77F523047D84, 0x32CAAB7B40C72493,
  111|   407k|      0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C,
  112|   407k|      0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A, 0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A,
  113|   407k|      0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817, 0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817,
  114|   407k|   };
  115|       |   // clang-format on
  116|       |
  117|   407k|   alignas(64) uint64_t W[16] = {0};
  118|   407k|   alignas(64) uint64_t W2[80];
  119|       |
  120|   407k|   uint64_t A = digest[0];
  121|   407k|   uint64_t B = digest[1];
  122|   407k|   uint64_t C = digest[2];
  123|   407k|   uint64_t D = digest[3];
  124|   407k|   uint64_t E = digest[4];
  125|   407k|   uint64_t F = digest[5];
  126|   407k|   uint64_t G = digest[6];
  127|   407k|   uint64_t H = digest[7];
  128|       |
  129|   407k|   const uint8_t* data = input.data();
  130|       |
  131|   465k|   while(blocks >= 2) {
  ------------------
  |  Branch (131:10): [True: 57.5k, False: 407k]
  ------------------
  132|  57.5k|      SIMD_4x64 WS[8];
  133|       |
  134|   517k|      for(size_t i = 0; i < 8; i++) {
  ------------------
  |  Branch (134:25): [True: 460k, False: 57.5k]
  ------------------
  135|   460k|         WS[i] = SIMD_4x64::load_be2(&data[16 * i], &data[128 + 16 * i]);
  136|   460k|         auto WK = WS[i] + SIMD_4x64::load_le(&K2[4 * i]);
  137|   460k|         WK.store_le2(&W[2 * i], &W2[2 * i]);
  138|   460k|      }
  139|       |
  140|  57.5k|      data += 2 * 128;
  141|  57.5k|      blocks -= 2;
  142|       |
  143|       |      // First 64 rounds of SHA-512
  144|   287k|      for(size_t r = 0; r != 64; r += 16) {
  ------------------
  |  Branch (144:25): [True: 230k, False: 57.5k]
  ------------------
  145|   230k|         auto w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 16)]);
  146|   230k|         SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  147|   230k|         SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  148|   230k|         w.store_le2(&W[0], &W2[r + 16]);
  149|       |
  150|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 18)]);
  151|   230k|         SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  152|   230k|         SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  153|   230k|         w.store_le2(&W[2], &W2[r + 18]);
  154|       |
  155|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 20)]);
  156|   230k|         SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  157|   230k|         SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  158|   230k|         w.store_le2(&W[4], &W2[r + 20]);
  159|       |
  160|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 22)]);
  161|   230k|         SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  162|   230k|         SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  163|   230k|         w.store_le2(&W[6], &W2[r + 22]);
  164|       |
  165|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 24)]);
  166|   230k|         SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  167|   230k|         SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  168|   230k|         w.store_le2(&W[8], &W2[r + 24]);
  169|       |
  170|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 26)]);
  171|   230k|         SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  172|   230k|         SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  173|   230k|         w.store_le2(&W[10], &W2[r + 26]);
  174|       |
  175|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 28)]);
  176|   230k|         SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  177|   230k|         SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  178|   230k|         w.store_le2(&W[12], &W2[r + 28]);
  179|       |
  180|   230k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 30)]);
  181|   230k|         SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  182|   230k|         SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  183|   230k|         w.store_le2(&W[14], &W2[r + 30]);
  184|   230k|      }
  185|       |
  186|       |      // Final 16 rounds of SHA-512
  187|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  188|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  189|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  190|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  191|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  192|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  193|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  194|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  195|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  196|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  197|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  198|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  199|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  200|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  201|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  202|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  203|       |
  204|  57.5k|      A = (digest[0] += A);
  205|  57.5k|      B = (digest[1] += B);
  206|  57.5k|      C = (digest[2] += C);
  207|  57.5k|      D = (digest[3] += D);
  208|  57.5k|      E = (digest[4] += E);
  209|  57.5k|      F = (digest[5] += F);
  210|  57.5k|      G = (digest[6] += G);
  211|  57.5k|      H = (digest[7] += H);
  212|       |
  213|       |      // Second block of SHA-512 compression, with pre-expanded message
  214|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[0]);
  215|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[1]);
  216|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[2]);
  217|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[3]);
  218|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[4]);
  219|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[5]);
  220|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[6]);
  221|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[7]);
  222|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[8]);
  223|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[9]);
  224|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[10]);
  225|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[11]);
  226|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[12]);
  227|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[13]);
  228|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[14]);
  229|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[15]);
  230|       |
  231|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[16]);
  232|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[17]);
  233|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[18]);
  234|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[19]);
  235|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[20]);
  236|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[21]);
  237|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[22]);
  238|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[23]);
  239|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[24]);
  240|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[25]);
  241|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[26]);
  242|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[27]);
  243|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[28]);
  244|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[29]);
  245|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[30]);
  246|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[31]);
  247|       |
  248|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[32]);
  249|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[33]);
  250|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[34]);
  251|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[35]);
  252|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[36]);
  253|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[37]);
  254|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[38]);
  255|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[39]);
  256|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[40]);
  257|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[41]);
  258|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[42]);
  259|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[43]);
  260|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[44]);
  261|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[45]);
  262|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[46]);
  263|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[47]);
  264|       |
  265|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[48]);
  266|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[49]);
  267|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[50]);
  268|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[51]);
  269|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[52]);
  270|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[53]);
  271|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[54]);
  272|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[55]);
  273|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[56]);
  274|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[57]);
  275|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[58]);
  276|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[59]);
  277|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[60]);
  278|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[61]);
  279|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[62]);
  280|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[63]);
  281|       |
  282|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[64]);
  283|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[65]);
  284|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[66]);
  285|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[67]);
  286|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[68]);
  287|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[69]);
  288|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[70]);
  289|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[71]);
  290|  57.5k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[72]);
  291|  57.5k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[73]);
  292|  57.5k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[74]);
  293|  57.5k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[75]);
  294|  57.5k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[76]);
  295|  57.5k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[77]);
  296|  57.5k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[78]);
  297|  57.5k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[79]);
  298|       |
  299|  57.5k|      A = (digest[0] += A);
  300|  57.5k|      B = (digest[1] += B);
  301|  57.5k|      C = (digest[2] += C);
  302|  57.5k|      D = (digest[3] += D);
  303|  57.5k|      E = (digest[4] += E);
  304|  57.5k|      F = (digest[5] += F);
  305|  57.5k|      G = (digest[6] += G);
  306|  57.5k|      H = (digest[7] += H);
  307|  57.5k|   }
  308|       |
  309|   811k|   while(blocks > 0) {
  ------------------
  |  Branch (309:10): [True: 403k, False: 407k]
  ------------------
  310|   403k|      SIMD_2x64 WS[8];
  311|       |
  312|  3.63M|      for(size_t i = 0; i < 8; i++) {
  ------------------
  |  Branch (312:25): [True: 3.22M, False: 403k]
  ------------------
  313|  3.22M|         WS[i] = SIMD_2x64::load_be(&data[16 * i]);
  314|  3.22M|         auto WK = WS[i] + SIMD_2x64::load_le(&K[2 * i]);
  315|  3.22M|         WK.store_le(&W[2 * i]);
  316|  3.22M|      }
  317|       |
  318|   403k|      data += 128;
  319|   403k|      blocks -= 1;
  320|       |
  321|       |      // First 64 rounds of SHA-512
  322|  2.01M|      for(size_t r = 0; r != 64; r += 16) {
  ------------------
  |  Branch (322:25): [True: 1.61M, False: 403k]
  ------------------
  323|  1.61M|         auto w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 16]);
  324|  1.61M|         SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  325|  1.61M|         SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  326|  1.61M|         w.store_le(&W[0]);
  327|       |
  328|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 18]);
  329|  1.61M|         SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  330|  1.61M|         SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  331|  1.61M|         w.store_le(&W[2]);
  332|       |
  333|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 20]);
  334|  1.61M|         SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  335|  1.61M|         SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  336|  1.61M|         w.store_le(&W[4]);
  337|       |
  338|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 22]);
  339|  1.61M|         SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  340|  1.61M|         SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  341|  1.61M|         w.store_le(&W[6]);
  342|       |
  343|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 24]);
  344|  1.61M|         SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  345|  1.61M|         SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  346|  1.61M|         w.store_le(&W[8]);
  347|       |
  348|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 26]);
  349|  1.61M|         SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  350|  1.61M|         SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  351|  1.61M|         w.store_le(&W[10]);
  352|       |
  353|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 28]);
  354|  1.61M|         SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  355|  1.61M|         SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  356|  1.61M|         w.store_le(&W[12]);
  357|       |
  358|  1.61M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 30]);
  359|  1.61M|         SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  360|  1.61M|         SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  361|  1.61M|         w.store_le(&W[14]);
  362|  1.61M|      }
  363|       |
  364|       |      // Final 16 rounds of SHA-512
  365|   403k|      SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  366|   403k|      SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  367|   403k|      SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  368|   403k|      SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  369|   403k|      SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  370|   403k|      SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  371|   403k|      SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  372|   403k|      SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  373|   403k|      SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  374|   403k|      SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  375|   403k|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  376|   403k|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  377|   403k|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  378|   403k|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  379|   403k|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  380|   403k|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  381|       |
  382|   403k|      A = (digest[0] += A);
  383|   403k|      B = (digest[1] += B);
  384|   403k|      C = (digest[2] += C);
  385|   403k|      D = (digest[3] += D);
  386|   403k|      E = (digest[4] += E);
  387|   403k|      F = (digest[5] += F);
  388|   403k|      G = (digest[6] += G);
  389|   403k|      H = (digest[7] += H);
  390|   403k|   }
  391|   407k|}
sha2_64_avx2.cpp:_ZN5Botan12_GLOBAL__N_113sha512_next_wINS_9SIMD_4x64EEET_PS3_:
   21|  1.84M|BOTAN_FORCE_INLINE BOTAN_FN_ISA_AVX2_BMI2 SIMD_T sha512_next_w(SIMD_T x[8]) {
   22|  1.84M|   auto t0 = SIMD_T::alignr8(x[1], x[0]);
   23|  1.84M|   auto t1 = SIMD_T::alignr8(x[5], x[4]);
   24|       |
   25|  1.84M|   auto s0 = t0.template rotr<1>() ^ t0.template rotr<8>() ^ t0.template shr<7>();
   26|  1.84M|   auto s1 = x[7].template rotr<19>() ^ x[7].template rotr<61>() ^ x[7].template shr<6>();
   27|       |
   28|  1.84M|   auto nx = x[0] + s0 + s1 + t1;
   29|       |
   30|  1.84M|   x[0] = x[1];
   31|  1.84M|   x[1] = x[2];
   32|  1.84M|   x[2] = x[3];
   33|  1.84M|   x[3] = x[4];
   34|  1.84M|   x[4] = x[5];
   35|  1.84M|   x[5] = x[6];
   36|  1.84M|   x[6] = x[7];
   37|  1.84M|   x[7] = nx;
   38|       |
   39|  1.84M|   return x[7];
   40|  1.84M|}
sha2_64_avx2.cpp:_ZN5Botan12_GLOBAL__N_113sha512_next_wINS_9SIMD_2x64EEET_PS3_:
   21|  12.9M|BOTAN_FORCE_INLINE BOTAN_FN_ISA_AVX2_BMI2 SIMD_T sha512_next_w(SIMD_T x[8]) {
   22|  12.9M|   auto t0 = SIMD_T::alignr8(x[1], x[0]);
   23|  12.9M|   auto t1 = SIMD_T::alignr8(x[5], x[4]);
   24|       |
   25|  12.9M|   auto s0 = t0.template rotr<1>() ^ t0.template rotr<8>() ^ t0.template shr<7>();
   26|  12.9M|   auto s1 = x[7].template rotr<19>() ^ x[7].template rotr<61>() ^ x[7].template shr<6>();
   27|       |
   28|  12.9M|   auto nx = x[0] + s0 + s1 + t1;
   29|       |
   30|  12.9M|   x[0] = x[1];
   31|  12.9M|   x[1] = x[2];
   32|  12.9M|   x[2] = x[3];
   33|  12.9M|   x[3] = x[4];
   34|  12.9M|   x[4] = x[5];
   35|  12.9M|   x[5] = x[6];
   36|  12.9M|   x[6] = x[7];
   37|  12.9M|   x[7] = nx;
   38|       |
   39|  12.9M|   return x[7];
   40|  12.9M|}

_ZN5Botan4HMAC8add_dataENSt3__14spanIKhLm18446744073709551615EEE:
   20|   151k|void HMAC::add_data(std::span<const uint8_t> input) {
   21|   151k|   assert_key_material_set();
   22|   151k|   m_hash->update(input);
   23|   151k|}
_ZN5Botan4HMAC12final_resultENSt3__14spanIhLm18446744073709551615EEE:
   28|  82.5k|void HMAC::final_result(std::span<uint8_t> mac) {
   29|  82.5k|   assert_key_material_set();
   30|  82.5k|   m_hash->final(mac);
   31|  82.5k|   m_hash->update(m_okey);
   32|  82.5k|   m_hash->update(mac.first(m_hash_output_length));
   33|  82.5k|   m_hash->final(mac);
   34|  82.5k|   m_hash->update(m_ikey);
   35|  82.5k|}
_ZNK5Botan4HMAC8key_specEv:
   37|  39.6k|Key_Length_Specification HMAC::key_spec() const {
   38|       |   // Support very long lengths for things like PBKDF2 and the TLS PRF
   39|  39.6k|   return Key_Length_Specification(0, 4096);
   40|  39.6k|}
_ZNK5Botan4HMAC13output_lengthEv:
   42|  89.1k|size_t HMAC::output_length() const {
   43|  89.1k|   return m_hash_output_length;
   44|  89.1k|}
_ZNK5Botan4HMAC19has_keying_materialEv:
   46|   234k|bool HMAC::has_keying_material() const {
   47|   234k|   return !m_okey.empty();
   48|   234k|}
_ZN5Botan4HMAC12key_scheduleENSt3__14spanIKhLm18446744073709551615EEE:
   53|  39.6k|void HMAC::key_schedule(std::span<const uint8_t> key) {
   54|  39.6k|   const uint8_t ipad = 0x36;
   55|  39.6k|   const uint8_t opad = 0x5C;
   56|       |
   57|  39.6k|   m_hash->clear();
   58|       |
   59|  39.6k|   m_ikey.resize(m_hash_block_size);
   60|  39.6k|   m_okey.resize(m_hash_block_size);
   61|       |
   62|  39.6k|   clear_mem(m_ikey.data(), m_ikey.size());
   63|  39.6k|   clear_mem(m_okey.data(), m_okey.size());
   64|       |
   65|       |   /*
   66|       |   * Sometimes the HMAC key length itself is sensitive, as with PBKDF2 where it
   67|       |   * reveals the length of the passphrase. Make some attempt to hide this to
   68|       |   * side channels. Clearly if the secret is longer than the block size then the
   69|       |   * branch to hash first reveals that. In addition, counting the number of
   70|       |   * compression functions executed reveals the size at the granularity of the
   71|       |   * hash function's block size.
   72|       |   *
   73|       |   * The greater concern is for smaller keys; being able to detect when a
   74|       |   * passphrase is say 4 bytes may assist choosing weaker targets. Even though
   75|       |   * the loop bounds are constant, we can only actually read key[0..length] so
   76|       |   * it doesn't seem possible to make this computation truly constant time.
   77|       |   *
   78|       |   * We don't mind leaking if the length is exactly zero since that's
   79|       |   * trivial to simply check.
   80|       |   */
   81|       |
   82|  39.6k|   if(key.size() > m_hash_block_size) {
  ------------------
  |  Branch (82:7): [True: 0, False: 39.6k]
  ------------------
   83|      0|      m_hash->update(key);
   84|      0|      m_hash->final(m_ikey.data());
   85|  39.6k|   } else if(key.size() >= 20) {
  ------------------
  |  Branch (85:14): [True: 39.6k, False: 0]
  ------------------
   86|       |      // For long keys we just leak the length either it is a cryptovariable
   87|       |      // or a long enough password that just the length is not a useful signal
   88|  39.6k|      copy_mem(std::span{m_ikey}.first(key.size()), key);
   89|  39.6k|   } else if(!key.empty()) {
  ------------------
  |  Branch (89:14): [True: 0, False: 0]
  ------------------
   90|      0|      for(size_t i = 0, i_mod_length = 0; i != m_hash_block_size; ++i) {
  ------------------
  |  Branch (90:43): [True: 0, False: 0]
  ------------------
   91|       |         /*
   92|       |         access key[i % length] but avoiding division due to variable
   93|       |         time computation on some processors.
   94|       |         */
   95|      0|         auto needs_reduction = CT::Mask<size_t>::is_lte(key.size(), i_mod_length);
   96|      0|         i_mod_length = needs_reduction.select(0, i_mod_length);
   97|      0|         const uint8_t kb = key[i_mod_length];
   98|       |
   99|      0|         auto in_range = CT::Mask<size_t>::is_lt(i, key.size());
  100|      0|         m_ikey[i] = static_cast<uint8_t>(in_range.if_set_return(kb));
  101|      0|         i_mod_length += 1;
  102|      0|      }
  103|      0|   }
  104|       |
  105|  5.10M|   for(size_t i = 0; i != m_hash_block_size; ++i) {
  ------------------
  |  Branch (105:22): [True: 5.06M, False: 39.6k]
  ------------------
  106|  5.06M|      m_ikey[i] ^= ipad;
  107|  5.06M|      m_okey[i] = m_ikey[i] ^ ipad ^ opad;
  108|  5.06M|   }
  109|       |
  110|  39.6k|   m_hash->update(m_ikey);
  111|  39.6k|}
_ZN5Botan4HMACC2ENSt3__110unique_ptrINS_12HashFunctionENS1_14default_deleteIS3_EEEE:
  140|  3.30k|      m_hash(std::move(hash)),
  141|  3.30k|      m_hash_output_length(m_hash->output_length()),
  142|  3.30k|      m_hash_block_size(m_hash->hash_block_size()) {
  143|  3.30k|   BOTAN_ARG_CHECK(m_hash_block_size >= m_hash_output_length, "HMAC is not compatible with this hash function");
  ------------------
  |  |   34|  3.30k|   do {                                                          \
  |  |   35|  3.30k|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (35:10): [True: 0, False: 3.30k]
  |  |  ------------------
  |  |   36|  3.30k|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   37|  3.30k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (37:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  144|  3.30k|}

_ZN5Botan25MessageAuthenticationCode6createENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
   52|  3.30k|                                                                             std::string_view provider) {
   53|  3.30k|   const SCAN_Name req(algo_spec);
   54|       |
   55|  3.30k|#if defined(BOTAN_HAS_BLAKE2BMAC)
   56|  3.30k|   if(req.algo_name() == "Blake2b" || req.algo_name() == "BLAKE2b") {
  ------------------
  |  Branch (56:7): [True: 0, False: 3.30k]
  |  Branch (56:39): [True: 0, False: 3.30k]
  ------------------
   57|      0|      return std::make_unique<BLAKE2bMAC>(req.arg_as_integer(0, 512));
   58|      0|   }
   59|  3.30k|#endif
   60|       |
   61|  3.30k|#if defined(BOTAN_HAS_GMAC)
   62|  3.30k|   if(req.algo_name() == "GMAC" && req.arg_count() == 1) {
  ------------------
  |  Branch (62:7): [True: 0, False: 3.30k]
  |  Branch (62:36): [True: 0, False: 0]
  ------------------
   63|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (63:10): [True: 0, False: 0]
  |  Branch (63:30): [True: 0, False: 0]
  ------------------
   64|      0|         if(auto bc = BlockCipher::create(req.arg(0))) {
  ------------------
  |  Branch (64:18): [True: 0, False: 0]
  ------------------
   65|      0|            return std::make_unique<GMAC>(std::move(bc));
   66|      0|         }
   67|      0|      }
   68|      0|   }
   69|  3.30k|#endif
   70|       |
   71|  3.30k|#if defined(BOTAN_HAS_HMAC)
   72|  3.30k|   if(req.algo_name() == "HMAC" && req.arg_count() == 1) {
  ------------------
  |  Branch (72:7): [True: 3.30k, False: 0]
  |  Branch (72:36): [True: 3.30k, False: 0]
  ------------------
   73|  3.30k|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (73:10): [True: 3.30k, False: 0]
  |  Branch (73:30): [True: 0, False: 0]
  ------------------
   74|  3.30k|         if(auto hash = HashFunction::create(req.arg(0))) {
  ------------------
  |  Branch (74:18): [True: 3.30k, False: 0]
  ------------------
   75|  3.30k|            return std::make_unique<HMAC>(std::move(hash));
   76|  3.30k|         }
   77|  3.30k|      }
   78|  3.30k|   }
   79|      0|#endif
   80|       |
   81|      0|#if defined(BOTAN_HAS_POLY1305)
   82|      0|   if(req.algo_name() == "Poly1305" && req.arg_count() == 0) {
  ------------------
  |  Branch (82:7): [True: 0, False: 0]
  |  Branch (82:40): [True: 0, False: 0]
  ------------------
   83|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (83:10): [True: 0, False: 0]
  |  Branch (83:30): [True: 0, False: 0]
  ------------------
   84|      0|         return std::make_unique<Poly1305>();
   85|      0|      }
   86|      0|   }
   87|      0|#endif
   88|       |
   89|      0|#if defined(BOTAN_HAS_SIPHASH)
   90|      0|   if(req.algo_name() == "SipHash") {
  ------------------
  |  Branch (90:7): [True: 0, False: 0]
  ------------------
   91|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (91:10): [True: 0, False: 0]
  |  Branch (91:30): [True: 0, False: 0]
  ------------------
   92|      0|         return std::make_unique<SipHash>(req.arg_as_integer(0, 2), req.arg_as_integer(1, 4));
   93|      0|      }
   94|      0|   }
   95|      0|#endif
   96|       |
   97|      0|#if defined(BOTAN_HAS_CMAC)
   98|      0|   if((req.algo_name() == "CMAC" || req.algo_name() == "OMAC") && req.arg_count() == 1) {
  ------------------
  |  Branch (98:8): [True: 0, False: 0]
  |  Branch (98:37): [True: 0, False: 0]
  |  Branch (98:67): [True: 0, False: 0]
  ------------------
   99|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (99:10): [True: 0, False: 0]
  |  Branch (99:30): [True: 0, False: 0]
  ------------------
  100|      0|         if(auto bc = BlockCipher::create(req.arg(0))) {
  ------------------
  |  Branch (100:18): [True: 0, False: 0]
  ------------------
  101|      0|            return std::make_unique<CMAC>(std::move(bc));
  102|      0|         }
  103|      0|      }
  104|      0|   }
  105|      0|#endif
  106|       |
  107|      0|#if defined(BOTAN_HAS_ANSI_X919_MAC)
  108|      0|   if(req.algo_name() == "X9.19-MAC") {
  ------------------
  |  Branch (108:7): [True: 0, False: 0]
  ------------------
  109|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (109:10): [True: 0, False: 0]
  |  Branch (109:30): [True: 0, False: 0]
  ------------------
  110|      0|         return std::make_unique<ANSI_X919_MAC>();
  111|      0|      }
  112|      0|   }
  113|      0|#endif
  114|       |
  115|      0|#if defined(BOTAN_HAS_KMAC)
  116|      0|   if(req.algo_name() == "KMAC-128") {
  ------------------
  |  Branch (116:7): [True: 0, False: 0]
  ------------------
  117|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (117:10): [True: 0, False: 0]
  |  Branch (117:30): [True: 0, False: 0]
  ------------------
  118|      0|         if(req.arg_count() != 1) {
  ------------------
  |  Branch (118:13): [True: 0, False: 0]
  ------------------
  119|      0|            throw Invalid_Argument(
  120|      0|               "invalid algorithm specification for KMAC-128: need exactly one argument for output bit length");
  121|      0|         }
  122|      0|         return std::make_unique<KMAC128>(req.arg_as_integer(0));
  123|      0|      }
  124|      0|   }
  125|       |
  126|      0|   if(req.algo_name() == "KMAC-256") {
  ------------------
  |  Branch (126:7): [True: 0, False: 0]
  ------------------
  127|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (127:10): [True: 0, False: 0]
  |  Branch (127:30): [True: 0, False: 0]
  ------------------
  128|      0|         if(req.arg_count() != 1) {
  ------------------
  |  Branch (128:13): [True: 0, False: 0]
  ------------------
  129|      0|            throw Invalid_Argument(
  130|      0|               "invalid algorithm specification for KMAC-256: need exactly one argument for output bit length");
  131|      0|         }
  132|      0|         return std::make_unique<KMAC256>(req.arg_as_integer(0));
  133|      0|      }
  134|      0|   }
  135|      0|#endif
  136|       |
  137|      0|   BOTAN_UNUSED(req);
  ------------------
  |  |  122|      0|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
  138|      0|   BOTAN_UNUSED(provider);
  ------------------
  |  |  122|      0|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
  139|       |
  140|      0|   return nullptr;
  141|      0|}

_ZN5Botan19ed25519_gen_keypairEPhS0_PKh:
   20|  3.30k|void ed25519_gen_keypair(uint8_t pk[32], uint8_t sk[64], const uint8_t seed[32]) {
   21|  3.30k|   uint8_t az[64];
   22|       |
   23|  3.30k|   auto sha512 = HashFunction::create_or_throw("SHA-512");
   24|  3.30k|   sha512->update(seed, 32);
   25|  3.30k|   sha512->final(az);
   26|  3.30k|   az[0] &= 248;
   27|  3.30k|   az[31] &= 63;
   28|  3.30k|   az[31] |= 64;
   29|       |
   30|  3.30k|   ed25519_basepoint_mul(std::span<uint8_t, 32>{pk, 32}, az);
   31|       |
   32|  3.30k|   copy_mem(sk, seed, 32);
   33|  3.30k|   copy_mem(sk + 32, pk, 32);
   34|  3.30k|}
_ZN5Botan12ed25519_signEPhPKhmS2_S2_m:
   41|  3.30k|                  size_t domain_sep_len) {
   42|  3.30k|   uint8_t az[64];
   43|  3.30k|   uint8_t nonce[64];
   44|  3.30k|   uint8_t hram[64];
   45|       |
   46|  3.30k|   auto sha512 = HashFunction::create_or_throw("SHA-512");
   47|       |
   48|  3.30k|   sha512->update(sk, 32);
   49|  3.30k|   sha512->final(az);
   50|  3.30k|   az[0] &= 248;
   51|  3.30k|   az[31] &= 63;
   52|  3.30k|   az[31] |= 64;
   53|       |
   54|  3.30k|   sha512->update(domain_sep, domain_sep_len);
   55|  3.30k|   sha512->update(az + 32, 32);
   56|  3.30k|   sha512->update(m, mlen);
   57|  3.30k|   sha512->final(nonce);
   58|       |
   59|  3.30k|   sc_reduce(nonce);
   60|  3.30k|   ed25519_basepoint_mul(std::span<uint8_t, 32>{sig, 32}, nonce);
   61|       |
   62|  3.30k|   sha512->update(domain_sep, domain_sep_len);
   63|  3.30k|   sha512->update(sig, 32);
   64|  3.30k|   sha512->update(sk + 32, 32);
   65|  3.30k|   sha512->update(m, mlen);
   66|  3.30k|   sha512->final(hram);
   67|       |
   68|  3.30k|   sc_reduce(hram);
   69|  3.30k|   sc_muladd(sig + 32, hram, az, nonce);
   70|  3.30k|}
_ZN5Botan14ed25519_verifyEPKhmS1_S1_S1_m:
   77|  3.30k|                    size_t domain_sep_len) {
   78|  3.30k|   if(sig[63] & 224) {
  ------------------
  |  Branch (78:7): [True: 0, False: 3.30k]
  ------------------
   79|      0|      return false;
   80|      0|   }
   81|       |
   82|  3.30k|   const uint64_t CURVE25519_ORDER[4] = {
   83|  3.30k|      0x1000000000000000,
   84|  3.30k|      0x0000000000000000,
   85|  3.30k|      0x14def9dea2f79cd6,
   86|  3.30k|      0x5812631a5cf5d3ed,
   87|  3.30k|   };
   88|       |
   89|  3.30k|   const uint64_t s[4] = {load_le<uint64_t>(sig + 32, 3),
   90|  3.30k|                          load_le<uint64_t>(sig + 32, 2),
   91|  3.30k|                          load_le<uint64_t>(sig + 32, 1),
   92|  3.30k|                          load_le<uint64_t>(sig + 32, 0)};
   93|       |
   94|       |   // RFC 8032 adds the requirement that we verify that s < order in
   95|       |   // the signature; this did not exist in the original Ed25519 spec.
   96|  3.30k|   for(size_t i = 0; i != 4; ++i) {
  ------------------
  |  Branch (96:22): [True: 3.30k, False: 0]
  ------------------
   97|  3.30k|      if(s[i] > CURVE25519_ORDER[i]) {
  ------------------
  |  Branch (97:10): [True: 0, False: 3.30k]
  ------------------
   98|      0|         return false;
   99|      0|      }
  100|  3.30k|      if(s[i] < CURVE25519_ORDER[i]) {
  ------------------
  |  Branch (100:10): [True: 3.30k, False: 0]
  ------------------
  101|  3.30k|         break;
  102|  3.30k|      }
  103|      0|      if(i == 3) {  // here s == order
  ------------------
  |  Branch (103:10): [True: 0, False: 0]
  ------------------
  104|      0|         return false;
  105|      0|      }
  106|      0|   }
  107|       |
  108|  3.30k|   uint8_t h[64];
  109|  3.30k|   auto sha512 = HashFunction::create_or_throw("SHA-512");
  110|       |
  111|  3.30k|   sha512->update(domain_sep, domain_sep_len);
  112|  3.30k|   sha512->update(sig, 32);
  113|  3.30k|   sha512->update(pk, 32);
  114|  3.30k|   sha512->update(m, mlen);
  115|  3.30k|   sha512->final(h);
  116|  3.30k|   sc_reduce(h);
  117|       |
  118|  3.30k|   return signature_check(std::span<const uint8_t, 32>{pk, 32}, h, sig, sig + 32);
  119|  3.30k|}

_ZNK5Botan20Ed25519_FieldElement6invertEv:
   18|  13.2k|Ed25519_FieldElement Ed25519_FieldElement::invert() const {
   19|  13.2k|   auto t0 = this->sqr();
   20|  13.2k|   auto t1 = t0.sqr_iter(2);
   21|  13.2k|   t1 = *this * t1;
   22|  13.2k|   t0 = t0 * t1;
   23|  13.2k|   auto t2 = t0.sqr();
   24|  13.2k|   t1 = t1 * t2;
   25|  13.2k|   t2 = t1.sqr_iter(5);
   26|  13.2k|   t1 = t2 * t1;
   27|  13.2k|   t2 = t1.sqr_iter(10);
   28|  13.2k|   t2 = t2 * t1;
   29|  13.2k|   auto t3 = t2.sqr_iter(20);
   30|  13.2k|   t2 = t3 * t2;
   31|  13.2k|   t2 = t2.sqr_iter(10);
   32|  13.2k|   t1 = t2 * t1;
   33|  13.2k|   t2 = t1.sqr_iter(50);
   34|  13.2k|   t2 = t2 * t1;
   35|  13.2k|   t3 = t2.sqr_iter(100);
   36|  13.2k|   t2 = t3 * t2;
   37|  13.2k|   t2 = t2.sqr_iter(50);
   38|  13.2k|   t1 = t2 * t1;
   39|  13.2k|   t1 = t1.sqr_iter(5);
   40|       |
   41|  13.2k|   t0 = t1 * t0;
   42|  13.2k|   return t0;
   43|  13.2k|}
_ZNK5Botan20Ed25519_FieldElement9pow_22523Ev:
   45|  6.60k|Ed25519_FieldElement Ed25519_FieldElement::pow_22523() const {
   46|  6.60k|   auto t0 = this->sqr();
   47|  6.60k|   auto t1 = t0.sqr_iter(2);
   48|  6.60k|   t1 = (*this) * t1;
   49|  6.60k|   t0 = t0 * t1;
   50|  6.60k|   t0 = t0.sqr();
   51|  6.60k|   t0 = t1 * t0;
   52|  6.60k|   t1 = t0.sqr_iter(5);
   53|  6.60k|   t0 = t1 * t0;
   54|  6.60k|   t1 = t0.sqr_iter(10);
   55|  6.60k|   t1 = t1 * t0;
   56|  6.60k|   auto t2 = t1.sqr_iter(20);
   57|  6.60k|   t1 = t2 * t1;
   58|  6.60k|   t1 = t1.sqr_iter(10);
   59|  6.60k|   t0 = t1 * t0;
   60|  6.60k|   t1 = t0.sqr_iter(50);
   61|  6.60k|   t1 = t1 * t0;
   62|  6.60k|   t2 = t1.sqr_iter(100);
   63|  6.60k|   t1 = t2 * t1;
   64|  6.60k|   t1 = t1.sqr_iter(50);
   65|  6.60k|   t0 = t1 * t0;
   66|  6.60k|   t0 = t0.sqr_iter(2);
   67|       |
   68|  6.60k|   t0 = t0 * (*this);
   69|  6.60k|   return t0;
   70|  6.60k|}
_ZN5Botan20Ed25519_FieldElement3mulERKS0_S2_:
  105|  11.4M|Ed25519_FieldElement Ed25519_FieldElement::mul(const Ed25519_FieldElement& f, const Ed25519_FieldElement& g) {
  106|  11.4M|   const int32_t f0 = f.m_fe[0];
  107|  11.4M|   const int32_t f1 = f.m_fe[1];
  108|  11.4M|   const int32_t f2 = f.m_fe[2];
  109|  11.4M|   const int32_t f3 = f.m_fe[3];
  110|  11.4M|   const int32_t f4 = f.m_fe[4];
  111|  11.4M|   const int32_t f5 = f.m_fe[5];
  112|  11.4M|   const int32_t f6 = f.m_fe[6];
  113|  11.4M|   const int32_t f7 = f.m_fe[7];
  114|  11.4M|   const int32_t f8 = f.m_fe[8];
  115|  11.4M|   const int32_t f9 = f.m_fe[9];
  116|       |
  117|  11.4M|   const int32_t g0 = g.m_fe[0];
  118|  11.4M|   const int32_t g1 = g.m_fe[1];
  119|  11.4M|   const int32_t g2 = g.m_fe[2];
  120|  11.4M|   const int32_t g3 = g.m_fe[3];
  121|  11.4M|   const int32_t g4 = g.m_fe[4];
  122|  11.4M|   const int32_t g5 = g.m_fe[5];
  123|  11.4M|   const int32_t g6 = g.m_fe[6];
  124|  11.4M|   const int32_t g7 = g.m_fe[7];
  125|  11.4M|   const int32_t g8 = g.m_fe[8];
  126|  11.4M|   const int32_t g9 = g.m_fe[9];
  127|       |
  128|  11.4M|   const int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */
  129|  11.4M|   const int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  130|  11.4M|   const int32_t g3_19 = 19 * g3;
  131|  11.4M|   const int32_t g4_19 = 19 * g4;
  132|  11.4M|   const int32_t g5_19 = 19 * g5;
  133|  11.4M|   const int32_t g6_19 = 19 * g6;
  134|  11.4M|   const int32_t g7_19 = 19 * g7;
  135|  11.4M|   const int32_t g8_19 = 19 * g8;
  136|  11.4M|   const int32_t g9_19 = 19 * g9;
  137|  11.4M|   const int32_t f1_2 = 2 * f1;
  138|  11.4M|   const int32_t f3_2 = 2 * f3;
  139|  11.4M|   const int32_t f5_2 = 2 * f5;
  140|  11.4M|   const int32_t f7_2 = 2 * f7;
  141|  11.4M|   const int32_t f9_2 = 2 * f9;
  142|       |
  143|  11.4M|   const int64_t f0g0 = f0 * static_cast<int64_t>(g0);
  144|  11.4M|   const int64_t f0g1 = f0 * static_cast<int64_t>(g1);
  145|  11.4M|   const int64_t f0g2 = f0 * static_cast<int64_t>(g2);
  146|  11.4M|   const int64_t f0g3 = f0 * static_cast<int64_t>(g3);
  147|  11.4M|   const int64_t f0g4 = f0 * static_cast<int64_t>(g4);
  148|  11.4M|   const int64_t f0g5 = f0 * static_cast<int64_t>(g5);
  149|  11.4M|   const int64_t f0g6 = f0 * static_cast<int64_t>(g6);
  150|  11.4M|   const int64_t f0g7 = f0 * static_cast<int64_t>(g7);
  151|  11.4M|   const int64_t f0g8 = f0 * static_cast<int64_t>(g8);
  152|  11.4M|   const int64_t f0g9 = f0 * static_cast<int64_t>(g9);
  153|  11.4M|   const int64_t f1g0 = f1 * static_cast<int64_t>(g0);
  154|  11.4M|   const int64_t f1g1_2 = f1_2 * static_cast<int64_t>(g1);
  155|  11.4M|   const int64_t f1g2 = f1 * static_cast<int64_t>(g2);
  156|  11.4M|   const int64_t f1g3_2 = f1_2 * static_cast<int64_t>(g3);
  157|  11.4M|   const int64_t f1g4 = f1 * static_cast<int64_t>(g4);
  158|  11.4M|   const int64_t f1g5_2 = f1_2 * static_cast<int64_t>(g5);
  159|  11.4M|   const int64_t f1g6 = f1 * static_cast<int64_t>(g6);
  160|  11.4M|   const int64_t f1g7_2 = f1_2 * static_cast<int64_t>(g7);
  161|  11.4M|   const int64_t f1g8 = f1 * static_cast<int64_t>(g8);
  162|  11.4M|   const int64_t f1g9_38 = f1_2 * static_cast<int64_t>(g9_19);
  163|  11.4M|   const int64_t f2g0 = f2 * static_cast<int64_t>(g0);
  164|  11.4M|   const int64_t f2g1 = f2 * static_cast<int64_t>(g1);
  165|  11.4M|   const int64_t f2g2 = f2 * static_cast<int64_t>(g2);
  166|  11.4M|   const int64_t f2g3 = f2 * static_cast<int64_t>(g3);
  167|  11.4M|   const int64_t f2g4 = f2 * static_cast<int64_t>(g4);
  168|  11.4M|   const int64_t f2g5 = f2 * static_cast<int64_t>(g5);
  169|  11.4M|   const int64_t f2g6 = f2 * static_cast<int64_t>(g6);
  170|  11.4M|   const int64_t f2g7 = f2 * static_cast<int64_t>(g7);
  171|  11.4M|   const int64_t f2g8_19 = f2 * static_cast<int64_t>(g8_19);
  172|  11.4M|   const int64_t f2g9_19 = f2 * static_cast<int64_t>(g9_19);
  173|  11.4M|   const int64_t f3g0 = f3 * static_cast<int64_t>(g0);
  174|  11.4M|   const int64_t f3g1_2 = f3_2 * static_cast<int64_t>(g1);
  175|  11.4M|   const int64_t f3g2 = f3 * static_cast<int64_t>(g2);
  176|  11.4M|   const int64_t f3g3_2 = f3_2 * static_cast<int64_t>(g3);
  177|  11.4M|   const int64_t f3g4 = f3 * static_cast<int64_t>(g4);
  178|  11.4M|   const int64_t f3g5_2 = f3_2 * static_cast<int64_t>(g5);
  179|  11.4M|   const int64_t f3g6 = f3 * static_cast<int64_t>(g6);
  180|  11.4M|   const int64_t f3g7_38 = f3_2 * static_cast<int64_t>(g7_19);
  181|  11.4M|   const int64_t f3g8_19 = f3 * static_cast<int64_t>(g8_19);
  182|  11.4M|   const int64_t f3g9_38 = f3_2 * static_cast<int64_t>(g9_19);
  183|  11.4M|   const int64_t f4g0 = f4 * static_cast<int64_t>(g0);
  184|  11.4M|   const int64_t f4g1 = f4 * static_cast<int64_t>(g1);
  185|  11.4M|   const int64_t f4g2 = f4 * static_cast<int64_t>(g2);
  186|  11.4M|   const int64_t f4g3 = f4 * static_cast<int64_t>(g3);
  187|  11.4M|   const int64_t f4g4 = f4 * static_cast<int64_t>(g4);
  188|  11.4M|   const int64_t f4g5 = f4 * static_cast<int64_t>(g5);
  189|  11.4M|   const int64_t f4g6_19 = f4 * static_cast<int64_t>(g6_19);
  190|  11.4M|   const int64_t f4g7_19 = f4 * static_cast<int64_t>(g7_19);
  191|  11.4M|   const int64_t f4g8_19 = f4 * static_cast<int64_t>(g8_19);
  192|  11.4M|   const int64_t f4g9_19 = f4 * static_cast<int64_t>(g9_19);
  193|  11.4M|   const int64_t f5g0 = f5 * static_cast<int64_t>(g0);
  194|  11.4M|   const int64_t f5g1_2 = f5_2 * static_cast<int64_t>(g1);
  195|  11.4M|   const int64_t f5g2 = f5 * static_cast<int64_t>(g2);
  196|  11.4M|   const int64_t f5g3_2 = f5_2 * static_cast<int64_t>(g3);
  197|  11.4M|   const int64_t f5g4 = f5 * static_cast<int64_t>(g4);
  198|  11.4M|   const int64_t f5g5_38 = f5_2 * static_cast<int64_t>(g5_19);
  199|  11.4M|   const int64_t f5g6_19 = f5 * static_cast<int64_t>(g6_19);
  200|  11.4M|   const int64_t f5g7_38 = f5_2 * static_cast<int64_t>(g7_19);
  201|  11.4M|   const int64_t f5g8_19 = f5 * static_cast<int64_t>(g8_19);
  202|  11.4M|   const int64_t f5g9_38 = f5_2 * static_cast<int64_t>(g9_19);
  203|  11.4M|   const int64_t f6g0 = f6 * static_cast<int64_t>(g0);
  204|  11.4M|   const int64_t f6g1 = f6 * static_cast<int64_t>(g1);
  205|  11.4M|   const int64_t f6g2 = f6 * static_cast<int64_t>(g2);
  206|  11.4M|   const int64_t f6g3 = f6 * static_cast<int64_t>(g3);
  207|  11.4M|   const int64_t f6g4_19 = f6 * static_cast<int64_t>(g4_19);
  208|  11.4M|   const int64_t f6g5_19 = f6 * static_cast<int64_t>(g5_19);
  209|  11.4M|   const int64_t f6g6_19 = f6 * static_cast<int64_t>(g6_19);
  210|  11.4M|   const int64_t f6g7_19 = f6 * static_cast<int64_t>(g7_19);
  211|  11.4M|   const int64_t f6g8_19 = f6 * static_cast<int64_t>(g8_19);
  212|  11.4M|   const int64_t f6g9_19 = f6 * static_cast<int64_t>(g9_19);
  213|  11.4M|   const int64_t f7g0 = f7 * static_cast<int64_t>(g0);
  214|  11.4M|   const int64_t f7g1_2 = f7_2 * static_cast<int64_t>(g1);
  215|  11.4M|   const int64_t f7g2 = f7 * static_cast<int64_t>(g2);
  216|  11.4M|   const int64_t f7g3_38 = f7_2 * static_cast<int64_t>(g3_19);
  217|  11.4M|   const int64_t f7g4_19 = f7 * static_cast<int64_t>(g4_19);
  218|  11.4M|   const int64_t f7g5_38 = f7_2 * static_cast<int64_t>(g5_19);
  219|  11.4M|   const int64_t f7g6_19 = f7 * static_cast<int64_t>(g6_19);
  220|  11.4M|   const int64_t f7g7_38 = f7_2 * static_cast<int64_t>(g7_19);
  221|  11.4M|   const int64_t f7g8_19 = f7 * static_cast<int64_t>(g8_19);
  222|  11.4M|   const int64_t f7g9_38 = f7_2 * static_cast<int64_t>(g9_19);
  223|  11.4M|   const int64_t f8g0 = f8 * static_cast<int64_t>(g0);
  224|  11.4M|   const int64_t f8g1 = f8 * static_cast<int64_t>(g1);
  225|  11.4M|   const int64_t f8g2_19 = f8 * static_cast<int64_t>(g2_19);
  226|  11.4M|   const int64_t f8g3_19 = f8 * static_cast<int64_t>(g3_19);
  227|  11.4M|   const int64_t f8g4_19 = f8 * static_cast<int64_t>(g4_19);
  228|  11.4M|   const int64_t f8g5_19 = f8 * static_cast<int64_t>(g5_19);
  229|  11.4M|   const int64_t f8g6_19 = f8 * static_cast<int64_t>(g6_19);
  230|  11.4M|   const int64_t f8g7_19 = f8 * static_cast<int64_t>(g7_19);
  231|  11.4M|   const int64_t f8g8_19 = f8 * static_cast<int64_t>(g8_19);
  232|  11.4M|   const int64_t f8g9_19 = f8 * static_cast<int64_t>(g9_19);
  233|  11.4M|   const int64_t f9g0 = f9 * static_cast<int64_t>(g0);
  234|  11.4M|   const int64_t f9g1_38 = f9_2 * static_cast<int64_t>(g1_19);
  235|  11.4M|   const int64_t f9g2_19 = f9 * static_cast<int64_t>(g2_19);
  236|  11.4M|   const int64_t f9g3_38 = f9_2 * static_cast<int64_t>(g3_19);
  237|  11.4M|   const int64_t f9g4_19 = f9 * static_cast<int64_t>(g4_19);
  238|  11.4M|   const int64_t f9g5_38 = f9_2 * static_cast<int64_t>(g5_19);
  239|  11.4M|   const int64_t f9g6_19 = f9 * static_cast<int64_t>(g6_19);
  240|  11.4M|   const int64_t f9g7_38 = f9_2 * static_cast<int64_t>(g7_19);
  241|  11.4M|   const int64_t f9g8_19 = f9 * static_cast<int64_t>(g8_19);
  242|  11.4M|   const int64_t f9g9_38 = f9_2 * static_cast<int64_t>(g9_19);
  243|       |
  244|  11.4M|   int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 + f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;
  245|  11.4M|   int64_t h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 + f7g4_19 + f8g3_19 + f9g2_19;
  246|  11.4M|   int64_t h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 + f7g5_38 + f8g4_19 + f9g3_38;
  247|  11.4M|   int64_t h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 + f7g6_19 + f8g5_19 + f9g4_19;
  248|  11.4M|   int64_t h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 + f7g7_38 + f8g6_19 + f9g5_38;
  249|  11.4M|   int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 + f8g7_19 + f9g6_19;
  250|  11.4M|   int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 + f7g9_38 + f8g8_19 + f9g7_38;
  251|  11.4M|   int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 + f8g9_19 + f9g8_19;
  252|  11.4M|   int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 + f8g0 + f9g9_38;
  253|  11.4M|   int64_t h9 = f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;
  254|       |
  255|       |   /*
  256|       |   |h0| <= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))
  257|       |   i.e. |h0| <= 1.4*2^60; narrower ranges for h2, h4, h6, h8
  258|       |   |h1| <= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))
  259|       |   i.e. |h1| <= 1.7*2^59; narrower ranges for h3, h5, h7, h9
  260|       |   */
  261|  11.4M|   carry<26>(h0, h1);
  262|  11.4M|   carry<26>(h4, h5);
  263|       |
  264|       |   /* |h0| <= 2^25 */
  265|       |   /* |h4| <= 2^25 */
  266|       |   /* |h1| <= 1.71*2^59 */
  267|       |   /* |h5| <= 1.71*2^59 */
  268|       |
  269|  11.4M|   carry<25>(h1, h2);
  270|  11.4M|   carry<25>(h5, h6);
  271|       |
  272|       |   /* |h1| <= 2^24; from now on fits into int32 */
  273|       |   /* |h5| <= 2^24; from now on fits into int32 */
  274|       |   /* |h2| <= 1.41*2^60 */
  275|       |   /* |h6| <= 1.41*2^60 */
  276|       |
  277|  11.4M|   carry<26>(h2, h3);
  278|  11.4M|   carry<26>(h6, h7);
  279|       |   /* |h2| <= 2^25; from now on fits into int32 unchanged */
  280|       |   /* |h6| <= 2^25; from now on fits into int32 unchanged */
  281|       |   /* |h3| <= 1.71*2^59 */
  282|       |   /* |h7| <= 1.71*2^59 */
  283|       |
  284|  11.4M|   carry<25>(h3, h4);
  285|  11.4M|   carry<25>(h7, h8);
  286|       |   /* |h3| <= 2^24; from now on fits into int32 unchanged */
  287|       |   /* |h7| <= 2^24; from now on fits into int32 unchanged */
  288|       |   /* |h4| <= 1.72*2^34 */
  289|       |   /* |h8| <= 1.41*2^60 */
  290|       |
  291|  11.4M|   carry<26>(h4, h5);
  292|  11.4M|   carry<26>(h8, h9);
  293|       |   /* |h4| <= 2^25; from now on fits into int32 unchanged */
  294|       |   /* |h8| <= 2^25; from now on fits into int32 unchanged */
  295|       |   /* |h5| <= 1.01*2^24 */
  296|       |   /* |h9| <= 1.71*2^59 */
  297|       |
  298|  11.4M|   carry<25, 19>(h9, h0);
  299|       |
  300|       |   /* |h9| <= 2^24; from now on fits into int32 unchanged */
  301|       |   /* |h0| <= 1.1*2^39 */
  302|       |
  303|  11.4M|   carry<26>(h0, h1);
  304|       |   /* |h0| <= 2^25; from now on fits into int32 unchanged */
  305|       |   /* |h1| <= 1.01*2^24 */
  306|       |
  307|  11.4M|   return Ed25519_FieldElement(h0, h1, h2, h3, h4, h5, h6, h7, h8, h9);
  308|  11.4M|}
_ZNK5Botan20Ed25519_FieldElement8sqr_iterEm:
  326|  5.33M|Ed25519_FieldElement Ed25519_FieldElement::sqr_iter(size_t iter) const {
  327|  5.33M|   int32_t f0 = m_fe[0];
  328|  5.33M|   int32_t f1 = m_fe[1];
  329|  5.33M|   int32_t f2 = m_fe[2];
  330|  5.33M|   int32_t f3 = m_fe[3];
  331|  5.33M|   int32_t f4 = m_fe[4];
  332|  5.33M|   int32_t f5 = m_fe[5];
  333|  5.33M|   int32_t f6 = m_fe[6];
  334|  5.33M|   int32_t f7 = m_fe[7];
  335|  5.33M|   int32_t f8 = m_fe[8];
  336|  5.33M|   int32_t f9 = m_fe[9];
  337|       |
  338|  15.4M|   for(size_t i = 0; i != iter; ++i) {
  ------------------
  |  Branch (338:22): [True: 10.1M, False: 5.33M]
  ------------------
  339|  10.1M|      const int32_t f0_2 = 2 * f0;
  340|  10.1M|      const int32_t f1_2 = 2 * f1;
  341|  10.1M|      const int32_t f2_2 = 2 * f2;
  342|  10.1M|      const int32_t f3_2 = 2 * f3;
  343|  10.1M|      const int32_t f4_2 = 2 * f4;
  344|  10.1M|      const int32_t f5_2 = 2 * f5;
  345|  10.1M|      const int32_t f6_2 = 2 * f6;
  346|  10.1M|      const int32_t f7_2 = 2 * f7;
  347|  10.1M|      const int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */
  348|  10.1M|      const int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */
  349|  10.1M|      const int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */
  350|  10.1M|      const int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */
  351|  10.1M|      const int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */
  352|       |
  353|  10.1M|      const int64_t f0f0 = f0 * static_cast<int64_t>(f0);
  354|  10.1M|      const int64_t f0f1_2 = f0_2 * static_cast<int64_t>(f1);
  355|  10.1M|      const int64_t f0f2_2 = f0_2 * static_cast<int64_t>(f2);
  356|  10.1M|      const int64_t f0f3_2 = f0_2 * static_cast<int64_t>(f3);
  357|  10.1M|      const int64_t f0f4_2 = f0_2 * static_cast<int64_t>(f4);
  358|  10.1M|      const int64_t f0f5_2 = f0_2 * static_cast<int64_t>(f5);
  359|  10.1M|      const int64_t f0f6_2 = f0_2 * static_cast<int64_t>(f6);
  360|  10.1M|      const int64_t f0f7_2 = f0_2 * static_cast<int64_t>(f7);
  361|  10.1M|      const int64_t f0f8_2 = f0_2 * static_cast<int64_t>(f8);
  362|  10.1M|      const int64_t f0f9_2 = f0_2 * static_cast<int64_t>(f9);
  363|  10.1M|      const int64_t f1f1_2 = f1_2 * static_cast<int64_t>(f1);
  364|  10.1M|      const int64_t f1f2_2 = f1_2 * static_cast<int64_t>(f2);
  365|  10.1M|      const int64_t f1f3_4 = f1_2 * static_cast<int64_t>(f3_2);
  366|  10.1M|      const int64_t f1f4_2 = f1_2 * static_cast<int64_t>(f4);
  367|  10.1M|      const int64_t f1f5_4 = f1_2 * static_cast<int64_t>(f5_2);
  368|  10.1M|      const int64_t f1f6_2 = f1_2 * static_cast<int64_t>(f6);
  369|  10.1M|      const int64_t f1f7_4 = f1_2 * static_cast<int64_t>(f7_2);
  370|  10.1M|      const int64_t f1f8_2 = f1_2 * static_cast<int64_t>(f8);
  371|  10.1M|      const int64_t f1f9_76 = f1_2 * static_cast<int64_t>(f9_38);
  372|  10.1M|      const int64_t f2f2 = f2 * static_cast<int64_t>(f2);
  373|  10.1M|      const int64_t f2f3_2 = f2_2 * static_cast<int64_t>(f3);
  374|  10.1M|      const int64_t f2f4_2 = f2_2 * static_cast<int64_t>(f4);
  375|  10.1M|      const int64_t f2f5_2 = f2_2 * static_cast<int64_t>(f5);
  376|  10.1M|      const int64_t f2f6_2 = f2_2 * static_cast<int64_t>(f6);
  377|  10.1M|      const int64_t f2f7_2 = f2_2 * static_cast<int64_t>(f7);
  378|  10.1M|      const int64_t f2f8_38 = f2_2 * static_cast<int64_t>(f8_19);
  379|  10.1M|      const int64_t f2f9_38 = f2 * static_cast<int64_t>(f9_38);
  380|  10.1M|      const int64_t f3f3_2 = f3_2 * static_cast<int64_t>(f3);
  381|  10.1M|      const int64_t f3f4_2 = f3_2 * static_cast<int64_t>(f4);
  382|  10.1M|      const int64_t f3f5_4 = f3_2 * static_cast<int64_t>(f5_2);
  383|  10.1M|      const int64_t f3f6_2 = f3_2 * static_cast<int64_t>(f6);
  384|  10.1M|      const int64_t f3f7_76 = f3_2 * static_cast<int64_t>(f7_38);
  385|  10.1M|      const int64_t f3f8_38 = f3_2 * static_cast<int64_t>(f8_19);
  386|  10.1M|      const int64_t f3f9_76 = f3_2 * static_cast<int64_t>(f9_38);
  387|  10.1M|      const int64_t f4f4 = f4 * static_cast<int64_t>(f4);
  388|  10.1M|      const int64_t f4f5_2 = f4_2 * static_cast<int64_t>(f5);
  389|  10.1M|      const int64_t f4f6_38 = f4_2 * static_cast<int64_t>(f6_19);
  390|  10.1M|      const int64_t f4f7_38 = f4 * static_cast<int64_t>(f7_38);
  391|  10.1M|      const int64_t f4f8_38 = f4_2 * static_cast<int64_t>(f8_19);
  392|  10.1M|      const int64_t f4f9_38 = f4 * static_cast<int64_t>(f9_38);
  393|  10.1M|      const int64_t f5f5_38 = f5 * static_cast<int64_t>(f5_38);
  394|  10.1M|      const int64_t f5f6_38 = f5_2 * static_cast<int64_t>(f6_19);
  395|  10.1M|      const int64_t f5f7_76 = f5_2 * static_cast<int64_t>(f7_38);
  396|  10.1M|      const int64_t f5f8_38 = f5_2 * static_cast<int64_t>(f8_19);
  397|  10.1M|      const int64_t f5f9_76 = f5_2 * static_cast<int64_t>(f9_38);
  398|  10.1M|      const int64_t f6f6_19 = f6 * static_cast<int64_t>(f6_19);
  399|  10.1M|      const int64_t f6f7_38 = f6 * static_cast<int64_t>(f7_38);
  400|  10.1M|      const int64_t f6f8_38 = f6_2 * static_cast<int64_t>(f8_19);
  401|  10.1M|      const int64_t f6f9_38 = f6 * static_cast<int64_t>(f9_38);
  402|  10.1M|      const int64_t f7f7_38 = f7 * static_cast<int64_t>(f7_38);
  403|  10.1M|      const int64_t f7f8_38 = f7_2 * static_cast<int64_t>(f8_19);
  404|  10.1M|      const int64_t f7f9_76 = f7_2 * static_cast<int64_t>(f9_38);
  405|  10.1M|      const int64_t f8f8_19 = f8 * static_cast<int64_t>(f8_19);
  406|  10.1M|      const int64_t f8f9_38 = f8 * static_cast<int64_t>(f9_38);
  407|  10.1M|      const int64_t f9f9_38 = f9 * static_cast<int64_t>(f9_38);
  408|       |
  409|  10.1M|      int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
  410|  10.1M|      int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
  411|  10.1M|      int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
  412|  10.1M|      int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
  413|  10.1M|      int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
  414|  10.1M|      int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
  415|  10.1M|      int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
  416|  10.1M|      int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
  417|  10.1M|      int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
  418|  10.1M|      int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;
  419|       |
  420|  10.1M|      carry<26>(h0, h1);
  421|  10.1M|      carry<26>(h4, h5);
  422|  10.1M|      carry<25>(h1, h2);
  423|  10.1M|      carry<25>(h5, h6);
  424|  10.1M|      carry<26>(h2, h3);
  425|  10.1M|      carry<26>(h6, h7);
  426|       |
  427|  10.1M|      carry<25>(h3, h4);
  428|  10.1M|      carry<25>(h7, h8);
  429|       |
  430|  10.1M|      carry<26>(h4, h5);
  431|  10.1M|      carry<26>(h8, h9);
  432|  10.1M|      carry<25, 19>(h9, h0);
  433|  10.1M|      carry<26>(h0, h1);
  434|       |
  435|  10.1M|      f0 = static_cast<int32_t>(h0);
  436|  10.1M|      f1 = static_cast<int32_t>(h1);
  437|  10.1M|      f2 = static_cast<int32_t>(h2);
  438|  10.1M|      f3 = static_cast<int32_t>(h3);
  439|  10.1M|      f4 = static_cast<int32_t>(h4);
  440|  10.1M|      f5 = static_cast<int32_t>(h5);
  441|  10.1M|      f6 = static_cast<int32_t>(h6);
  442|  10.1M|      f7 = static_cast<int32_t>(h7);
  443|  10.1M|      f8 = static_cast<int32_t>(h8);
  444|  10.1M|      f9 = static_cast<int32_t>(h9);
  445|  10.1M|   }
  446|       |
  447|  5.33M|   return Ed25519_FieldElement(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9);
  448|  5.33M|}
_ZNK5Botan20Ed25519_FieldElement4sqr2Ev:
  466|  1.69M|Ed25519_FieldElement Ed25519_FieldElement::sqr2() const {
  467|  1.69M|   const int32_t f0 = m_fe[0];
  468|  1.69M|   const int32_t f1 = m_fe[1];
  469|  1.69M|   const int32_t f2 = m_fe[2];
  470|  1.69M|   const int32_t f3 = m_fe[3];
  471|  1.69M|   const int32_t f4 = m_fe[4];
  472|  1.69M|   const int32_t f5 = m_fe[5];
  473|  1.69M|   const int32_t f6 = m_fe[6];
  474|  1.69M|   const int32_t f7 = m_fe[7];
  475|  1.69M|   const int32_t f8 = m_fe[8];
  476|  1.69M|   const int32_t f9 = m_fe[9];
  477|       |
  478|  1.69M|   const int32_t f0_2 = 2 * f0;
  479|  1.69M|   const int32_t f1_2 = 2 * f1;
  480|  1.69M|   const int32_t f2_2 = 2 * f2;
  481|  1.69M|   const int32_t f3_2 = 2 * f3;
  482|  1.69M|   const int32_t f4_2 = 2 * f4;
  483|  1.69M|   const int32_t f5_2 = 2 * f5;
  484|  1.69M|   const int32_t f6_2 = 2 * f6;
  485|  1.69M|   const int32_t f7_2 = 2 * f7;
  486|  1.69M|   const int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */
  487|  1.69M|   const int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */
  488|  1.69M|   const int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */
  489|  1.69M|   const int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */
  490|  1.69M|   const int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */
  491|  1.69M|   const int64_t f0f0 = f0 * static_cast<int64_t>(f0);
  492|  1.69M|   const int64_t f0f1_2 = f0_2 * static_cast<int64_t>(f1);
  493|  1.69M|   const int64_t f0f2_2 = f0_2 * static_cast<int64_t>(f2);
  494|  1.69M|   const int64_t f0f3_2 = f0_2 * static_cast<int64_t>(f3);
  495|  1.69M|   const int64_t f0f4_2 = f0_2 * static_cast<int64_t>(f4);
  496|  1.69M|   const int64_t f0f5_2 = f0_2 * static_cast<int64_t>(f5);
  497|  1.69M|   const int64_t f0f6_2 = f0_2 * static_cast<int64_t>(f6);
  498|  1.69M|   const int64_t f0f7_2 = f0_2 * static_cast<int64_t>(f7);
  499|  1.69M|   const int64_t f0f8_2 = f0_2 * static_cast<int64_t>(f8);
  500|  1.69M|   const int64_t f0f9_2 = f0_2 * static_cast<int64_t>(f9);
  501|  1.69M|   const int64_t f1f1_2 = f1_2 * static_cast<int64_t>(f1);
  502|  1.69M|   const int64_t f1f2_2 = f1_2 * static_cast<int64_t>(f2);
  503|  1.69M|   const int64_t f1f3_4 = f1_2 * static_cast<int64_t>(f3_2);
  504|  1.69M|   const int64_t f1f4_2 = f1_2 * static_cast<int64_t>(f4);
  505|  1.69M|   const int64_t f1f5_4 = f1_2 * static_cast<int64_t>(f5_2);
  506|  1.69M|   const int64_t f1f6_2 = f1_2 * static_cast<int64_t>(f6);
  507|  1.69M|   const int64_t f1f7_4 = f1_2 * static_cast<int64_t>(f7_2);
  508|  1.69M|   const int64_t f1f8_2 = f1_2 * static_cast<int64_t>(f8);
  509|  1.69M|   const int64_t f1f9_76 = f1_2 * static_cast<int64_t>(f9_38);
  510|  1.69M|   const int64_t f2f2 = f2 * static_cast<int64_t>(f2);
  511|  1.69M|   const int64_t f2f3_2 = f2_2 * static_cast<int64_t>(f3);
  512|  1.69M|   const int64_t f2f4_2 = f2_2 * static_cast<int64_t>(f4);
  513|  1.69M|   const int64_t f2f5_2 = f2_2 * static_cast<int64_t>(f5);
  514|  1.69M|   const int64_t f2f6_2 = f2_2 * static_cast<int64_t>(f6);
  515|  1.69M|   const int64_t f2f7_2 = f2_2 * static_cast<int64_t>(f7);
  516|  1.69M|   const int64_t f2f8_38 = f2_2 * static_cast<int64_t>(f8_19);
  517|  1.69M|   const int64_t f2f9_38 = f2 * static_cast<int64_t>(f9_38);
  518|  1.69M|   const int64_t f3f3_2 = f3_2 * static_cast<int64_t>(f3);
  519|  1.69M|   const int64_t f3f4_2 = f3_2 * static_cast<int64_t>(f4);
  520|  1.69M|   const int64_t f3f5_4 = f3_2 * static_cast<int64_t>(f5_2);
  521|  1.69M|   const int64_t f3f6_2 = f3_2 * static_cast<int64_t>(f6);
  522|  1.69M|   const int64_t f3f7_76 = f3_2 * static_cast<int64_t>(f7_38);
  523|  1.69M|   const int64_t f3f8_38 = f3_2 * static_cast<int64_t>(f8_19);
  524|  1.69M|   const int64_t f3f9_76 = f3_2 * static_cast<int64_t>(f9_38);
  525|  1.69M|   const int64_t f4f4 = f4 * static_cast<int64_t>(f4);
  526|  1.69M|   const int64_t f4f5_2 = f4_2 * static_cast<int64_t>(f5);
  527|  1.69M|   const int64_t f4f6_38 = f4_2 * static_cast<int64_t>(f6_19);
  528|  1.69M|   const int64_t f4f7_38 = f4 * static_cast<int64_t>(f7_38);
  529|  1.69M|   const int64_t f4f8_38 = f4_2 * static_cast<int64_t>(f8_19);
  530|  1.69M|   const int64_t f4f9_38 = f4 * static_cast<int64_t>(f9_38);
  531|  1.69M|   const int64_t f5f5_38 = f5 * static_cast<int64_t>(f5_38);
  532|  1.69M|   const int64_t f5f6_38 = f5_2 * static_cast<int64_t>(f6_19);
  533|  1.69M|   const int64_t f5f7_76 = f5_2 * static_cast<int64_t>(f7_38);
  534|  1.69M|   const int64_t f5f8_38 = f5_2 * static_cast<int64_t>(f8_19);
  535|  1.69M|   const int64_t f5f9_76 = f5_2 * static_cast<int64_t>(f9_38);
  536|  1.69M|   const int64_t f6f6_19 = f6 * static_cast<int64_t>(f6_19);
  537|  1.69M|   const int64_t f6f7_38 = f6 * static_cast<int64_t>(f7_38);
  538|  1.69M|   const int64_t f6f8_38 = f6_2 * static_cast<int64_t>(f8_19);
  539|  1.69M|   const int64_t f6f9_38 = f6 * static_cast<int64_t>(f9_38);
  540|  1.69M|   const int64_t f7f7_38 = f7 * static_cast<int64_t>(f7_38);
  541|  1.69M|   const int64_t f7f8_38 = f7_2 * static_cast<int64_t>(f8_19);
  542|  1.69M|   const int64_t f7f9_76 = f7_2 * static_cast<int64_t>(f9_38);
  543|  1.69M|   const int64_t f8f8_19 = f8 * static_cast<int64_t>(f8_19);
  544|  1.69M|   const int64_t f8f9_38 = f8 * static_cast<int64_t>(f9_38);
  545|  1.69M|   const int64_t f9f9_38 = f9 * static_cast<int64_t>(f9_38);
  546|       |
  547|  1.69M|   int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
  548|  1.69M|   int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
  549|  1.69M|   int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
  550|  1.69M|   int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
  551|  1.69M|   int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
  552|  1.69M|   int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
  553|  1.69M|   int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
  554|  1.69M|   int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
  555|  1.69M|   int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
  556|  1.69M|   int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;
  557|       |
  558|  1.69M|   h0 += h0;
  559|  1.69M|   h1 += h1;
  560|  1.69M|   h2 += h2;
  561|  1.69M|   h3 += h3;
  562|  1.69M|   h4 += h4;
  563|  1.69M|   h5 += h5;
  564|  1.69M|   h6 += h6;
  565|  1.69M|   h7 += h7;
  566|  1.69M|   h8 += h8;
  567|  1.69M|   h9 += h9;
  568|       |
  569|  1.69M|   carry<26>(h0, h1);
  570|  1.69M|   carry<26>(h4, h5);
  571|       |
  572|  1.69M|   carry<25>(h1, h2);
  573|  1.69M|   carry<25>(h5, h6);
  574|       |
  575|  1.69M|   carry<26>(h2, h3);
  576|  1.69M|   carry<26>(h6, h7);
  577|       |
  578|  1.69M|   carry<25>(h3, h4);
  579|  1.69M|   carry<25>(h7, h8);
  580|  1.69M|   carry<26>(h4, h5);
  581|  1.69M|   carry<26>(h8, h9);
  582|  1.69M|   carry<25, 19>(h9, h0);
  583|  1.69M|   carry<26>(h0, h1);
  584|       |
  585|  1.69M|   return Ed25519_FieldElement(h0, h1, h2, h3, h4, h5, h6, h7, h8, h9);
  586|  1.69M|}
_ZN5Botan20Ed25519_FieldElement11deserializeEPKh:
  591|  6.60k|Ed25519_FieldElement Ed25519_FieldElement::deserialize(const uint8_t s[32]) {
  592|  6.60k|   int64_t h0 = load_4(s);
  593|  6.60k|   int64_t h1 = load_3(s + 4) << 6;
  594|  6.60k|   int64_t h2 = load_3(s + 7) << 5;
  595|  6.60k|   int64_t h3 = load_3(s + 10) << 3;
  596|  6.60k|   int64_t h4 = load_3(s + 13) << 2;
  597|  6.60k|   int64_t h5 = load_4(s + 16);
  598|  6.60k|   int64_t h6 = load_3(s + 20) << 7;
  599|  6.60k|   int64_t h7 = load_3(s + 23) << 5;
  600|  6.60k|   int64_t h8 = load_3(s + 26) << 4;
  601|  6.60k|   int64_t h9 = (load_3(s + 29) & 0x7fffff) << 2;
  602|       |
  603|  6.60k|   carry<25, 19>(h9, h0);
  604|  6.60k|   carry<25>(h1, h2);
  605|  6.60k|   carry<25>(h3, h4);
  606|  6.60k|   carry<25>(h5, h6);
  607|  6.60k|   carry<25>(h7, h8);
  608|       |
  609|  6.60k|   carry<26>(h0, h1);
  610|  6.60k|   carry<26>(h2, h3);
  611|  6.60k|   carry<26>(h4, h5);
  612|  6.60k|   carry<26>(h6, h7);
  613|  6.60k|   carry<26>(h8, h9);
  614|       |
  615|  6.60k|   return Ed25519_FieldElement(h0, h1, h2, h3, h4, h5, h6, h7, h8, h9);
  616|  6.60k|}
_ZNK5Botan20Ed25519_FieldElement12serialize_toENSt3__14spanIhLm32EEE:
  643|  42.9k|void Ed25519_FieldElement::serialize_to(std::span<uint8_t, 32> s) const {
  644|  42.9k|   const int64_t X25 = (1 << 25);
  645|       |
  646|  42.9k|   int32_t h0 = m_fe[0];
  647|  42.9k|   int32_t h1 = m_fe[1];
  648|  42.9k|   int32_t h2 = m_fe[2];
  649|  42.9k|   int32_t h3 = m_fe[3];
  650|  42.9k|   int32_t h4 = m_fe[4];
  651|  42.9k|   int32_t h5 = m_fe[5];
  652|  42.9k|   int32_t h6 = m_fe[6];
  653|  42.9k|   int32_t h7 = m_fe[7];
  654|  42.9k|   int32_t h8 = m_fe[8];
  655|  42.9k|   int32_t h9 = m_fe[9];
  656|  42.9k|   int32_t q;
  657|       |
  658|  42.9k|   q = (19 * h9 + ((static_cast<int32_t>(1) << 24))) >> 25;
  659|  42.9k|   q = (h0 + q) >> 26;
  660|  42.9k|   q = (h1 + q) >> 25;
  661|  42.9k|   q = (h2 + q) >> 26;
  662|  42.9k|   q = (h3 + q) >> 25;
  663|  42.9k|   q = (h4 + q) >> 26;
  664|  42.9k|   q = (h5 + q) >> 25;
  665|  42.9k|   q = (h6 + q) >> 26;
  666|  42.9k|   q = (h7 + q) >> 25;
  667|  42.9k|   q = (h8 + q) >> 26;
  668|  42.9k|   q = (h9 + q) >> 25;
  669|       |
  670|       |   /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */
  671|  42.9k|   h0 += 19 * q;
  672|       |   /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */
  673|       |
  674|  42.9k|   carry0<26>(h0, h1);
  675|  42.9k|   carry0<25>(h1, h2);
  676|  42.9k|   carry0<26>(h2, h3);
  677|  42.9k|   carry0<25>(h3, h4);
  678|  42.9k|   carry0<26>(h4, h5);
  679|  42.9k|   carry0<25>(h5, h6);
  680|  42.9k|   carry0<26>(h6, h7);
  681|  42.9k|   carry0<25>(h7, h8);
  682|  42.9k|   carry0<26>(h8, h9);
  683|       |
  684|  42.9k|   int32_t carry9 = h9 >> 25;
  685|  42.9k|   h9 -= carry9 * X25;
  686|       |   /* h10 = carry9 */
  687|       |
  688|       |   /*
  689|       |   Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
  690|       |   Have h0+...+2^230 h9 between 0 and 2^255-1;
  691|       |   evidently 2^255 h10-2^255 q = 0.
  692|       |   Goal: Output h0+...+2^230 h9.
  693|       |   */
  694|       |
  695|  42.9k|   s[0] = static_cast<uint8_t>(h0 >> 0);
  696|  42.9k|   s[1] = static_cast<uint8_t>(h0 >> 8);
  697|  42.9k|   s[2] = static_cast<uint8_t>(h0 >> 16);
  698|  42.9k|   s[3] = static_cast<uint8_t>((h0 >> 24) | (h1 << 2));
  699|  42.9k|   s[4] = static_cast<uint8_t>(h1 >> 6);
  700|  42.9k|   s[5] = static_cast<uint8_t>(h1 >> 14);
  701|  42.9k|   s[6] = static_cast<uint8_t>((h1 >> 22) | (h2 << 3));
  702|  42.9k|   s[7] = static_cast<uint8_t>(h2 >> 5);
  703|  42.9k|   s[8] = static_cast<uint8_t>(h2 >> 13);
  704|  42.9k|   s[9] = static_cast<uint8_t>((h2 >> 21) | (h3 << 5));
  705|  42.9k|   s[10] = static_cast<uint8_t>(h3 >> 3);
  706|  42.9k|   s[11] = static_cast<uint8_t>(h3 >> 11);
  707|  42.9k|   s[12] = static_cast<uint8_t>((h3 >> 19) | (h4 << 6));
  708|  42.9k|   s[13] = static_cast<uint8_t>(h4 >> 2);
  709|  42.9k|   s[14] = static_cast<uint8_t>(h4 >> 10);
  710|  42.9k|   s[15] = static_cast<uint8_t>(h4 >> 18);
  711|  42.9k|   s[16] = static_cast<uint8_t>(h5 >> 0);
  712|  42.9k|   s[17] = static_cast<uint8_t>(h5 >> 8);
  713|  42.9k|   s[18] = static_cast<uint8_t>(h5 >> 16);
  714|  42.9k|   s[19] = static_cast<uint8_t>((h5 >> 24) | (h6 << 1));
  715|  42.9k|   s[20] = static_cast<uint8_t>(h6 >> 7);
  716|  42.9k|   s[21] = static_cast<uint8_t>(h6 >> 15);
  717|  42.9k|   s[22] = static_cast<uint8_t>((h6 >> 23) | (h7 << 3));
  718|  42.9k|   s[23] = static_cast<uint8_t>(h7 >> 5);
  719|  42.9k|   s[24] = static_cast<uint8_t>(h7 >> 13);
  720|  42.9k|   s[25] = static_cast<uint8_t>((h7 >> 21) | (h8 << 4));
  721|  42.9k|   s[26] = static_cast<uint8_t>(h8 >> 4);
  722|  42.9k|   s[27] = static_cast<uint8_t>(h8 >> 12);
  723|  42.9k|   s[28] = static_cast<uint8_t>((h8 >> 20) | (h9 << 6));
  724|  42.9k|   s[29] = static_cast<uint8_t>(h9 >> 2);
  725|  42.9k|   s[30] = static_cast<uint8_t>(h9 >> 10);
  726|  42.9k|   s[31] = static_cast<uint8_t>(h9 >> 18);
  727|  42.9k|}

_ZNK5Botan17Ed25519_PublicKey9check_keyERNS_21RandomNumberGeneratorEb:
   25|  3.30k|bool Ed25519_PublicKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
   26|  3.30k|   if(m_public.size() != 32) {
  ------------------
  |  Branch (26:7): [True: 0, False: 3.30k]
  ------------------
   27|      0|      return false;
   28|      0|   }
   29|       |
   30|       |   /*
   31|       |   This function was derived from public domain code in Tor's blinding.c
   32|       |   */
   33|       |
   34|  3.30k|   const uint8_t identity_element[32] = {1};
   35|  3.30k|   if(CT::is_equal(m_public.data(), identity_element, 32).as_bool()) {
  ------------------
  |  Branch (35:7): [True: 0, False: 3.30k]
  ------------------
   36|      0|      return false;
   37|      0|   }
   38|       |
   39|       |   // The order of the Ed25519 group encoded
   40|  3.30k|   const uint8_t modm_m[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7,
   41|  3.30k|                               0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   42|  3.30k|                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
   43|       |
   44|  3.30k|   const unsigned char zero[32] = {0};
   45|       |
   46|  3.30k|   unsigned char pkcopy[32];
   47|       |
   48|  3.30k|   copy_mem(pkcopy, m_public.data(), 32);
   49|  3.30k|   pkcopy[31] ^= (1 << 7);  // flip sign
   50|       |
   51|  3.30k|   return signature_check(pkcopy, modm_m, identity_element, zero);
   52|  3.30k|}
_ZN5Botan17Ed25519_PublicKeyC1EPKhm:
   54|  3.30k|Ed25519_PublicKey::Ed25519_PublicKey(const uint8_t pub_key[], size_t pub_len) {
   55|  3.30k|   if(pub_len != 32) {
  ------------------
  |  Branch (55:7): [True: 0, False: 3.30k]
  ------------------
   56|      0|      throw Decoding_Error("Invalid length for Ed25519 key");
   57|      0|   }
   58|  3.30k|   m_public.assign(pub_key, pub_key + pub_len);
   59|  3.30k|}
_ZN5Botan18Ed25519_PrivateKeyC1ERNS_21RandomNumberGeneratorE:
  106|  3.30k|Ed25519_PrivateKey::Ed25519_PrivateKey(RandomNumberGenerator& rng) {
  107|  3.30k|   const secure_vector<uint8_t> seed = rng.random_vec(32);
  108|  3.30k|   m_public.resize(32);
  109|  3.30k|   m_private.resize(64);
  110|  3.30k|   ed25519_gen_keypair(m_public.data(), m_private.data(), seed.data());
  111|  3.30k|}
_ZNK5Botan18Ed25519_PrivateKey10public_keyEv:
  125|  3.30k|std::unique_ptr<Public_Key> Ed25519_PrivateKey::public_key() const {
  126|  3.30k|   return std::make_unique<Ed25519_PublicKey>(get_public_key());
  127|  3.30k|}
_ZNK5Botan18Ed25519_PrivateKey9check_keyERNS_21RandomNumberGeneratorEb:
  134|  3.30k|bool Ed25519_PrivateKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
  135|  3.30k|   return true;  // ???
  136|  3.30k|}
_ZNK5Botan17Ed25519_PublicKey22create_verification_opENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
  276|  3.30k|                                                                                std::string_view provider) const {
  277|  3.30k|   if(provider == "base" || provider.empty()) {
  ------------------
  |  Branch (277:7): [True: 0, False: 3.30k]
  |  Branch (277:29): [True: 3.30k, False: 0]
  ------------------
  278|  3.30k|      if(params.empty() || params == "Identity" || params == "Pure") {
  ------------------
  |  Branch (278:10): [True: 0, False: 3.30k]
  |  Branch (278:28): [True: 0, False: 3.30k]
  |  Branch (278:52): [True: 0, False: 3.30k]
  ------------------
  279|      0|         return std::make_unique<Ed25519_Pure_Verify_Operation>(*this);
  280|  3.30k|      } else if(params == "Ed25519ph") {
  ------------------
  |  Branch (280:17): [True: 3.30k, False: 0]
  ------------------
  281|  3.30k|         return std::make_unique<Ed25519_Hashed_Verify_Operation>(*this, "SHA-512", true);
  282|  3.30k|      } else {
  283|      0|         return std::make_unique<Ed25519_Hashed_Verify_Operation>(*this, params, false);
  284|      0|      }
  285|  3.30k|   }
  286|      0|   throw Provider_Not_Found(algo_name(), provider);
  287|  3.30k|}
_ZNK5Botan18Ed25519_PrivateKey19create_signature_opERNS_21RandomNumberGeneratorENSt3__117basic_string_viewIcNS3_11char_traitsIcEEEES7_:
  303|  3.30k|                                                                           std::string_view provider) const {
  304|  3.30k|   if(provider == "base" || provider.empty()) {
  ------------------
  |  Branch (304:7): [True: 0, False: 3.30k]
  |  Branch (304:29): [True: 3.30k, False: 0]
  ------------------
  305|  3.30k|      if(params.empty() || params == "Identity" || params == "Pure") {
  ------------------
  |  Branch (305:10): [True: 0, False: 3.30k]
  |  Branch (305:28): [True: 0, False: 3.30k]
  |  Branch (305:52): [True: 0, False: 3.30k]
  ------------------
  306|      0|         return std::make_unique<Ed25519_Pure_Sign_Operation>(*this);
  307|  3.30k|      } else if(params == "Ed25519ph") {
  ------------------
  |  Branch (307:17): [True: 3.30k, False: 0]
  ------------------
  308|  3.30k|         return std::make_unique<Ed25519_Hashed_Sign_Operation>(*this, "SHA-512", true);
  309|  3.30k|      } else {
  310|      0|         return std::make_unique<Ed25519_Hashed_Sign_Operation>(*this, params, false);
  311|      0|      }
  312|  3.30k|   }
  313|      0|   throw Provider_Not_Found(algo_name(), provider);
  314|  3.30k|}
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_131Ed25519_Hashed_Verify_OperationC2ERKNS_17Ed25519_PublicKeyENSt3__117basic_string_viewIcNS5_11char_traitsIcEEEEb:
  173|  3.30k|            m_key(key.get_public_key()) {
  174|  3.30k|         m_hash = HashFunction::create_or_throw(hash);
  175|       |
  176|  3.30k|         if(rfc8032) {
  ------------------
  |  Branch (176:13): [True: 3.30k, False: 0]
  ------------------
  177|  3.30k|            m_domain_sep = {0x53, 0x69, 0x67, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x6E,
  178|  3.30k|                            0x6F, 0x20, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x63, 0x6F,
  179|  3.30k|                            0x6C, 0x6C, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x01, 0x00};
  180|  3.30k|         }
  181|  3.30k|      }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_131Ed25519_Hashed_Verify_Operation6updateENSt3__14spanIKhLm18446744073709551615EEE:
  183|  3.30k|      void update(std::span<const uint8_t> msg) override { m_hash->update(msg); }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_131Ed25519_Hashed_Verify_Operation18is_valid_signatureENSt3__14spanIKhLm18446744073709551615EEE:
  185|  3.30k|      bool is_valid_signature(std::span<const uint8_t> sig) override {
  186|  3.30k|         if(sig.size() != 64) {
  ------------------
  |  Branch (186:13): [True: 0, False: 3.30k]
  ------------------
  187|      0|            return false;
  188|      0|         }
  189|  3.30k|         std::vector<uint8_t> msg_hash(m_hash->output_length());
  190|  3.30k|         m_hash->final(msg_hash.data());
  191|       |
  192|  3.30k|         BOTAN_ASSERT_EQUAL(m_key.size(), 32, "Expected size");
  ------------------
  |  |   73|  3.30k|   do {                                                                                                \
  |  |   74|  3.30k|      if((expr1) != (expr2))                                                                           \
  |  |  ------------------
  |  |  |  Branch (74:10): [True: 0, False: 3.30k]
  |  |  ------------------
  |  |   75|  3.30k|         Botan::assertion_failure(#expr1 " == " #expr2, assertion_made, __func__, __FILE__, __LINE__); \
  |  |   76|  3.30k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (76:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  193|  3.30k|         return ed25519_verify(
  194|  3.30k|            msg_hash.data(), msg_hash.size(), sig.data(), m_key.data(), m_domain_sep.data(), m_domain_sep.size());
  195|  3.30k|      }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_129Ed25519_Hashed_Sign_OperationC2ERKNS_18Ed25519_PrivateKeyENSt3__117basic_string_viewIcNS5_11char_traitsIcEEEEb:
  242|  3.30k|            m_key(key.raw_private_key_bits()) {
  243|  3.30k|         m_hash = HashFunction::create_or_throw(hash);
  244|       |
  245|  3.30k|         if(rfc8032) {
  ------------------
  |  Branch (245:13): [True: 3.30k, False: 0]
  ------------------
  246|  3.30k|            m_domain_sep = std::vector<uint8_t>{0x53, 0x69, 0x67, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x6E,
  247|  3.30k|                                                0x6F, 0x20, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x63, 0x6F,
  248|  3.30k|                                                0x6C, 0x6C, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x01, 0x00};
  249|  3.30k|         }
  250|  3.30k|      }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_129Ed25519_Hashed_Sign_Operation6updateENSt3__14spanIKhLm18446744073709551615EEE:
  254|  3.30k|      void update(std::span<const uint8_t> msg) override { m_hash->update(msg); }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_129Ed25519_Hashed_Sign_Operation4signERNS_21RandomNumberGeneratorE:
  256|  3.30k|      std::vector<uint8_t> sign(RandomNumberGenerator& /*rng*/) override {
  257|  3.30k|         std::vector<uint8_t> sig(64);
  258|  3.30k|         std::vector<uint8_t> msg_hash(m_hash->output_length());
  259|  3.30k|         m_hash->final(msg_hash.data());
  260|  3.30k|         ed25519_sign(
  261|  3.30k|            sig.data(), msg_hash.data(), msg_hash.size(), m_key.data(), m_domain_sep.data(), m_domain_sep.size());
  262|  3.30k|         return sig;
  263|  3.30k|      }

_ZN5Botan21ed25519_basepoint_mulENSt3__14spanIhLm32EEEPKh:
 1858|  6.60k|void ed25519_basepoint_mul(std::span<uint8_t, 32> out, const uint8_t a[32]) {
 1859|  6.60k|   std::array<int8_t, 64> e;
 1860|       |
 1861|  6.60k|   CT::poison(a, 32);
 1862|       |
 1863|       |   // each e[i] is between 0 and 15 except e[63] which is between 0 and 7
 1864|   217k|   for(size_t i = 0; i != 32; ++i) {
  ------------------
  |  Branch (1864:22): [True: 211k, False: 6.60k]
  ------------------
 1865|   211k|      e[2 * i + 0] = (a[i] >> 0) & 0x0F;
 1866|   211k|      e[2 * i + 1] = (a[i] >> 4) & 0x0F;
 1867|   211k|   }
 1868|       |
 1869|  6.60k|   int8_t carry = 0;
 1870|   422k|   for(size_t i = 0; i < 63; ++i) {
  ------------------
  |  Branch (1870:22): [True: 415k, False: 6.60k]
  ------------------
 1871|   415k|      e[i] += carry;
 1872|   415k|      carry = e[i] + 8;
 1873|   415k|      carry >>= 4;
 1874|   415k|      e[i] -= carry << 4;
 1875|   415k|   }
 1876|  6.60k|   e[63] += carry;
 1877|       |   /* each e[i] is between -8 and 8 */
 1878|       |
 1879|  6.60k|   auto h = Ed25519_Point_Extended::identity();
 1880|   217k|   for(size_t i = 1; i < 64; i += 2) {
  ------------------
  |  Branch (1880:22): [True: 211k, False: 6.60k]
  ------------------
 1881|   211k|      h = Ed25519_Point_Extended::from(h + select(B_precomp[i / 2], e[i]));
 1882|   211k|   }
 1883|       |
 1884|  6.60k|   auto s = Ed25519_Point_Projective::from(h.dbl());
 1885|  6.60k|   s = Ed25519_Point_Projective::from(s.dbl());
 1886|  6.60k|   s = Ed25519_Point_Projective::from(s.dbl());
 1887|  6.60k|   h = Ed25519_Point_Extended::from(s.dbl());
 1888|       |
 1889|   217k|   for(size_t i = 0; i != 64; i += 2) {
  ------------------
  |  Branch (1889:22): [True: 211k, False: 6.60k]
  ------------------
 1890|   211k|      h = Ed25519_Point_Extended::from(h + select(B_precomp[i / 2], e[i]));
 1891|   211k|   }
 1892|       |
 1893|  6.60k|   h.serialize_to(out);
 1894|       |
 1895|  6.60k|   CT::unpoison(a, 32);
 1896|  6.60k|   CT::unpoison(out);
 1897|  6.60k|}
_ZN5Botan15signature_checkENSt3__14spanIKhLm32EEEPS2_S4_S4_:
 1899|  6.60k|bool signature_check(std::span<const uint8_t, 32> pk, const uint8_t h[32], const uint8_t r[32], const uint8_t s[32]) {
 1900|  6.60k|   if(auto A = frombytes_negate_vartime(pk)) {
  ------------------
  |  Branch (1900:12): [True: 6.60k, False: 0]
  ------------------
 1901|  6.60k|      std::array<uint8_t, 32> rcheck;
 1902|  6.60k|      ge_double_scalarmult_vartime(rcheck, h, *A, s);
 1903|  6.60k|      return CT::is_equal(rcheck.data(), r, 32).as_bool();
 1904|  6.60k|   }
 1905|      0|   return false;
 1906|  6.60k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_122Ed25519_Point_Extended8identityEv:
  109|  13.2k|      static constexpr Ed25519_Point_Extended identity() {
  110|  13.2k|         Ed25519_Point_Extended h;
  111|  13.2k|         h.X = Ed25519_FieldElement::zero();
  112|  13.2k|         h.Y = Ed25519_FieldElement::one();
  113|  13.2k|         h.Z = Ed25519_FieldElement::one();
  114|  13.2k|         h.T = Ed25519_FieldElement::zero();
  115|  13.2k|         return h;
  116|  13.2k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_122Ed25519_Point_Extended4fromERKNS0_23Ed25519_Point_CompletedE:
  129|   837k|      static Ed25519_Point_Extended from(const Ed25519_Point_Completed& p) {
  130|   837k|         Ed25519_Point_Extended r;
  131|   837k|         r.X = p.X * p.T;
  132|   837k|         r.Y = p.Y * p.Z;
  133|   837k|         r.Z = p.Z * p.T;
  134|   837k|         r.T = p.X * p.Y;
  135|   837k|         return r;
  136|   837k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_1plERKNS0_22Ed25519_Point_ExtendedERKNS0_19Ed25519_Point_NielsE:
  220|   493k|inline Ed25519_Point_Completed operator+(const Ed25519_Point_Extended& p, const Ed25519_Point_Niels& q) {
  221|   493k|   Ed25519_Point_Completed r;
  222|   493k|   r.X = p.Y + p.X;        // YpX1 = Y1+X1
  223|   493k|   r.Y = p.Y - p.X;        // YmX1 = Y1-X1
  224|   493k|   r.Z = r.X * q.yplusx;   // A = YpX1*ypx2
  225|   493k|   r.Y = r.Y * q.yminusx;  // B = YmX1*ymx2
  226|   493k|   r.T = q.xy2d * p.T;     // C = xy2d2*T1
  227|   493k|   auto t0 = p.Z + p.Z;    // D = 2*Z1
  228|   493k|   r.X = r.Z - r.Y;        // X3 = A-B
  229|   493k|   r.Y = r.Z + r.Y;        // Y3 = A+B
  230|   493k|   r.Z = t0 + r.T;         // Z3 = D+C
  231|   493k|   r.T = t0 - r.T;         // T3 = D-C
  232|   493k|   return r;
  233|   493k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_16selectEPKNS0_19Ed25519_Point_NielsEa:
  450|   422k|Ed25519_Point_Niels select(const Ed25519_Point_Niels base[8], int8_t b) {
  451|   422k|   const uint8_t bnegative = negative(b);
  452|   422k|   const uint8_t babs = b - ((-static_cast<int>(bnegative) & b) * 2);
  453|   422k|   const uint32_t neg_mask = equal32(bnegative, 1);
  454|       |
  455|   422k|   const uint32_t mask1 = equal32(babs, 1);
  456|   422k|   const uint32_t mask2 = equal32(babs, 2);
  457|   422k|   const uint32_t mask3 = equal32(babs, 3);
  458|   422k|   const uint32_t mask4 = equal32(babs, 4);
  459|   422k|   const uint32_t mask5 = equal32(babs, 5);
  460|   422k|   const uint32_t mask6 = equal32(babs, 6);
  461|   422k|   const uint32_t mask7 = equal32(babs, 7);
  462|   422k|   const uint32_t mask8 = equal32(babs, 8);
  463|       |
  464|   422k|   auto t = Ed25519_Point_Niels::identity();
  465|       |
  466|  4.64M|   for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (466:22): [True: 4.22M, False: 422k]
  ------------------
  467|  4.22M|      t.yplusx[i] = t.yplusx[i] ^ ((t.yplusx[i] ^ base[0].yplusx[i]) & mask1) ^
  468|  4.22M|                    ((t.yplusx[i] ^ base[1].yplusx[i]) & mask2) ^ ((t.yplusx[i] ^ base[2].yplusx[i]) & mask3) ^
  469|  4.22M|                    ((t.yplusx[i] ^ base[3].yplusx[i]) & mask4) ^ ((t.yplusx[i] ^ base[4].yplusx[i]) & mask5) ^
  470|  4.22M|                    ((t.yplusx[i] ^ base[5].yplusx[i]) & mask6) ^ ((t.yplusx[i] ^ base[6].yplusx[i]) & mask7) ^
  471|  4.22M|                    ((t.yplusx[i] ^ base[7].yplusx[i]) & mask8);
  472|       |
  473|  4.22M|      t.yminusx[i] = t.yminusx[i] ^ ((t.yminusx[i] ^ base[0].yminusx[i]) & mask1) ^
  474|  4.22M|                     ((t.yminusx[i] ^ base[1].yminusx[i]) & mask2) ^ ((t.yminusx[i] ^ base[2].yminusx[i]) & mask3) ^
  475|  4.22M|                     ((t.yminusx[i] ^ base[3].yminusx[i]) & mask4) ^ ((t.yminusx[i] ^ base[4].yminusx[i]) & mask5) ^
  476|  4.22M|                     ((t.yminusx[i] ^ base[5].yminusx[i]) & mask6) ^ ((t.yminusx[i] ^ base[6].yminusx[i]) & mask7) ^
  477|  4.22M|                     ((t.yminusx[i] ^ base[7].yminusx[i]) & mask8);
  478|       |
  479|  4.22M|      t.xy2d[i] = t.xy2d[i] ^ ((t.xy2d[i] ^ base[0].xy2d[i]) & mask1) ^ ((t.xy2d[i] ^ base[1].xy2d[i]) & mask2) ^
  480|  4.22M|                  ((t.xy2d[i] ^ base[2].xy2d[i]) & mask3) ^ ((t.xy2d[i] ^ base[3].xy2d[i]) & mask4) ^
  481|  4.22M|                  ((t.xy2d[i] ^ base[4].xy2d[i]) & mask5) ^ ((t.xy2d[i] ^ base[5].xy2d[i]) & mask6) ^
  482|  4.22M|                  ((t.xy2d[i] ^ base[6].xy2d[i]) & mask7) ^ ((t.xy2d[i] ^ base[7].xy2d[i]) & mask8);
  483|  4.22M|   }
  484|       |
  485|   422k|   auto minus_xy2d = -t.xy2d;
  486|       |
  487|       |   // If negative have to swap yminusx and yplusx
  488|  4.64M|   for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (488:22): [True: 4.22M, False: 422k]
  ------------------
  489|  4.22M|      int32_t t_yplusx = t.yplusx[i] ^ ((t.yplusx[i] ^ t.yminusx[i]) & neg_mask);
  490|  4.22M|      int32_t t_yminusx = t.yminusx[i] ^ ((t.yminusx[i] ^ t.yplusx[i]) & neg_mask);
  491|       |
  492|  4.22M|      t.yplusx[i] = t_yplusx;
  493|  4.22M|      t.yminusx[i] = t_yminusx;
  494|  4.22M|      t.xy2d[i] = t.xy2d[i] ^ ((t.xy2d[i] ^ minus_xy2d[i]) & neg_mask);
  495|  4.22M|   }
  496|       |
  497|   422k|   return t;
  498|   422k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_18negativeEa:
  446|   422k|inline uint8_t negative(int8_t b) {
  447|   422k|   return static_cast<uint8_t>(b) >> 7;
  448|   422k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_17equal32Ehh:
  442|  3.80M|inline uint32_t equal32(uint8_t b, uint8_t c) {
  443|  3.80M|   return CT::Mask<uint32_t>::is_equal(b, c).value();
  444|  3.80M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_119Ed25519_Point_Niels8identityEv:
  160|   422k|      static constexpr Ed25519_Point_Niels identity() {
  161|   422k|         Ed25519_Point_Niels h;
  162|   422k|         h.yplusx = Ed25519_FieldElement::one();
  163|   422k|         h.yminusx = Ed25519_FieldElement::one();
  164|   422k|         h.xy2d = Ed25519_FieldElement::zero();
  165|   422k|         return h;
  166|   422k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_124Ed25519_Point_Projective4fromERKNS0_23Ed25519_Point_CompletedE:
   56|  1.68M|      static Ed25519_Point_Projective from(const Ed25519_Point_Completed& p) {
   57|  1.68M|         Ed25519_Point_Projective r;
   58|  1.68M|         r.X = p.X * p.T;
   59|  1.68M|         r.Y = p.Y * p.Z;
   60|  1.68M|         r.Z = p.Z * p.T;
   61|  1.68M|         return r;
   62|  1.68M|      }
ge.cpp:_ZNK5Botan12_GLOBAL__N_122Ed25519_Point_Extended3dblEv:
  118|  13.2k|      Ed25519_Point_Completed dbl() const {
  119|  13.2k|         Ed25519_Point_Projective q;
  120|  13.2k|         q.X = X;
  121|  13.2k|         q.Y = Y;
  122|  13.2k|         q.Z = Z;
  123|  13.2k|         return q.dbl();
  124|  13.2k|      }
ge.cpp:_ZNK5Botan12_GLOBAL__N_124Ed25519_Point_Projective3dblEv:
   83|  1.69M|Ed25519_Point_Completed Ed25519_Point_Projective::dbl() const {
   84|  1.69M|   Ed25519_Point_Completed r;
   85|  1.69M|   r.X = X.sqr();        // XX=X1^2
   86|  1.69M|   r.Z = Y.sqr();        // YY=Y1^2
   87|  1.69M|   r.T = Z.sqr2();       // B=2*Z1^2
   88|  1.69M|   r.Y = X + Y;          // A=X1+Y1
   89|  1.69M|   auto t0 = r.Y.sqr();  // AA=A^2
   90|  1.69M|   r.Y = r.Z + r.X;      // Y3=YY+XX
   91|  1.69M|   r.Z = r.Z - r.X;      // Z3=YY-XX
   92|  1.69M|   r.X = t0 - r.Y;       // X3=AA-Y3
   93|  1.69M|   r.T = r.T - r.Z;      // T3=B-Z3
   94|  1.69M|   return r;
   95|  1.69M|}
ge.cpp:_ZNK5Botan12_GLOBAL__N_122Ed25519_Point_Extended12serialize_toENSt3__14spanIhLm32EEE:
  138|  6.60k|      void serialize_to(std::span<uint8_t, 32> out) const {
  139|  6.60k|         auto recip = this->Z.invert();
  140|  6.60k|         auto x = this->X * recip;
  141|  6.60k|         auto y = this->Y * recip;
  142|  6.60k|         y.serialize_to(out);
  143|  6.60k|         out[31] ^= x.is_negative() ? 0x80 : 0x00;
  ------------------
  |  Branch (143:21): [True: 3.31k, False: 3.28k]
  ------------------
  144|  6.60k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_124frombytes_negate_vartimeENSt3__14spanIKhLm32EEE:
  302|  6.60k|std::optional<Ed25519_Point_Extended> frombytes_negate_vartime(std::span<const uint8_t, 32> s) {
  303|  6.60k|   static constexpr Ed25519_FieldElement d = {
  304|  6.60k|      -10913610, 13857413, -15372611, 6949391, 114729, -8787816, -6275908, -3247719, -18696448, -12055116};
  305|  6.60k|   static constexpr Ed25519_FieldElement sqrtm1 = {
  306|  6.60k|      -32595792, -7943725, 9377950, 3500415, 12389472, -272473, -25146209, -2005654, 326686, 11406482};
  307|       |
  308|  6.60k|   auto h = Ed25519_Point_Extended::identity();
  309|  6.60k|   h.Y = Ed25519_FieldElement::deserialize(s.data());
  310|  6.60k|   h.Z = Ed25519_FieldElement::one();
  311|  6.60k|   auto u = h.Y.sqr();
  312|  6.60k|   auto v = u * d;
  313|  6.60k|   u = u - h.Z; /* u = y^2-1 */
  314|  6.60k|   v = v + h.Z; /* v = dy^2+1 */
  315|       |
  316|  6.60k|   auto v3 = v.sqr() * v;
  317|  6.60k|   h.X = v3.sqr();
  318|  6.60k|   h.X = h.X * v;
  319|  6.60k|   h.X = h.X * u; /* x = uv^7 */
  320|       |
  321|  6.60k|   h.X = h.X.pow_22523();
  322|  6.60k|   h.X = h.X * v3;
  323|  6.60k|   h.X = h.X * u; /* x = uv^3(uv^7)^((q-5)/8) */
  324|       |
  325|  6.60k|   auto vxx = h.X.sqr();
  326|  6.60k|   vxx = vxx * v;
  327|  6.60k|   auto check = vxx - u; /* vx^2-u */
  328|  6.60k|   if(!check.is_zero()) {
  ------------------
  |  Branch (328:7): [True: 3.37k, False: 3.22k]
  ------------------
  329|  3.37k|      check = vxx + u; /* vx^2+u */
  330|  3.37k|      if(!check.is_zero()) {
  ------------------
  |  Branch (330:10): [True: 0, False: 3.37k]
  ------------------
  331|      0|         return {};
  332|      0|      }
  333|  3.37k|      h.X = h.X * sqrtm1;
  334|  3.37k|   }
  335|       |
  336|  6.60k|   if(h.X.is_negative() == bool(s[31] >> 7)) {
  ------------------
  |  Branch (336:7): [True: 3.30k, False: 3.30k]
  ------------------
  337|  3.30k|      h.X = -h.X;
  338|  3.30k|   }
  339|       |
  340|  6.60k|   h.T = h.X * h.Y;
  341|  6.60k|   return h;
  342|  6.60k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_128ge_double_scalarmult_vartimeENSt3__14spanIhLm32EEEPKhRKNS0_22Ed25519_Point_ExtendedES5_:
  354|  6.60k|                                  const uint8_t* b) {
  355|  6.60k|   static constexpr Ed25519_Point_Niels Bi[8] = {
  356|  6.60k|      {
  357|  6.60k|         {25967493, -14356035, 29566456, 3660896, -12694345, 4014787, 27544626, -11754271, -6079156, 2047605},
  358|  6.60k|         {-12545711, 934262, -2722910, 3049990, -727428, 9406986, 12720692, 5043384, 19500929, -15469378},
  359|  6.60k|         {-8738181, 4489570, 9688441, -14785194, 10184609, -12363380, 29287919, 11864899, -24514362, -4438546},
  360|  6.60k|      },
  361|  6.60k|      {
  362|  6.60k|         {15636291, -9688557, 24204773, -7912398, 616977, -16685262, 27787600, -14772189, 28944400, -1550024},
  363|  6.60k|         {16568933, 4717097, -11556148, -1102322, 15682896, -11807043, 16354577, -11775962, 7689662, 11199574},
  364|  6.60k|         {30464156, -5976125, -11779434, -15670865, 23220365, 15915852, 7512774, 10017326, -17749093, -9920357},
  365|  6.60k|      },
  366|  6.60k|      {
  367|  6.60k|         {10861363, 11473154, 27284546, 1981175, -30064349, 12577861, 32867885, 14515107, -15438304, 10819380},
  368|  6.60k|         {4708026, 6336745, 20377586, 9066809, -11272109, 6594696, -25653668, 12483688, -12668491, 5581306},
  369|  6.60k|         {19563160, 16186464, -29386857, 4097519, 10237984, -4348115, 28542350, 13850243, -23678021, -15815942},
  370|  6.60k|      },
  371|  6.60k|      {
  372|  6.60k|         {5153746, 9909285, 1723747, -2777874, 30523605, 5516873, 19480852, 5230134, -23952439, -15175766},
  373|  6.60k|         {-30269007, -3463509, 7665486, 10083793, 28475525, 1649722, 20654025, 16520125, 30598449, 7715701},
  374|  6.60k|         {28881845, 14381568, 9657904, 3680757, -20181635, 7843316, -31400660, 1370708, 29794553, -1409300},
  375|  6.60k|      },
  376|  6.60k|      {
  377|  6.60k|         {-22518993, -6692182, 14201702, -8745502, -23510406, 8844726, 18474211, -1361450, -13062696, 13821877},
  378|  6.60k|         {-6455177, -7839871, 3374702, -4740862, -27098617, -10571707, 31655028, -7212327, 18853322, -14220951},
  379|  6.60k|         {4566830, -12963868, -28974889, -12240689, -7602672, -2830569, -8514358, -10431137, 2207753, -3209784},
  380|  6.60k|      },
  381|  6.60k|      {
  382|  6.60k|         {-25154831, -4185821, 29681144, 7868801, -6854661, -9423865, -12437364, -663000, -31111463, -16132436},
  383|  6.60k|         {25576264, -2703214, 7349804, -11814844, 16472782, 9300885, 3844789, 15725684, 171356, 6466918},
  384|  6.60k|         {23103977, 13316479, 9739013, -16149481, 817875, -15038942, 8965339, -14088058, -30714912, 16193877},
  385|  6.60k|      },
  386|  6.60k|      {
  387|  6.60k|         {-33521811, 3180713, -2394130, 14003687, -16903474, -16270840, 17238398, 4729455, -18074513, 9256800},
  388|  6.60k|         {-25182317, -4174131, 32336398, 5036987, -21236817, 11360617, 22616405, 9761698, -19827198, 630305},
  389|  6.60k|         {-13720693, 2639453, -24237460, -7406481, 9494427, -5774029, -6554551, -15960994, -2449256, -14291300},
  390|  6.60k|      },
  391|  6.60k|      {
  392|  6.60k|         {-3151181, -5046075, 9282714, 6866145, -31907062, -863023, -18940575, 15033784, 25105118, -7894876},
  393|  6.60k|         {-24326370, 15950226, -31801215, -14592823, -11662737, -5090925, 1573892, -2625887, 2198790, -15804619},
  394|  6.60k|         {-3099351, 10324967, -2241613, 7453183, -5446979, -2735503, -13812022, -16236442, -32461234, -12290683},
  395|  6.60k|      },
  396|  6.60k|   };
  397|       |
  398|  6.60k|   std::array<int8_t, 256> aslide;
  399|  6.60k|   std::array<int8_t, 256> bslide;
  400|       |
  401|  6.60k|   slide(aslide, a);
  402|  6.60k|   slide(bslide, b);
  403|       |
  404|  6.60k|   Ed25519_Point_Cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */
  405|  6.60k|   Ai[0] = Ed25519_Point_Cached::from(A);
  406|  6.60k|   const auto A2 = Ed25519_Point_Extended::from(A.dbl());
  407|       |
  408|  52.8k|   for(size_t i = 1; i != 8; ++i) {
  ------------------
  |  Branch (408:22): [True: 46.2k, False: 6.60k]
  ------------------
  409|  46.2k|      Ai[i] = Ed25519_Point_Cached::from(A2 + Ai[i - 1]);
  410|  46.2k|   }
  411|       |
  412|  6.60k|   auto r = Ed25519_Point_Projective::identity();
  413|       |
  414|  6.60k|   int i;
  415|  31.5k|   for(i = 255; i >= 0; --i) {
  ------------------
  |  Branch (415:17): [True: 31.5k, False: 0]
  ------------------
  416|  31.5k|      if(aslide[i] || bslide[i]) {
  ------------------
  |  Branch (416:10): [True: 5.20k, False: 26.3k]
  |  Branch (416:23): [True: 1.39k, False: 24.9k]
  ------------------
  417|  6.60k|         break;
  418|  6.60k|      }
  419|  31.5k|   }
  420|       |
  421|  1.67M|   for(; i >= 0; --i) {
  ------------------
  |  Branch (421:10): [True: 1.66M, False: 6.60k]
  ------------------
  422|  1.66M|      auto t = r.dbl();
  423|       |
  424|  1.66M|      if(aslide[i] > 0) {
  ------------------
  |  Branch (424:10): [True: 107k, False: 1.55M]
  ------------------
  425|   107k|         t = Ed25519_Point_Extended::from(t) + Ai[aslide[i] >> 1];
  426|  1.55M|      } else if(aslide[i] < 0) {
  ------------------
  |  Branch (426:17): [True: 108k, False: 1.44M]
  ------------------
  427|   108k|         t = Ed25519_Point_Extended::from(t) - Ai[(-aslide[i]) >> 1];
  428|   108k|      }
  429|       |
  430|  1.66M|      if(bslide[i] > 0) {
  ------------------
  |  Branch (430:10): [True: 71.3k, False: 1.59M]
  ------------------
  431|  71.3k|         t = Ed25519_Point_Extended::from(t) + Bi[bslide[i] >> 1];
  432|  1.59M|      } else if(bslide[i] < 0) {
  ------------------
  |  Branch (432:17): [True: 68.6k, False: 1.52M]
  ------------------
  433|  68.6k|         t = Ed25519_Point_Extended::from(t) - Bi[(-bslide[i]) >> 1];
  434|  68.6k|      }
  435|       |
  436|  1.66M|      r = Ed25519_Point_Projective::from(t);
  437|  1.66M|   }
  438|       |
  439|  6.60k|   r.serialize_to(std::span<uint8_t, 32>{out});
  440|  6.60k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_15slideENSt3__14spanIaLm256EEEPKh:
  272|  13.2k|void slide(std::span<int8_t, 256> r, const uint8_t* a) {
  273|  3.39M|   for(size_t i = 0; i < 256; ++i) {
  ------------------
  |  Branch (273:22): [True: 3.37M, False: 13.2k]
  ------------------
  274|  3.37M|      r[i] = 1 & (a[i >> 3] >> (i & 7));
  275|  3.37M|   }
  276|       |
  277|  3.39M|   for(size_t i = 0; i < 256; ++i) {
  ------------------
  |  Branch (277:22): [True: 3.37M, False: 13.2k]
  ------------------
  278|  3.37M|      if(r[i]) {
  ------------------
  |  Branch (278:10): [True: 355k, False: 3.02M]
  ------------------
  279|  2.04M|         for(size_t b = 1; b <= 6 && i + b < 256; ++b) {
  ------------------
  |  Branch (279:28): [True: 1.94M, False: 91.0k]
  |  Branch (279:38): [True: 1.94M, False: 6.54k]
  ------------------
  280|  1.94M|            if(r[i + b]) {
  ------------------
  |  Branch (280:16): [True: 982k, False: 959k]
  ------------------
  281|   982k|               if(r[i] + (r[i + b] << b) <= 15) {
  ------------------
  |  Branch (281:19): [True: 547k, False: 435k]
  ------------------
  282|   547k|                  r[i] += r[i + b] << b;
  283|   547k|                  r[i + b] = 0;
  284|   547k|               } else if(r[i] - (r[i + b] << b) >= -15) {
  ------------------
  |  Branch (284:26): [True: 176k, False: 258k]
  ------------------
  285|   176k|                  r[i] -= r[i + b] << b;
  286|   522k|                  for(size_t k = i + b; k < 256; ++k) {
  ------------------
  |  Branch (286:41): [True: 522k, False: 0]
  ------------------
  287|   522k|                     if(!r[k]) {
  ------------------
  |  Branch (287:25): [True: 176k, False: 345k]
  ------------------
  288|   176k|                        r[k] = 1;
  289|   176k|                        break;
  290|   176k|                     }
  291|   345k|                     r[k] = 0;
  292|   345k|                  }
  293|   258k|               } else {
  294|   258k|                  break;
  295|   258k|               }
  296|   982k|            }
  297|  1.94M|         }
  298|   355k|      }
  299|  3.37M|   }
  300|  13.2k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_120Ed25519_Point_Cached4fromERKNS0_22Ed25519_Point_ExtendedE:
  179|  52.8k|      static Ed25519_Point_Cached from(const Ed25519_Point_Extended& p) {
  180|  52.8k|         static constexpr Ed25519_FieldElement d2 = {
  181|  52.8k|            -21827239, -5839606, -30745221, 13898782, 229458, 15978800, -12551817, -6495438, 29715968, 9444199};
  182|  52.8k|         Ed25519_Point_Cached r;
  183|  52.8k|         r.YplusX = p.Y + p.X;
  184|  52.8k|         r.YminusX = p.Y - p.X;
  185|  52.8k|         r.Z = p.Z;
  186|  52.8k|         r.T2d = p.T * d2;
  187|  52.8k|         return r;
  188|  52.8k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_120Ed25519_Point_Cached4fromERKNS0_23Ed25519_Point_CompletedE:
  193|  46.2k|      static Ed25519_Point_Cached from(const Ed25519_Point_Completed& p) {
  194|  46.2k|         return Ed25519_Point_Cached::from(Ed25519_Point_Extended::from(p));
  195|  46.2k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_1plERKNS0_22Ed25519_Point_ExtendedERKNS0_20Ed25519_Point_CachedE:
  201|   153k|inline Ed25519_Point_Completed operator+(const Ed25519_Point_Extended& p, const Ed25519_Point_Cached& q) {
  202|   153k|   Ed25519_Point_Completed r;
  203|   153k|   r.X = p.Y + p.X;        // YpX1 = Y1+X1
  204|   153k|   r.Y = p.Y - p.X;        // YmX1 = Y1-X1
  205|   153k|   r.Z = r.X * q.YplusX;   // A = YpX1*YpX2
  206|   153k|   r.Y = r.Y * q.YminusX;  // B = YmX1*YmX2
  207|   153k|   r.T = q.T2d * p.T;      // C = T2d2*T1
  208|   153k|   r.X = p.Z * q.Z;        // ZZ = Z1*Z2
  209|   153k|   auto t0 = r.X + r.X;    // D = 2*ZZ
  210|   153k|   r.X = r.Z - r.Y;        // X3 = A-B
  211|   153k|   r.Y = r.Z + r.Y;        // Y3 = A+B
  212|   153k|   r.Z = t0 + r.T;         // Z3 = D+C
  213|   153k|   r.T = t0 - r.T;         // T3 = D-C
  214|   153k|   return r;
  215|   153k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_124Ed25519_Point_Projective8identityEv:
   64|  6.60k|      static constexpr Ed25519_Point_Projective identity() {
   65|  6.60k|         Ed25519_Point_Projective h;
   66|  6.60k|         h.X = Ed25519_FieldElement::zero();
   67|  6.60k|         h.Y = Ed25519_FieldElement::one();
   68|  6.60k|         h.Z = Ed25519_FieldElement::one();
   69|  6.60k|         return h;
   70|  6.60k|      }
ge.cpp:_ZN5Botan12_GLOBAL__N_1miERKNS0_22Ed25519_Point_ExtendedERKNS0_20Ed25519_Point_CachedE:
  256|   108k|inline Ed25519_Point_Completed operator-(const Ed25519_Point_Extended& p, const Ed25519_Point_Cached& q) {
  257|   108k|   Ed25519_Point_Completed r;
  258|   108k|   r.X = p.Y + p.X;        // YpX1 = Y1+X1
  259|   108k|   r.Y = p.Y - p.X;        // YmX1 = Y1-X1
  260|   108k|   r.Z = r.X * q.YminusX;  // A = YpX1*YmX2
  261|   108k|   r.Y = r.Y * q.YplusX;   // B = YmX1*YpX2
  262|   108k|   r.T = q.T2d * p.T;      // C = T2d2*T1
  263|   108k|   r.X = p.Z * q.Z;        // ZZ = Z1*Z2
  264|   108k|   auto t0 = r.X + r.X;    // D = 2*ZZ
  265|   108k|   r.X = r.Z - r.Y;        // X3 = A-B
  266|   108k|   r.Y = r.Z + r.Y;        // Y3 = A+B
  267|   108k|   r.Z = t0 - r.T;         // Z3 = D-C
  268|   108k|   r.T = t0 + r.T;         // T3 = D+C
  269|   108k|   return r;
  270|   108k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_1miERKNS0_22Ed25519_Point_ExtendedERKNS0_19Ed25519_Point_NielsE:
  238|  68.6k|inline Ed25519_Point_Completed operator-(const Ed25519_Point_Extended& p, const Ed25519_Point_Niels& q) {
  239|  68.6k|   Ed25519_Point_Completed r;
  240|  68.6k|   r.X = p.Y + p.X;        // YpX1 = Y1+X1
  241|  68.6k|   r.Y = p.Y - p.X;        // YmX1 = Y1-X1
  242|  68.6k|   r.Z = r.X * q.yminusx;  // A = YpX1*ymx2
  243|  68.6k|   r.Y = r.Y * q.yplusx;   // B = YmX1*ypx2
  244|  68.6k|   r.T = q.xy2d * p.T;     // C = xy2d2*T1
  245|  68.6k|   auto t0 = p.Z + p.Z;    // D = 2*Z1
  246|  68.6k|   r.X = r.Z - r.Y;        // X3 = A-B
  247|  68.6k|   r.Y = r.Z + r.Y;        // Y3 = A+B
  248|  68.6k|   r.Z = t0 - r.T;         // Z3 = D-C
  249|  68.6k|   r.T = t0 + r.T;         // T3 = D+C
  250|  68.6k|   return r;
  251|  68.6k|}
ge.cpp:_ZNK5Botan12_GLOBAL__N_124Ed25519_Point_Projective12serialize_toENSt3__14spanIhLm32EEE:
   72|  6.60k|      void serialize_to(std::span<uint8_t, 32> s) const {
   73|  6.60k|         auto recip = this->Z.invert();
   74|  6.60k|         auto x = this->X * recip;
   75|  6.60k|         auto y = this->Y * recip;
   76|  6.60k|         y.serialize_to(s);
   77|  6.60k|         s[31] ^= x.is_negative() ? 0x80 : 0x00;
  ------------------
  |  Branch (77:19): [True: 1.63k, False: 4.96k]
  ------------------
   78|  6.60k|      }

_ZN5Botan9sc_muladdEPhPKhS2_S2_:
   26|  3.30k|void sc_muladd(uint8_t* s, const uint8_t* a, const uint8_t* b, const uint8_t* c) {
   27|  3.30k|   const int32_t MASK = 0x1fffff;
   28|       |
   29|  3.30k|   const int64_t a0 = MASK & load_3(a);
   30|  3.30k|   const int64_t a1 = MASK & (load_4(a + 2) >> 5);
   31|  3.30k|   const int64_t a2 = MASK & (load_3(a + 5) >> 2);
   32|  3.30k|   const int64_t a3 = MASK & (load_4(a + 7) >> 7);
   33|  3.30k|   const int64_t a4 = MASK & (load_4(a + 10) >> 4);
   34|  3.30k|   const int64_t a5 = MASK & (load_3(a + 13) >> 1);
   35|  3.30k|   const int64_t a6 = MASK & (load_4(a + 15) >> 6);
   36|  3.30k|   const int64_t a7 = MASK & (load_3(a + 18) >> 3);
   37|  3.30k|   const int64_t a8 = MASK & load_3(a + 21);
   38|  3.30k|   const int64_t a9 = MASK & (load_4(a + 23) >> 5);
   39|  3.30k|   const int64_t a10 = MASK & (load_3(a + 26) >> 2);
   40|  3.30k|   const int64_t a11 = (load_4(a + 28) >> 7);
   41|  3.30k|   const int64_t b0 = MASK & load_3(b);
   42|  3.30k|   const int64_t b1 = MASK & (load_4(b + 2) >> 5);
   43|  3.30k|   const int64_t b2 = MASK & (load_3(b + 5) >> 2);
   44|  3.30k|   const int64_t b3 = MASK & (load_4(b + 7) >> 7);
   45|  3.30k|   const int64_t b4 = MASK & (load_4(b + 10) >> 4);
   46|  3.30k|   const int64_t b5 = MASK & (load_3(b + 13) >> 1);
   47|  3.30k|   const int64_t b6 = MASK & (load_4(b + 15) >> 6);
   48|  3.30k|   const int64_t b7 = MASK & (load_3(b + 18) >> 3);
   49|  3.30k|   const int64_t b8 = MASK & load_3(b + 21);
   50|  3.30k|   const int64_t b9 = MASK & (load_4(b + 23) >> 5);
   51|  3.30k|   const int64_t b10 = MASK & (load_3(b + 26) >> 2);
   52|  3.30k|   const int64_t b11 = (load_4(b + 28) >> 7);
   53|  3.30k|   const int64_t c0 = MASK & load_3(c);
   54|  3.30k|   const int64_t c1 = MASK & (load_4(c + 2) >> 5);
   55|  3.30k|   const int64_t c2 = MASK & (load_3(c + 5) >> 2);
   56|  3.30k|   const int64_t c3 = MASK & (load_4(c + 7) >> 7);
   57|  3.30k|   const int64_t c4 = MASK & (load_4(c + 10) >> 4);
   58|  3.30k|   const int64_t c5 = MASK & (load_3(c + 13) >> 1);
   59|  3.30k|   const int64_t c6 = MASK & (load_4(c + 15) >> 6);
   60|  3.30k|   const int64_t c7 = MASK & (load_3(c + 18) >> 3);
   61|  3.30k|   const int64_t c8 = MASK & load_3(c + 21);
   62|  3.30k|   const int64_t c9 = MASK & (load_4(c + 23) >> 5);
   63|  3.30k|   const int64_t c10 = MASK & (load_3(c + 26) >> 2);
   64|  3.30k|   const int64_t c11 = (load_4(c + 28) >> 7);
   65|       |
   66|  3.30k|   int64_t s0 = c0 + a0 * b0;
   67|  3.30k|   int64_t s1 = c1 + a0 * b1 + a1 * b0;
   68|  3.30k|   int64_t s2 = c2 + a0 * b2 + a1 * b1 + a2 * b0;
   69|  3.30k|   int64_t s3 = c3 + a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;
   70|  3.30k|   int64_t s4 = c4 + a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;
   71|  3.30k|   int64_t s5 = c5 + a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;
   72|  3.30k|   int64_t s6 = c6 + a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;
   73|  3.30k|   int64_t s7 = c7 + a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 + a6 * b1 + a7 * b0;
   74|  3.30k|   int64_t s8 = c8 + a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 + a6 * b2 + a7 * b1 + a8 * b0;
   75|  3.30k|   int64_t s9 = c9 + a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 + a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;
   76|  3.30k|   int64_t s10 = c10 + a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 + a6 * b4 + a7 * b3 + a8 * b2 +
   77|  3.30k|                 a9 * b1 + a10 * b0;
   78|  3.30k|   int64_t s11 = c11 + a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 + a6 * b5 + a7 * b4 + a8 * b3 +
   79|  3.30k|                 a9 * b2 + a10 * b1 + a11 * b0;
   80|  3.30k|   int64_t s12 =
   81|  3.30k|      a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 + a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;
   82|  3.30k|   int64_t s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 + a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;
   83|  3.30k|   int64_t s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 + a9 * b5 + a10 * b4 + a11 * b3;
   84|  3.30k|   int64_t s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 + a10 * b5 + a11 * b4;
   85|  3.30k|   int64_t s16 = a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;
   86|  3.30k|   int64_t s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;
   87|  3.30k|   int64_t s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;
   88|  3.30k|   int64_t s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;
   89|  3.30k|   int64_t s20 = a9 * b11 + a10 * b10 + a11 * b9;
   90|  3.30k|   int64_t s21 = a10 * b11 + a11 * b10;
   91|  3.30k|   int64_t s22 = a11 * b11;
   92|  3.30k|   int64_t s23 = 0;
   93|       |
   94|  3.30k|   carry<21>(s0, s1);
   95|  3.30k|   carry<21>(s2, s3);
   96|  3.30k|   carry<21>(s4, s5);
   97|  3.30k|   carry<21>(s6, s7);
   98|  3.30k|   carry<21>(s8, s9);
   99|  3.30k|   carry<21>(s10, s11);
  100|  3.30k|   carry<21>(s12, s13);
  101|  3.30k|   carry<21>(s14, s15);
  102|  3.30k|   carry<21>(s16, s17);
  103|  3.30k|   carry<21>(s18, s19);
  104|  3.30k|   carry<21>(s20, s21);
  105|  3.30k|   carry<21>(s22, s23);
  106|       |
  107|  3.30k|   carry<21>(s1, s2);
  108|  3.30k|   carry<21>(s3, s4);
  109|  3.30k|   carry<21>(s5, s6);
  110|  3.30k|   carry<21>(s7, s8);
  111|  3.30k|   carry<21>(s9, s10);
  112|  3.30k|   carry<21>(s11, s12);
  113|  3.30k|   carry<21>(s13, s14);
  114|  3.30k|   carry<21>(s15, s16);
  115|  3.30k|   carry<21>(s17, s18);
  116|  3.30k|   carry<21>(s19, s20);
  117|  3.30k|   carry<21>(s21, s22);
  118|       |
  119|  3.30k|   redc_mul(s11, s12, s13, s14, s15, s16, s23);
  120|  3.30k|   redc_mul(s10, s11, s12, s13, s14, s15, s22);
  121|  3.30k|   redc_mul(s9, s10, s11, s12, s13, s14, s21);
  122|  3.30k|   redc_mul(s8, s9, s10, s11, s12, s13, s20);
  123|  3.30k|   redc_mul(s7, s8, s9, s10, s11, s12, s19);
  124|  3.30k|   redc_mul(s6, s7, s8, s9, s10, s11, s18);
  125|       |
  126|  3.30k|   carry<21>(s6, s7);
  127|  3.30k|   carry<21>(s8, s9);
  128|  3.30k|   carry<21>(s10, s11);
  129|  3.30k|   carry<21>(s12, s13);
  130|  3.30k|   carry<21>(s14, s15);
  131|  3.30k|   carry<21>(s16, s17);
  132|       |
  133|  3.30k|   carry<21>(s7, s8);
  134|  3.30k|   carry<21>(s9, s10);
  135|  3.30k|   carry<21>(s11, s12);
  136|  3.30k|   carry<21>(s13, s14);
  137|  3.30k|   carry<21>(s15, s16);
  138|       |
  139|  3.30k|   redc_mul(s5, s6, s7, s8, s9, s10, s17);
  140|  3.30k|   redc_mul(s4, s5, s6, s7, s8, s9, s16);
  141|  3.30k|   redc_mul(s3, s4, s5, s6, s7, s8, s15);
  142|  3.30k|   redc_mul(s2, s3, s4, s5, s6, s7, s14);
  143|  3.30k|   redc_mul(s1, s2, s3, s4, s5, s6, s13);
  144|  3.30k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  145|       |
  146|  3.30k|   carry<21>(s0, s1);
  147|  3.30k|   carry<21>(s2, s3);
  148|  3.30k|   carry<21>(s4, s5);
  149|  3.30k|   carry<21>(s6, s7);
  150|  3.30k|   carry<21>(s8, s9);
  151|  3.30k|   carry<21>(s10, s11);
  152|       |
  153|  3.30k|   carry<21>(s1, s2);
  154|  3.30k|   carry<21>(s3, s4);
  155|  3.30k|   carry<21>(s5, s6);
  156|  3.30k|   carry<21>(s7, s8);
  157|  3.30k|   carry<21>(s9, s10);
  158|  3.30k|   carry<21>(s11, s12);
  159|       |
  160|  3.30k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  161|       |
  162|  3.30k|   carry0<21>(s0, s1);
  163|  3.30k|   carry0<21>(s1, s2);
  164|  3.30k|   carry0<21>(s2, s3);
  165|  3.30k|   carry0<21>(s3, s4);
  166|  3.30k|   carry0<21>(s4, s5);
  167|  3.30k|   carry0<21>(s5, s6);
  168|  3.30k|   carry0<21>(s6, s7);
  169|  3.30k|   carry0<21>(s7, s8);
  170|  3.30k|   carry0<21>(s8, s9);
  171|  3.30k|   carry0<21>(s9, s10);
  172|  3.30k|   carry0<21>(s10, s11);
  173|  3.30k|   carry0<21>(s11, s12);
  174|       |
  175|  3.30k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  176|       |
  177|  3.30k|   carry0<21>(s0, s1);
  178|  3.30k|   carry0<21>(s1, s2);
  179|  3.30k|   carry0<21>(s2, s3);
  180|  3.30k|   carry0<21>(s3, s4);
  181|  3.30k|   carry0<21>(s4, s5);
  182|  3.30k|   carry0<21>(s5, s6);
  183|  3.30k|   carry0<21>(s6, s7);
  184|  3.30k|   carry0<21>(s7, s8);
  185|  3.30k|   carry0<21>(s8, s9);
  186|  3.30k|   carry0<21>(s9, s10);
  187|  3.30k|   carry0<21>(s10, s11);
  188|       |
  189|  3.30k|   s[0] = static_cast<uint8_t>(s0 >> 0);
  190|  3.30k|   s[1] = static_cast<uint8_t>(s0 >> 8);
  191|  3.30k|   s[2] = static_cast<uint8_t>((s0 >> 16) | (s1 << 5));
  192|  3.30k|   s[3] = static_cast<uint8_t>(s1 >> 3);
  193|  3.30k|   s[4] = static_cast<uint8_t>(s1 >> 11);
  194|  3.30k|   s[5] = static_cast<uint8_t>((s1 >> 19) | (s2 << 2));
  195|  3.30k|   s[6] = static_cast<uint8_t>(s2 >> 6);
  196|  3.30k|   s[7] = static_cast<uint8_t>((s2 >> 14) | (s3 << 7));
  197|  3.30k|   s[8] = static_cast<uint8_t>(s3 >> 1);
  198|  3.30k|   s[9] = static_cast<uint8_t>(s3 >> 9);
  199|  3.30k|   s[10] = static_cast<uint8_t>((s3 >> 17) | (s4 << 4));
  200|  3.30k|   s[11] = static_cast<uint8_t>(s4 >> 4);
  201|  3.30k|   s[12] = static_cast<uint8_t>(s4 >> 12);
  202|  3.30k|   s[13] = static_cast<uint8_t>((s4 >> 20) | (s5 << 1));
  203|  3.30k|   s[14] = static_cast<uint8_t>(s5 >> 7);
  204|  3.30k|   s[15] = static_cast<uint8_t>((s5 >> 15) | (s6 << 6));
  205|  3.30k|   s[16] = static_cast<uint8_t>(s6 >> 2);
  206|  3.30k|   s[17] = static_cast<uint8_t>(s6 >> 10);
  207|  3.30k|   s[18] = static_cast<uint8_t>((s6 >> 18) | (s7 << 3));
  208|  3.30k|   s[19] = static_cast<uint8_t>(s7 >> 5);
  209|  3.30k|   s[20] = static_cast<uint8_t>(s7 >> 13);
  210|  3.30k|   s[21] = static_cast<uint8_t>(s8 >> 0);
  211|  3.30k|   s[22] = static_cast<uint8_t>(s8 >> 8);
  212|  3.30k|   s[23] = static_cast<uint8_t>((s8 >> 16) | (s9 << 5));
  213|  3.30k|   s[24] = static_cast<uint8_t>(s9 >> 3);
  214|  3.30k|   s[25] = static_cast<uint8_t>(s9 >> 11);
  215|  3.30k|   s[26] = static_cast<uint8_t>((s9 >> 19) | (s10 << 2));
  216|  3.30k|   s[27] = static_cast<uint8_t>(s10 >> 6);
  217|  3.30k|   s[28] = static_cast<uint8_t>((s10 >> 14) | (s11 << 7));
  218|  3.30k|   s[29] = static_cast<uint8_t>(s11 >> 1);
  219|  3.30k|   s[30] = static_cast<uint8_t>(s11 >> 9);
  220|  3.30k|   s[31] = static_cast<uint8_t>(s11 >> 17);
  221|  3.30k|}

_ZN5Botan9sc_reduceEPh:
   25|  9.90k|void sc_reduce(uint8_t* s) {
   26|  9.90k|   const uint32_t MASK = 0x1fffff;
   27|       |
   28|  9.90k|   int64_t s0 = MASK & load_3(s);
   29|  9.90k|   int64_t s1 = MASK & (load_4(s + 2) >> 5);
   30|  9.90k|   int64_t s2 = MASK & (load_3(s + 5) >> 2);
   31|  9.90k|   int64_t s3 = MASK & (load_4(s + 7) >> 7);
   32|  9.90k|   int64_t s4 = MASK & (load_4(s + 10) >> 4);
   33|  9.90k|   int64_t s5 = MASK & (load_3(s + 13) >> 1);
   34|  9.90k|   int64_t s6 = MASK & (load_4(s + 15) >> 6);
   35|  9.90k|   int64_t s7 = MASK & (load_3(s + 18) >> 3);
   36|  9.90k|   int64_t s8 = MASK & load_3(s + 21);
   37|  9.90k|   int64_t s9 = MASK & (load_4(s + 23) >> 5);
   38|  9.90k|   int64_t s10 = MASK & (load_3(s + 26) >> 2);
   39|  9.90k|   int64_t s11 = MASK & (load_4(s + 28) >> 7);
   40|  9.90k|   int64_t s12 = MASK & (load_4(s + 31) >> 4);
   41|  9.90k|   int64_t s13 = MASK & (load_3(s + 34) >> 1);
   42|  9.90k|   int64_t s14 = MASK & (load_4(s + 36) >> 6);
   43|  9.90k|   int64_t s15 = MASK & (load_3(s + 39) >> 3);
   44|  9.90k|   int64_t s16 = MASK & load_3(s + 42);
   45|  9.90k|   int64_t s17 = MASK & (load_4(s + 44) >> 5);
   46|  9.90k|   int64_t s18 = MASK & (load_3(s + 47) >> 2);
   47|  9.90k|   int64_t s19 = MASK & (load_4(s + 49) >> 7);
   48|  9.90k|   int64_t s20 = MASK & (load_4(s + 52) >> 4);
   49|  9.90k|   int64_t s21 = MASK & (load_3(s + 55) >> 1);
   50|  9.90k|   int64_t s22 = MASK & (load_4(s + 57) >> 6);
   51|  9.90k|   int64_t s23 = (load_4(s + 60) >> 3);
   52|       |
   53|  9.90k|   redc_mul(s11, s12, s13, s14, s15, s16, s23);
   54|  9.90k|   redc_mul(s10, s11, s12, s13, s14, s15, s22);
   55|  9.90k|   redc_mul(s9, s10, s11, s12, s13, s14, s21);
   56|  9.90k|   redc_mul(s8, s9, s10, s11, s12, s13, s20);
   57|  9.90k|   redc_mul(s7, s8, s9, s10, s11, s12, s19);
   58|  9.90k|   redc_mul(s6, s7, s8, s9, s10, s11, s18);
   59|       |
   60|  9.90k|   carry<21>(s6, s7);
   61|  9.90k|   carry<21>(s8, s9);
   62|  9.90k|   carry<21>(s10, s11);
   63|  9.90k|   carry<21>(s12, s13);
   64|  9.90k|   carry<21>(s14, s15);
   65|  9.90k|   carry<21>(s16, s17);
   66|       |
   67|  9.90k|   carry<21>(s7, s8);
   68|  9.90k|   carry<21>(s9, s10);
   69|  9.90k|   carry<21>(s11, s12);
   70|  9.90k|   carry<21>(s13, s14);
   71|  9.90k|   carry<21>(s15, s16);
   72|       |
   73|  9.90k|   redc_mul(s5, s6, s7, s8, s9, s10, s17);
   74|  9.90k|   redc_mul(s4, s5, s6, s7, s8, s9, s16);
   75|  9.90k|   redc_mul(s3, s4, s5, s6, s7, s8, s15);
   76|  9.90k|   redc_mul(s2, s3, s4, s5, s6, s7, s14);
   77|  9.90k|   redc_mul(s1, s2, s3, s4, s5, s6, s13);
   78|  9.90k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
   79|       |
   80|  9.90k|   carry<21>(s0, s1);
   81|  9.90k|   carry<21>(s2, s3);
   82|  9.90k|   carry<21>(s4, s5);
   83|  9.90k|   carry<21>(s6, s7);
   84|  9.90k|   carry<21>(s8, s9);
   85|  9.90k|   carry<21>(s10, s11);
   86|       |
   87|  9.90k|   carry<21>(s1, s2);
   88|  9.90k|   carry<21>(s3, s4);
   89|  9.90k|   carry<21>(s5, s6);
   90|  9.90k|   carry<21>(s7, s8);
   91|  9.90k|   carry<21>(s9, s10);
   92|  9.90k|   carry<21>(s11, s12);
   93|       |
   94|  9.90k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
   95|       |
   96|  9.90k|   carry0<21>(s0, s1);
   97|  9.90k|   carry0<21>(s1, s2);
   98|  9.90k|   carry0<21>(s2, s3);
   99|  9.90k|   carry0<21>(s3, s4);
  100|  9.90k|   carry0<21>(s4, s5);
  101|  9.90k|   carry0<21>(s5, s6);
  102|  9.90k|   carry0<21>(s6, s7);
  103|  9.90k|   carry0<21>(s7, s8);
  104|  9.90k|   carry0<21>(s8, s9);
  105|  9.90k|   carry0<21>(s9, s10);
  106|  9.90k|   carry0<21>(s10, s11);
  107|  9.90k|   carry0<21>(s11, s12);
  108|       |
  109|  9.90k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  110|       |
  111|  9.90k|   carry0<21>(s0, s1);
  112|  9.90k|   carry0<21>(s1, s2);
  113|  9.90k|   carry0<21>(s2, s3);
  114|  9.90k|   carry0<21>(s3, s4);
  115|  9.90k|   carry0<21>(s4, s5);
  116|  9.90k|   carry0<21>(s5, s6);
  117|  9.90k|   carry0<21>(s6, s7);
  118|  9.90k|   carry0<21>(s7, s8);
  119|  9.90k|   carry0<21>(s8, s9);
  120|  9.90k|   carry0<21>(s9, s10);
  121|  9.90k|   carry0<21>(s10, s11);
  122|  9.90k|   carry0<21>(s11, s12);
  123|       |
  124|  9.90k|   s[0] = static_cast<uint8_t>(s0 >> 0);
  125|  9.90k|   s[1] = static_cast<uint8_t>(s0 >> 8);
  126|  9.90k|   s[2] = static_cast<uint8_t>((s0 >> 16) | (s1 << 5));
  127|  9.90k|   s[3] = static_cast<uint8_t>(s1 >> 3);
  128|  9.90k|   s[4] = static_cast<uint8_t>(s1 >> 11);
  129|  9.90k|   s[5] = static_cast<uint8_t>((s1 >> 19) | (s2 << 2));
  130|  9.90k|   s[6] = static_cast<uint8_t>(s2 >> 6);
  131|  9.90k|   s[7] = static_cast<uint8_t>((s2 >> 14) | (s3 << 7));
  132|  9.90k|   s[8] = static_cast<uint8_t>(s3 >> 1);
  133|  9.90k|   s[9] = static_cast<uint8_t>(s3 >> 9);
  134|  9.90k|   s[10] = static_cast<uint8_t>((s3 >> 17) | (s4 << 4));
  135|  9.90k|   s[11] = static_cast<uint8_t>(s4 >> 4);
  136|  9.90k|   s[12] = static_cast<uint8_t>(s4 >> 12);
  137|  9.90k|   s[13] = static_cast<uint8_t>((s4 >> 20) | (s5 << 1));
  138|  9.90k|   s[14] = static_cast<uint8_t>(s5 >> 7);
  139|  9.90k|   s[15] = static_cast<uint8_t>((s5 >> 15) | (s6 << 6));
  140|  9.90k|   s[16] = static_cast<uint8_t>(s6 >> 2);
  141|  9.90k|   s[17] = static_cast<uint8_t>(s6 >> 10);
  142|  9.90k|   s[18] = static_cast<uint8_t>((s6 >> 18) | (s7 << 3));
  143|  9.90k|   s[19] = static_cast<uint8_t>(s7 >> 5);
  144|  9.90k|   s[20] = static_cast<uint8_t>(s7 >> 13);
  145|  9.90k|   s[21] = static_cast<uint8_t>(s8 >> 0);
  146|  9.90k|   s[22] = static_cast<uint8_t>(s8 >> 8);
  147|  9.90k|   s[23] = static_cast<uint8_t>((s8 >> 16) | (s9 << 5));
  148|  9.90k|   s[24] = static_cast<uint8_t>(s9 >> 3);
  149|  9.90k|   s[25] = static_cast<uint8_t>(s9 >> 11);
  150|  9.90k|   s[26] = static_cast<uint8_t>((s9 >> 19) | (s10 << 2));
  151|  9.90k|   s[27] = static_cast<uint8_t>(s10 >> 6);
  152|  9.90k|   s[28] = static_cast<uint8_t>((s10 >> 14) | (s11 << 7));
  153|  9.90k|   s[29] = static_cast<uint8_t>(s11 >> 1);
  154|  9.90k|   s[30] = static_cast<uint8_t>(s11 >> 9);
  155|  9.90k|   s[31] = static_cast<uint8_t>(s11 >> 17);
  156|  9.90k|}

_ZN5Botan9PK_SignerC2ERKNS_11Private_KeyERNS_21RandomNumberGeneratorENSt3__117basic_string_viewIcNS6_11char_traitsIcEEEENS_16Signature_FormatESA_:
  258|  3.30k|      m_sig_format(format), m_sig_element_size(key._signature_element_size_for_DER_encoding()) {
  259|  3.30k|   if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (259:7): [True: 0, False: 3.30k]
  ------------------
  260|      0|      BOTAN_ARG_CHECK(m_sig_element_size.has_value(), "This key does not support DER signatures");
  ------------------
  |  |   34|      0|   do {                                                          \
  |  |   35|      0|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (35:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   37|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (37:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  261|      0|   }
  262|       |
  263|  3.30k|   m_op = key.create_signature_op(rng, emsa, provider);
  264|  3.30k|   if(!m_op) {
  ------------------
  |  Branch (264:7): [True: 0, False: 3.30k]
  ------------------
  265|      0|      throw Invalid_Argument(fmt("Key type {} does not support signature generation", key.algo_name()));
  266|      0|   }
  267|  3.30k|}
_ZN5Botan9PK_SignerD2Ev:
  277|  3.30k|PK_Signer::~PK_Signer() = default;
_ZN5Botan9PK_Signer6updateENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
  282|  3.30k|void PK_Signer::update(std::string_view in) {
  283|  3.30k|   this->update(cast_char_ptr_to_uint8(in.data()), in.size());
  284|  3.30k|}
_ZN5Botan9PK_Signer6updateEPKhm:
  286|  3.30k|void PK_Signer::update(const uint8_t in[], size_t length) {
  287|  3.30k|   m_op->update({in, length});
  288|  3.30k|}
_ZN5Botan9PK_Signer9signatureERNS_21RandomNumberGeneratorE:
  355|  3.30k|std::vector<uint8_t> PK_Signer::signature(RandomNumberGenerator& rng) {
  356|  3.30k|   std::vector<uint8_t> sig = m_op->sign(rng);
  357|       |
  358|  3.30k|   if(m_sig_format == Signature_Format::Standard) {
  ------------------
  |  Branch (358:7): [True: 3.30k, False: 0]
  ------------------
  359|  3.30k|      return sig;
  360|  3.30k|   } else if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (360:14): [True: 0, False: 0]
  ------------------
  361|      0|      BOTAN_ASSERT_NOMSG(m_sig_element_size.has_value());
  ------------------
  |  |   64|      0|   do {                                                                     \
  |  |   65|      0|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   66|      0|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  362|      0|      return der_encode_signature(sig, 2, m_sig_element_size.value());
  363|      0|   } else {
  364|      0|      throw Internal_Error("PK_Signer: Invalid signature format enum");
  365|      0|   }
  366|  3.30k|}
_ZN5Botan11PK_VerifierC2ERKNS_10Public_KeyENSt3__117basic_string_viewIcNS4_11char_traitsIcEEEENS_16Signature_FormatES8_:
  371|  3.30k|                         std::string_view provider) {
  372|  3.30k|   m_op = key.create_verification_op(emsa, provider);
  373|  3.30k|   if(!m_op) {
  ------------------
  |  Branch (373:7): [True: 0, False: 3.30k]
  ------------------
  374|      0|      throw Invalid_Argument(fmt("Key type {} does not support signature verification", key.algo_name()));
  375|      0|   }
  376|       |
  377|  3.30k|   m_sig_format = format;
  378|  3.30k|   m_sig_element_size = key._signature_element_size_for_DER_encoding();
  379|       |
  380|  3.30k|   if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (380:7): [True: 0, False: 3.30k]
  ------------------
  381|      0|      BOTAN_ARG_CHECK(m_sig_element_size.has_value(), "This key does not support DER signatures");
  ------------------
  |  |   34|      0|   do {                                                          \
  |  |   35|      0|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (35:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   36|      0|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   37|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (37:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  382|      0|   }
  383|  3.30k|}
_ZN5Botan11PK_VerifierD2Ev:
  397|  3.30k|PK_Verifier::~PK_Verifier() = default;
_ZN5Botan11PK_Verifier6updateENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
  418|  3.30k|void PK_Verifier::update(std::string_view in) {
  419|  3.30k|   this->update(cast_char_ptr_to_uint8(in.data()), in.size());
  420|  3.30k|}
_ZN5Botan11PK_Verifier6updateEPKhm:
  422|  3.30k|void PK_Verifier::update(const uint8_t in[], size_t length) {
  423|  3.30k|   m_op->update({in, length});
  424|  3.30k|}
_ZN5Botan11PK_Verifier15check_signatureEPKhm:
  458|  3.30k|bool PK_Verifier::check_signature(const uint8_t sig[], size_t length) {
  459|  3.30k|   try {
  460|  3.30k|      if(m_sig_format == Signature_Format::Standard) {
  ------------------
  |  Branch (460:10): [True: 3.30k, False: 0]
  ------------------
  461|  3.30k|         return m_op->is_valid_signature({sig, length});
  462|  3.30k|      } else if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (462:17): [True: 0, False: 0]
  ------------------
  463|      0|         bool decoding_success = false;
  464|      0|         std::vector<uint8_t> real_sig;
  465|       |
  466|      0|         BOTAN_ASSERT_NOMSG(m_sig_element_size.has_value());
  ------------------
  |  |   64|      0|   do {                                                                     \
  |  |   65|      0|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   66|      0|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  467|       |
  468|      0|         try {
  469|      0|            real_sig = decode_der_signature(sig, length, 2, m_sig_element_size.value());
  470|      0|            decoding_success = true;
  471|      0|         } catch(Decoding_Error&) {}
  472|       |
  473|      0|         bool accept = m_op->is_valid_signature(real_sig);
  474|       |
  475|      0|         return accept && decoding_success;
  ------------------
  |  Branch (475:17): [True: 0, False: 0]
  |  Branch (475:27): [True: 0, False: 0]
  ------------------
  476|      0|      } else {
  477|      0|         throw Internal_Error("PK_Verifier: Invalid signature format enum");
  478|      0|      }
  479|  3.30k|   } catch(Invalid_Argument&) {
  480|      0|      return false;
  481|      0|   } catch(Decoding_Error&) {
  482|      0|      return false;
  483|      0|   } catch(Encoding_Error&) {
  484|      0|      return false;
  485|      0|   }
  486|  3.30k|}

_ZN5Botan16curve25519_donnaEPhPKhS2_:
  454|  6.60k|void curve25519_donna(uint8_t mypublic[32], const uint8_t secret[32], const uint8_t basepoint[32]) {
  455|  6.60k|   CT::poison(secret, 32);
  456|  6.60k|   CT::poison(basepoint, 32);
  457|       |
  458|  6.60k|   uint64_t bp[5], x[5], z[5], zmone[5];
  459|  6.60k|   uint8_t e[32];
  460|       |
  461|  6.60k|   copy_mem(e, secret, 32);
  462|  6.60k|   e[0] &= 248;
  463|  6.60k|   e[31] &= 127;
  464|  6.60k|   e[31] |= 64;
  465|       |
  466|  6.60k|   fexpand(bp, basepoint);
  467|  6.60k|   cmult(x, z, e, bp);
  468|  6.60k|   crecip(zmone, z);
  469|  6.60k|   fmul(z, x, zmone);
  470|  6.60k|   fcontract(mypublic, z);
  471|       |
  472|  6.60k|   CT::unpoison(secret, 32);
  473|  6.60k|   CT::unpoison(basepoint, 32);
  474|  6.60k|   CT::unpoison(mypublic, 32);
  475|  6.60k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_17fexpandEPmPKh:
  218|  6.60k|inline void fexpand(uint64_t* out, const uint8_t* in) {
  219|  6.60k|   out[0] = load_le<uint64_t>(in, 0) & MASK_63;
  220|  6.60k|   out[1] = (load_le<uint64_t>(in + 6, 0) >> 3) & MASK_63;
  221|  6.60k|   out[2] = (load_le<uint64_t>(in + 12, 0) >> 6) & MASK_63;
  222|  6.60k|   out[3] = (load_le<uint64_t>(in + 19, 0) >> 1) & MASK_63;
  223|  6.60k|   out[4] = (load_le<uint64_t>(in + 24, 0) >> 12) & MASK_63;
  224|  6.60k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_15cmultEPmS1_PKhPKm:
  365|  6.60k|void cmult(uint64_t resultx[5], uint64_t resultz[5], const uint8_t n[32], const uint64_t q[5]) {
  366|  6.60k|   uint64_t a[5] = {0};  // nqpqx
  367|  6.60k|   uint64_t b[5] = {1};  // npqpz
  368|  6.60k|   uint64_t c[5] = {1};  // nqx
  369|  6.60k|   uint64_t d[5] = {0};  // nqz
  370|  6.60k|   uint64_t e[5] = {0};  // npqqx2
  371|  6.60k|   uint64_t f[5] = {1};  // npqqz2
  372|  6.60k|   uint64_t g[5] = {0};  // nqx2
  373|  6.60k|   uint64_t h[5] = {1};  // nqz2
  374|       |
  375|  6.60k|   copy_mem(a, q, 5);
  376|       |
  377|   217k|   for(size_t i = 0; i < 32; ++i) {
  ------------------
  |  Branch (377:22): [True: 211k, False: 6.60k]
  ------------------
  378|   211k|      const uint64_t si = n[31 - i];
  379|   211k|      const auto bit0 = CT::Mask<uint64_t>::expand_bit(si, 7);
  380|   211k|      const auto bit1 = CT::Mask<uint64_t>::expand_bit(si, 6);
  381|   211k|      const auto bit2 = CT::Mask<uint64_t>::expand_bit(si, 5);
  382|   211k|      const auto bit3 = CT::Mask<uint64_t>::expand_bit(si, 4);
  383|   211k|      const auto bit4 = CT::Mask<uint64_t>::expand_bit(si, 3);
  384|   211k|      const auto bit5 = CT::Mask<uint64_t>::expand_bit(si, 2);
  385|   211k|      const auto bit6 = CT::Mask<uint64_t>::expand_bit(si, 1);
  386|   211k|      const auto bit7 = CT::Mask<uint64_t>::expand_bit(si, 0);
  387|       |
  388|   211k|      swap_conditional(c, a, d, b, bit0);
  389|   211k|      fmonty(g, h, e, f, c, d, a, b, q);
  390|       |
  391|   211k|      swap_conditional(g, e, h, f, bit0 ^ bit1);
  392|   211k|      fmonty(c, d, a, b, g, h, e, f, q);
  393|       |
  394|   211k|      swap_conditional(c, a, d, b, bit1 ^ bit2);
  395|   211k|      fmonty(g, h, e, f, c, d, a, b, q);
  396|       |
  397|   211k|      swap_conditional(g, e, h, f, bit2 ^ bit3);
  398|   211k|      fmonty(c, d, a, b, g, h, e, f, q);
  399|       |
  400|   211k|      swap_conditional(c, a, d, b, bit3 ^ bit4);
  401|   211k|      fmonty(g, h, e, f, c, d, a, b, q);
  402|       |
  403|   211k|      swap_conditional(g, e, h, f, bit4 ^ bit5);
  404|   211k|      fmonty(c, d, a, b, g, h, e, f, q);
  405|       |
  406|   211k|      swap_conditional(c, a, d, b, bit5 ^ bit6);
  407|   211k|      fmonty(g, h, e, f, c, d, a, b, q);
  408|       |
  409|   211k|      swap_conditional(g, e, h, f, bit6 ^ bit7);
  410|   211k|      fmonty(c, d, a, b, g, h, e, f, q);
  411|       |
  412|   211k|      swap_conditional(c, a, d, b, bit7);
  413|   211k|   }
  414|       |
  415|  6.60k|   copy_mem(resultx, c, 5);
  416|  6.60k|   copy_mem(resultz, d, 5);
  417|  6.60k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_116swap_conditionalEPmS1_S1_S1_NS_2CT4MaskImEE:
  347|  1.90M|inline void swap_conditional(uint64_t a[5], uint64_t b[5], uint64_t c[5], uint64_t d[5], CT::Mask<uint64_t> swap) {
  348|  11.4M|   for(size_t i = 0; i < 5; ++i) {
  ------------------
  |  Branch (348:22): [True: 9.50M, False: 1.90M]
  ------------------
  349|  9.50M|      const uint64_t x0 = swap.if_set_return(a[i] ^ b[i]);
  350|  9.50M|      a[i] ^= x0;
  351|  9.50M|      b[i] ^= x0;
  352|       |
  353|  9.50M|      const uint64_t x1 = swap.if_set_return(c[i] ^ d[i]);
  354|  9.50M|      c[i] ^= x1;
  355|  9.50M|      d[i] ^= x1;
  356|  9.50M|   }
  357|  1.90M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_16fmontyEPmS1_S1_S1_S1_S1_S1_S1_PKm:
  309|  1.68M|            const uint64_t q_minus_q_dash[5]) {
  310|  1.68M|   uint64_t zzz[5];
  311|  1.68M|   uint64_t xx[5];
  312|  1.68M|   uint64_t zz[5];
  313|  1.68M|   uint64_t xxprime[5];
  314|  1.68M|   uint64_t zzprime[5];
  315|  1.68M|   uint64_t zzzprime[5];
  316|       |
  317|  1.68M|   fadd_sub(in_q_z, in_q_x);
  318|  1.68M|   fadd_sub(in_q_dash_z, in_q_dash_x);
  319|       |
  320|  1.68M|   fmul(xxprime, in_q_dash_x, in_q_z);
  321|  1.68M|   fmul(zzprime, in_q_dash_z, in_q_x);
  322|       |
  323|  1.68M|   fadd_sub(zzprime, xxprime);
  324|       |
  325|  1.68M|   fsquare(result_q_plus_q_dash_x, xxprime);
  326|  1.68M|   fsquare(zzzprime, zzprime);
  327|  1.68M|   fmul(result_q_plus_q_dash_z, zzzprime, q_minus_q_dash);
  328|       |
  329|  1.68M|   fsquare(xx, in_q_x);
  330|  1.68M|   fsquare(zz, in_q_z);
  331|  1.68M|   fmul(result_two_q_x, xx, zz);
  332|       |
  333|  1.68M|   fdifference_backwards(zz, xx);  // does zz = xx - zz
  334|  1.68M|   fscalar_product(zzz, zz, 121665);
  335|  1.68M|   fsum(zzz, xx);
  336|       |
  337|  1.68M|   fmul(result_two_q_z, zz, zzz);
  338|  1.68M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_18fadd_subEPmS1_:
   77|  5.06M|inline void fadd_sub(uint64_t x[5], uint64_t y[5]) {
   78|       |   // TODO merge these and avoid the tmp array
   79|  5.06M|   uint64_t tmp[5];
   80|  5.06M|   copy_mem(tmp, y, 5);
   81|  5.06M|   fsum(y, x);
   82|  5.06M|   fdifference_backwards(x, tmp);  // does x - z
   83|  5.06M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_17fsquareEPmPKmm:
  170|  6.83M|inline void fsquare(uint64_t out[5], const uint64_t in[5], size_t count = 1) {
  171|  6.83M|   uint64_t r0 = in[0];
  172|  6.83M|   uint64_t r1 = in[1];
  173|  6.83M|   uint64_t r2 = in[2];
  174|  6.83M|   uint64_t r3 = in[3];
  175|  6.83M|   uint64_t r4 = in[4];
  176|       |
  177|  15.2M|   for(size_t i = 0; i != count; ++i) {
  ------------------
  |  Branch (177:22): [True: 8.43M, False: 6.83M]
  ------------------
  178|  8.43M|      const uint64_t d0 = r0 * 2;
  179|  8.43M|      const uint64_t d1 = r1 * 2;
  180|  8.43M|      const uint64_t d2 = r2 * 2 * 19;
  181|  8.43M|      const uint64_t d419 = r4 * 19;
  182|  8.43M|      const uint64_t d4 = d419 * 2;
  183|       |
  184|  8.43M|      uint128_t t0 = uint128_t(r0) * r0 + uint128_t(d4) * r1 + uint128_t(d2) * (r3);
  185|  8.43M|      uint128_t t1 = uint128_t(d0) * r1 + uint128_t(d4) * r2 + uint128_t(r3) * (r3 * 19);
  186|  8.43M|      uint128_t t2 = uint128_t(d0) * r2 + uint128_t(r1) * r1 + uint128_t(d4) * (r3);
  187|  8.43M|      uint128_t t3 = uint128_t(d0) * r3 + uint128_t(d1) * r2 + uint128_t(r4) * (d419);
  188|  8.43M|      uint128_t t4 = uint128_t(d0) * r4 + uint128_t(d1) * r3 + uint128_t(r2) * (r2);
  189|       |
  190|  8.43M|      r0 = t0 & MASK_63;
  191|  8.43M|      t1 += carry_shift(t0, 51);
  192|  8.43M|      r1 = t1 & MASK_63;
  193|  8.43M|      t2 += carry_shift(t1, 51);
  194|  8.43M|      r2 = t2 & MASK_63;
  195|  8.43M|      t3 += carry_shift(t2, 51);
  196|  8.43M|      r3 = t3 & MASK_63;
  197|  8.43M|      t4 += carry_shift(t3, 51);
  198|  8.43M|      r4 = t4 & MASK_63;
  199|  8.43M|      uint64_t c = carry_shift(t4, 51);
  200|       |
  201|  8.43M|      r0 += c * 19;
  202|  8.43M|      c = r0 >> 51;
  203|  8.43M|      r0 = r0 & MASK_63;
  204|  8.43M|      r1 += c;
  205|  8.43M|      c = r1 >> 51;
  206|  8.43M|      r1 = r1 & MASK_63;
  207|  8.43M|      r2 += c;
  208|  8.43M|   }
  209|       |
  210|  6.83M|   out[0] = r0;
  211|  6.83M|   out[1] = r1;
  212|  6.83M|   out[2] = r2;
  213|  6.83M|   out[3] = r3;
  214|  6.83M|   out[4] = r4;
  215|  6.83M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_121fdifference_backwardsEPmPKm:
   65|  6.75M|inline void fdifference_backwards(uint64_t out[5], const uint64_t in[5]) {
   66|       |   /* 152 is 19 << 3 */
   67|  6.75M|   const uint64_t two54m152 = (static_cast<uint64_t>(1) << 54) - 152;
   68|  6.75M|   const uint64_t two54m8 = (static_cast<uint64_t>(1) << 54) - 8;
   69|       |
   70|  6.75M|   out[0] = in[0] + two54m152 - out[0];
   71|  6.75M|   out[1] = in[1] + two54m8 - out[1];
   72|  6.75M|   out[2] = in[2] + two54m8 - out[2];
   73|  6.75M|   out[3] = in[3] + two54m8 - out[3];
   74|  6.75M|   out[4] = in[4] + two54m8 - out[4];
   75|  6.75M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_115fscalar_productEPmPKmm:
   88|  1.68M|inline void fscalar_product(uint64_t out[5], const uint64_t in[5], const uint64_t scalar) {
   89|  1.68M|   uint128_t a = uint128_t(in[0]) * scalar;
   90|  1.68M|   out[0] = a & MASK_63;
   91|       |
   92|  1.68M|   a = uint128_t(in[1]) * scalar + carry_shift(a, 51);
   93|  1.68M|   out[1] = a & MASK_63;
   94|       |
   95|  1.68M|   a = uint128_t(in[2]) * scalar + carry_shift(a, 51);
   96|  1.68M|   out[2] = a & MASK_63;
   97|       |
   98|  1.68M|   a = uint128_t(in[3]) * scalar + carry_shift(a, 51);
   99|  1.68M|   out[3] = a & MASK_63;
  100|       |
  101|  1.68M|   a = uint128_t(in[4]) * scalar + carry_shift(a, 51);
  102|  1.68M|   out[4] = a & MASK_63;
  103|       |
  104|  1.68M|   out[0] += carry_shift(a, 51) * 19;
  105|  1.68M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_14fsumEPmPKm:
   51|  6.75M|inline void fsum(uint64_t out[5], const uint64_t in[5]) {
   52|  6.75M|   out[0] += in[0];
   53|  6.75M|   out[1] += in[1];
   54|  6.75M|   out[2] += in[2];
   55|  6.75M|   out[3] += in[3];
   56|  6.75M|   out[4] += in[4];
   57|  6.75M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_16crecipEPmPKm:
  422|  6.60k|void crecip(uint64_t out[5], const uint64_t z[5]) {
  423|  6.60k|   uint64_t a[5];
  424|  6.60k|   uint64_t b[5];
  425|  6.60k|   uint64_t c[5];
  426|  6.60k|   uint64_t t0[5];
  427|       |
  428|  6.60k|   fsquare(a, z);        // 2
  429|  6.60k|   fsquare(t0, a, 2);    // 8
  430|  6.60k|   fmul(b, t0, z);       // 9
  431|  6.60k|   fmul(a, b, a);        // 11
  432|  6.60k|   fsquare(t0, a);       // 22
  433|  6.60k|   fmul(b, t0, b);       // 2^5 - 2^0 = 31
  434|  6.60k|   fsquare(t0, b, 5);    // 2^10 - 2^5
  435|  6.60k|   fmul(b, t0, b);       // 2^10 - 2^0
  436|  6.60k|   fsquare(t0, b, 10);   // 2^20 - 2^10
  437|  6.60k|   fmul(c, t0, b);       // 2^20 - 2^0
  438|  6.60k|   fsquare(t0, c, 20);   // 2^40 - 2^20
  439|  6.60k|   fmul(t0, t0, c);      // 2^40 - 2^0
  440|  6.60k|   fsquare(t0, t0, 10);  // 2^50 - 2^10
  441|  6.60k|   fmul(b, t0, b);       // 2^50 - 2^0
  442|  6.60k|   fsquare(t0, b, 50);   // 2^100 - 2^50
  443|  6.60k|   fmul(c, t0, b);       // 2^100 - 2^0
  444|  6.60k|   fsquare(t0, c, 100);  // 2^200 - 2^100
  445|  6.60k|   fmul(t0, t0, c);      // 2^200 - 2^0
  446|  6.60k|   fsquare(t0, t0, 50);  // 2^250 - 2^50
  447|  6.60k|   fmul(t0, t0, b);      // 2^250 - 2^0
  448|  6.60k|   fsquare(t0, t0, 5);   // 2^255 - 2^5
  449|  6.60k|   fmul(out, t0, a);     // 2^255 - 21
  450|  6.60k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_14fmulEPmPKmS3_:
  115|  8.52M|inline void fmul(uint64_t out[5], const uint64_t in[5], const uint64_t in2[5]) {
  116|  8.52M|   const uint128_t s0 = in2[0];
  117|  8.52M|   const uint128_t s1 = in2[1];
  118|  8.52M|   const uint128_t s2 = in2[2];
  119|  8.52M|   const uint128_t s3 = in2[3];
  120|  8.52M|   const uint128_t s4 = in2[4];
  121|       |
  122|  8.52M|   uint64_t r0 = in[0];
  123|  8.52M|   uint64_t r1 = in[1];
  124|  8.52M|   uint64_t r2 = in[2];
  125|  8.52M|   uint64_t r3 = in[3];
  126|  8.52M|   uint64_t r4 = in[4];
  127|       |
  128|  8.52M|   uint128_t t0 = r0 * s0;
  129|  8.52M|   uint128_t t1 = r0 * s1 + r1 * s0;
  130|  8.52M|   uint128_t t2 = r0 * s2 + r2 * s0 + r1 * s1;
  131|  8.52M|   uint128_t t3 = r0 * s3 + r3 * s0 + r1 * s2 + r2 * s1;
  132|  8.52M|   uint128_t t4 = r0 * s4 + r4 * s0 + r3 * s1 + r1 * s3 + r2 * s2;
  133|       |
  134|  8.52M|   r4 *= 19;
  135|  8.52M|   r1 *= 19;
  136|  8.52M|   r2 *= 19;
  137|  8.52M|   r3 *= 19;
  138|       |
  139|  8.52M|   t0 += r4 * s1 + r1 * s4 + r2 * s3 + r3 * s2;
  140|  8.52M|   t1 += r4 * s2 + r2 * s4 + r3 * s3;
  141|  8.52M|   t2 += r4 * s3 + r3 * s4;
  142|  8.52M|   t3 += r4 * s4;
  143|       |
  144|  8.52M|   r0 = t0 & MASK_63;
  145|  8.52M|   t1 += carry_shift(t0, 51);
  146|  8.52M|   r1 = t1 & MASK_63;
  147|  8.52M|   t2 += carry_shift(t1, 51);
  148|  8.52M|   r2 = t2 & MASK_63;
  149|  8.52M|   t3 += carry_shift(t2, 51);
  150|  8.52M|   r3 = t3 & MASK_63;
  151|  8.52M|   t4 += carry_shift(t3, 51);
  152|  8.52M|   r4 = t4 & MASK_63;
  153|  8.52M|   uint64_t c = carry_shift(t4, 51);
  154|       |
  155|  8.52M|   r0 += c * 19;
  156|  8.52M|   c = r0 >> 51;
  157|  8.52M|   r0 = r0 & MASK_63;
  158|  8.52M|   r1 += c;
  159|  8.52M|   c = r1 >> 51;
  160|  8.52M|   r1 = r1 & MASK_63;
  161|  8.52M|   r2 += c;
  162|       |
  163|  8.52M|   out[0] = r0;
  164|  8.52M|   out[1] = r1;
  165|  8.52M|   out[2] = r2;
  166|  8.52M|   out[3] = r3;
  167|  8.52M|   out[4] = r4;
  168|  8.52M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_19fcontractEPhPKm:
  229|  6.60k|inline void fcontract(uint8_t* out, const uint64_t input[5]) {
  230|  6.60k|   uint128_t t0 = input[0];
  231|  6.60k|   uint128_t t1 = input[1];
  232|  6.60k|   uint128_t t2 = input[2];
  233|  6.60k|   uint128_t t3 = input[3];
  234|  6.60k|   uint128_t t4 = input[4];
  235|       |
  236|  19.8k|   for(size_t i = 0; i != 2; ++i) {
  ------------------
  |  Branch (236:22): [True: 13.2k, False: 6.60k]
  ------------------
  237|  13.2k|      t1 += t0 >> 51;
  238|  13.2k|      t0 &= MASK_63;
  239|  13.2k|      t2 += t1 >> 51;
  240|  13.2k|      t1 &= MASK_63;
  241|  13.2k|      t3 += t2 >> 51;
  242|  13.2k|      t2 &= MASK_63;
  243|  13.2k|      t4 += t3 >> 51;
  244|  13.2k|      t3 &= MASK_63;
  245|  13.2k|      t0 += (t4 >> 51) * 19;
  246|  13.2k|      t4 &= MASK_63;
  247|  13.2k|   }
  248|       |
  249|       |   /* now t is between 0 and 2^255-1, properly carried. */
  250|       |   /* case 1: between 0 and 2^255-20. case 2: between 2^255-19 and 2^255-1. */
  251|       |
  252|  6.60k|   t0 += 19;
  253|       |
  254|  6.60k|   t1 += t0 >> 51;
  255|  6.60k|   t0 &= MASK_63;
  256|  6.60k|   t2 += t1 >> 51;
  257|  6.60k|   t1 &= MASK_63;
  258|  6.60k|   t3 += t2 >> 51;
  259|  6.60k|   t2 &= MASK_63;
  260|  6.60k|   t4 += t3 >> 51;
  261|  6.60k|   t3 &= MASK_63;
  262|  6.60k|   t0 += (t4 >> 51) * 19;
  263|  6.60k|   t4 &= MASK_63;
  264|       |
  265|       |   /* now between 19 and 2^255-1 in both cases, and offset by 19. */
  266|       |
  267|  6.60k|   t0 += 0x8000000000000 - 19;
  268|  6.60k|   t1 += 0x8000000000000 - 1;
  269|  6.60k|   t2 += 0x8000000000000 - 1;
  270|  6.60k|   t3 += 0x8000000000000 - 1;
  271|  6.60k|   t4 += 0x8000000000000 - 1;
  272|       |
  273|       |   /* now between 2^255 and 2^256-20, and offset by 2^255. */
  274|       |
  275|  6.60k|   t1 += t0 >> 51;
  276|  6.60k|   t0 &= MASK_63;
  277|  6.60k|   t2 += t1 >> 51;
  278|  6.60k|   t1 &= MASK_63;
  279|  6.60k|   t3 += t2 >> 51;
  280|  6.60k|   t2 &= MASK_63;
  281|  6.60k|   t4 += t3 >> 51;
  282|  6.60k|   t3 &= MASK_63;
  283|  6.60k|   t4 &= MASK_63;
  284|       |
  285|  6.60k|   store_le(out,
  286|  6.60k|            combine_lower(t0, 0, t1, 51),
  287|  6.60k|            combine_lower(t1, 13, t2, 38),
  288|  6.60k|            combine_lower(t2, 26, t3, 25),
  289|  6.60k|            combine_lower(t3, 39, t4, 12));
  290|  6.60k|}

_ZN5Botan20curve25519_basepointEPhPKh:
   19|  6.60k|void curve25519_basepoint(uint8_t mypublic[32], const uint8_t secret[32]) {
   20|  6.60k|   const uint8_t basepoint[32] = {9};
   21|  6.60k|   curve25519_donna(mypublic, secret, basepoint);
   22|  6.60k|}
_ZNK5Botan16X25519_PublicKey9check_keyERNS_21RandomNumberGeneratorEb:
   44|  3.30k|bool X25519_PublicKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
   45|  3.30k|   return true;  // no tests possible?
   46|  3.30k|}
_ZN5Botan16X25519_PublicKeyC1ENSt3__14spanIKhLm18446744073709551615EEE:
   51|  3.30k|X25519_PublicKey::X25519_PublicKey(std::span<const uint8_t> pub) {
   52|  3.30k|   m_public.assign(pub.begin(), pub.end());
   53|       |
   54|  3.30k|   size_check(m_public.size(), "public key");
   55|  3.30k|}
_ZNK5Botan16X25519_PublicKey19raw_public_key_bitsEv:
   57|  3.30k|std::vector<uint8_t> X25519_PublicKey::raw_public_key_bits() const {
   58|  3.30k|   return m_public;
   59|  3.30k|}
_ZN5Botan17X25519_PrivateKeyC1ERNS_21RandomNumberGeneratorE:
   79|  3.30k|X25519_PrivateKey::X25519_PrivateKey(RandomNumberGenerator& rng) {
   80|  3.30k|   m_private = rng.random_vec(32);
   81|  3.30k|   m_public.resize(32);
   82|  3.30k|   curve25519_basepoint(m_public.data(), m_private.data());
   83|  3.30k|}
_ZNK5Botan17X25519_PrivateKey10public_keyEv:
   93|  3.30k|std::unique_ptr<Public_Key> X25519_PrivateKey::public_key() const {
   94|  3.30k|   return std::make_unique<X25519_PublicKey>(public_value());
   95|  3.30k|}
_ZNK5Botan17X25519_PrivateKey9check_keyERNS_21RandomNumberGeneratorEb:
  101|  3.30k|bool X25519_PrivateKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
  102|  3.30k|   std::vector<uint8_t> public_point(32);
  103|  3.30k|   curve25519_basepoint(public_point.data(), m_private.data());
  104|  3.30k|   return public_point == m_public;
  105|  3.30k|}
x25519.cpp:_ZN5Botan12_GLOBAL__N_110size_checkEmPKc:
   26|  3.30k|void size_check(size_t size, const char* thing) {
   27|  3.30k|   if(size != 32) {
  ------------------
  |  Branch (27:7): [True: 0, False: 3.30k]
  ------------------
   28|      0|      throw Decoding_Error(fmt("Invalid size {} for X25519 {}", size, thing));
   29|      0|   }
   30|  3.30k|}

_ZN5Botan14AutoSeeded_RNGD2Ev:
   42|  3.30k|AutoSeeded_RNG::~AutoSeeded_RNG() = default;
_ZN5Botan14AutoSeeded_RNGC2Em:
   64|  3.30k|AutoSeeded_RNG::AutoSeeded_RNG(size_t reseed_interval) {
   65|  3.30k|#if defined(BOTAN_HAS_SYSTEM_RNG)
   66|  3.30k|   m_rng = std::make_unique<HMAC_DRBG>(auto_rng_hmac(), system_rng(), reseed_interval);
   67|       |#elif defined(BOTAN_HAS_ENTROPY_SOURCE)
   68|       |   m_rng = std::make_unique<HMAC_DRBG>(auto_rng_hmac(), Entropy_Sources::global_sources(), reseed_interval);
   69|       |#else
   70|       |   BOTAN_UNUSED(reseed_interval);
   71|       |   throw Not_Implemented("AutoSeeded_RNG default constructor not available due to no RNG or entropy sources");
   72|       |#endif
   73|       |
   74|  3.30k|   force_reseed();
   75|  3.30k|}
_ZN5Botan14AutoSeeded_RNG12force_reseedEv:
   77|  3.30k|void AutoSeeded_RNG::force_reseed() {
   78|  3.30k|   m_rng->force_reseed();
   79|  3.30k|   m_rng->next_byte();
   80|       |
   81|  3.30k|   if(!m_rng->is_seeded()) {
  ------------------
  |  Branch (81:7): [True: 0, False: 3.30k]
  ------------------
   82|      0|      throw Internal_Error("AutoSeeded_RNG reseeding failed");
   83|      0|   }
   84|  3.30k|}
_ZN5Botan14AutoSeeded_RNG21fill_bytes_with_inputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
  102|  6.60k|void AutoSeeded_RNG::fill_bytes_with_input(std::span<uint8_t> out, std::span<const uint8_t> in) {
  103|  6.60k|   if(in.empty()) {
  ------------------
  |  Branch (103:7): [True: 6.60k, False: 0]
  ------------------
  104|  6.60k|      m_rng->randomize_with_ts_input(out);
  105|  6.60k|   } else {
  106|      0|      m_rng->randomize_with_input(out, in);
  107|      0|   }
  108|  6.60k|}
auto_rng.cpp:_ZN5Botan12_GLOBAL__N_113auto_rng_hmacEv:
   24|  3.30k|std::unique_ptr<MessageAuthenticationCode> auto_rng_hmac() {
   25|  3.30k|   const std::string possible_auto_rng_hmacs[] = {
   26|  3.30k|      "HMAC(SHA-512)",
   27|  3.30k|      "HMAC(SHA-256)",
   28|  3.30k|   };
   29|       |
   30|  3.30k|   for(const auto& hmac : possible_auto_rng_hmacs) {
  ------------------
  |  Branch (30:25): [True: 3.30k, False: 0]
  ------------------
   31|  3.30k|      if(auto mac = MessageAuthenticationCode::create(hmac)) {
  ------------------
  |  Branch (31:15): [True: 3.30k, False: 0]
  ------------------
   32|  3.30k|         return mac;
   33|  3.30k|      }
   34|  3.30k|   }
   35|       |
   36|       |   // This shouldn't happen since this module has a dependency on sha2_32
   37|      0|   throw Internal_Error("AutoSeeded_RNG: No usable HMAC hash found");
   38|  3.30k|}

_ZN5Botan9HMAC_DRBGC2ENSt3__110unique_ptrINS_25MessageAuthenticationCodeENS1_14default_deleteIS3_EEEERNS_21RandomNumberGeneratorEmm:
   51|  3.30k|      Stateful_RNG(underlying_rng, reseed_interval),
   52|  3.30k|      m_mac(std::move(prf)),
   53|  3.30k|      m_max_number_of_bytes_per_request(max_number_of_bytes_per_request),
   54|  3.30k|      m_security_level(hmac_drbg_security_level(m_mac->output_length())) {
   55|  3.30k|   BOTAN_ASSERT_NONNULL(m_mac);
  ------------------
  |  |   91|  3.30k|   do {                                                                                   \
  |  |   92|  3.30k|      if((ptr) == nullptr)                                                                \
  |  |  ------------------
  |  |  |  Branch (92:10): [True: 0, False: 3.30k]
  |  |  ------------------
  |  |   93|  3.30k|         Botan::assertion_failure(#ptr " is not null", "", __func__, __FILE__, __LINE__); \
  |  |   94|  3.30k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (94:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   56|       |
   57|  3.30k|   check_limits(reseed_interval, max_number_of_bytes_per_request);
   58|       |
   59|  3.30k|   clear();
   60|  3.30k|}
_ZN5Botan9HMAC_DRBG11clear_stateEv:
  110|  3.30k|void HMAC_DRBG::clear_state() {
  111|  3.30k|   if(m_V.empty()) {
  ------------------
  |  Branch (111:7): [True: 3.30k, False: 0]
  ------------------
  112|  3.30k|      const size_t output_length = m_mac->output_length();
  113|  3.30k|      m_V.resize(output_length);
  114|  3.30k|      m_T.resize(output_length);
  115|  3.30k|   }
  116|       |
  117|   214k|   for(size_t i = 0; i != m_V.size(); ++i) {
  ------------------
  |  Branch (117:22): [True: 211k, False: 3.30k]
  ------------------
  118|   211k|      m_V[i] = 0x01;
  119|   211k|   }
  120|  3.30k|   m_mac->set_key(std::vector<uint8_t>(m_V.size(), 0x00));
  121|  3.30k|}
_ZN5Botan9HMAC_DRBG15generate_outputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
  131|  9.90k|void HMAC_DRBG::generate_output(std::span<uint8_t> output, std::span<const uint8_t> input) {
  132|  9.90k|   BOTAN_ASSERT_NOMSG(!output.empty());
  ------------------
  |  |   64|  9.90k|   do {                                                                     \
  |  |   65|  9.90k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 9.90k]
  |  |  ------------------
  |  |   66|  9.90k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|  9.90k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  133|       |
  134|  9.90k|   if(!input.empty()) {
  ------------------
  |  Branch (134:7): [True: 6.60k, False: 3.30k]
  ------------------
  135|  6.60k|      update(input);
  136|  6.60k|   }
  137|       |
  138|  19.8k|   while(!output.empty()) {
  ------------------
  |  Branch (138:10): [True: 9.90k, False: 9.90k]
  ------------------
  139|  9.90k|      const size_t to_copy = std::min(output.size(), m_V.size());
  140|  9.90k|      m_mac->update(m_V);
  141|  9.90k|      m_mac->final(m_V);
  142|  9.90k|      copy_mem(output.data(), m_V.data(), to_copy);
  143|       |
  144|  9.90k|      output = output.subspan(to_copy);
  145|  9.90k|   }
  146|       |
  147|  9.90k|   update(input);
  148|  9.90k|}
_ZN5Botan9HMAC_DRBG6updateENSt3__14spanIKhLm18446744073709551615EEE:
  154|  19.8k|void HMAC_DRBG::update(std::span<const uint8_t> input) {
  155|  19.8k|   m_mac->update(m_V);
  156|  19.8k|   m_mac->update(0x00);
  157|  19.8k|   if(!input.empty()) {
  ------------------
  |  Branch (157:7): [True: 16.5k, False: 3.30k]
  ------------------
  158|  16.5k|      m_mac->update(input);
  159|  16.5k|   }
  160|  19.8k|   m_mac->final(m_T);
  161|  19.8k|   m_mac->set_key(m_T);
  162|       |
  163|  19.8k|   m_mac->update(m_V);
  164|  19.8k|   m_mac->final(m_V);
  165|       |
  166|  19.8k|   if(!input.empty()) {
  ------------------
  |  Branch (166:7): [True: 16.5k, False: 3.30k]
  ------------------
  167|  16.5k|      m_mac->update(m_V);
  168|  16.5k|      m_mac->update(0x01);
  169|  16.5k|      m_mac->update(input);
  170|  16.5k|      m_mac->final(m_T);
  171|  16.5k|      m_mac->set_key(m_T);
  172|       |
  173|  16.5k|      m_mac->update(m_V);
  174|  16.5k|      m_mac->final(m_V);
  175|  16.5k|   }
  176|  19.8k|}
_ZNK5Botan9HMAC_DRBG14security_levelEv:
  178|  9.90k|size_t HMAC_DRBG::security_level() const {
  179|  9.90k|   return m_security_level;
  180|  9.90k|}
hmac_drbg.cpp:_ZN5Botan12_GLOBAL__N_124hmac_drbg_security_levelEm:
   18|  3.30k|size_t hmac_drbg_security_level(size_t mac_output_length) {
   19|       |   // security strength of the hash function
   20|       |   // for pre-image resistance (see NIST SP 800-57)
   21|       |   // SHA-1: 128 bits
   22|       |   // SHA-224, SHA-512/224: 192 bits,
   23|       |   // SHA-256, SHA-512/256, SHA-384, SHA-512: >= 256 bits
   24|       |   // NIST SP 800-90A only supports up to 256 bits though
   25|       |
   26|  3.30k|   if(mac_output_length < 32) {
  ------------------
  |  Branch (26:7): [True: 0, False: 3.30k]
  ------------------
   27|      0|      return (mac_output_length - 4) * 8;
   28|  3.30k|   } else {
   29|  3.30k|      return 32 * 8;
   30|  3.30k|   }
   31|  3.30k|}
hmac_drbg.cpp:_ZN5Botan12_GLOBAL__N_112check_limitsEmm:
   33|  3.30k|void check_limits(size_t reseed_interval, size_t max_number_of_bytes_per_request) {
   34|       |   // SP800-90A permits up to 2^48, but it is not usable on 32 bit
   35|       |   // platforms, so we only allow up to 2^24, which is still reasonably high
   36|  3.30k|   if(reseed_interval == 0 || reseed_interval > static_cast<size_t>(1) << 24) {
  ------------------
  |  Branch (36:7): [True: 0, False: 3.30k]
  |  Branch (36:31): [True: 0, False: 3.30k]
  ------------------
   37|      0|      throw Invalid_Argument("Invalid value for reseed_interval");
   38|      0|   }
   39|       |
   40|  3.30k|   if(max_number_of_bytes_per_request == 0 || max_number_of_bytes_per_request > 64 * 1024) {
  ------------------
  |  Branch (40:7): [True: 0, False: 3.30k]
  |  Branch (40:47): [True: 0, False: 3.30k]
  ------------------
   41|      0|      throw Invalid_Argument("Invalid value for max_number_of_bytes_per_request");
   42|      0|   }
   43|  3.30k|}

_ZN5Botan21RandomNumberGenerator23randomize_with_ts_inputENSt3__14spanIhLm18446744073709551615EEE:
   27|  6.60k|void RandomNumberGenerator::randomize_with_ts_input(std::span<uint8_t> output) {
   28|  6.60k|   if(this->accepts_input()) {
  ------------------
  |  Branch (28:7): [True: 6.60k, False: 0]
  ------------------
   29|  6.60k|      std::array<uint8_t, 32> additional_input = {0};
   30|       |
   31|  6.60k|#if defined(BOTAN_HAS_OS_UTILS)
   32|  6.60k|      store_le(std::span{additional_input}.subspan<0, 8>(), OS::get_high_resolution_clock());
   33|  6.60k|      store_le(std::span{additional_input}.subspan<8, 4>(), OS::get_process_id());
   34|  6.60k|      constexpr size_t offset = 12;
   35|       |#else
   36|       |      constexpr size_t offset = 0;
   37|       |#endif
   38|       |
   39|  6.60k|#if defined(BOTAN_HAS_SYSTEM_RNG)
   40|  6.60k|      system_rng().randomize(std::span{additional_input}.subspan<offset>());
   41|       |#else
   42|       |      BOTAN_UNUSED(offset);
   43|       |#endif
   44|       |
   45|  6.60k|      this->fill_bytes_with_input(output, additional_input);
   46|  6.60k|   } else {
   47|      0|      this->fill_bytes_with_input(output, {});
   48|      0|   }
   49|  6.60k|}
_ZN5Botan21RandomNumberGenerator15reseed_from_rngERS0_m:
   63|  3.30k|void RandomNumberGenerator::reseed_from_rng(RandomNumberGenerator& rng, size_t poll_bits) {
   64|  3.30k|   if(this->accepts_input()) {
  ------------------
  |  Branch (64:7): [True: 3.30k, False: 0]
  ------------------
   65|  3.30k|      this->add_entropy(rng.random_vec(poll_bits / 8));
   66|  3.30k|   }
   67|  3.30k|}

_ZN5Botan12Stateful_RNG5clearEv:
   14|  3.30k|void Stateful_RNG::clear() {
   15|  3.30k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   16|  3.30k|   m_reseed_counter = 0;
   17|  3.30k|   m_last_pid = 0;
   18|  3.30k|   clear_state();
   19|  3.30k|}
_ZN5Botan12Stateful_RNG12force_reseedEv:
   21|  3.30k|void Stateful_RNG::force_reseed() {
   22|  3.30k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   23|  3.30k|   m_reseed_counter = 0;
   24|  3.30k|}
_ZNK5Botan12Stateful_RNG9is_seededEv:
   26|  16.5k|bool Stateful_RNG::is_seeded() const {
   27|  16.5k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   28|  16.5k|   return m_reseed_counter > 0;
   29|  16.5k|}
_ZN5Botan12Stateful_RNG23generate_batched_outputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
   38|  9.90k|void Stateful_RNG::generate_batched_output(std::span<uint8_t> output, std::span<const uint8_t> input) {
   39|  9.90k|   BOTAN_ASSERT_NOMSG(!output.empty());
  ------------------
  |  |   64|  9.90k|   do {                                                                     \
  |  |   65|  9.90k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 9.90k]
  |  |  ------------------
  |  |   66|  9.90k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|  9.90k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   40|       |
   41|  9.90k|   const size_t max_per_request = max_number_of_bytes_per_request();
   42|       |
   43|  9.90k|   if(max_per_request == 0) {
  ------------------
  |  Branch (43:7): [True: 0, False: 9.90k]
  ------------------
   44|       |      // no limit
   45|      0|      reseed_check();
   46|      0|      this->generate_output(output, input);
   47|  9.90k|   } else {
   48|  19.8k|      while(!output.empty()) {
  ------------------
  |  Branch (48:13): [True: 9.90k, False: 9.90k]
  ------------------
   49|  9.90k|         const size_t this_req = std::min(max_per_request, output.size());
   50|       |
   51|  9.90k|         reseed_check();
   52|  9.90k|         this->generate_output(output.subspan(0, this_req), input);
   53|       |
   54|       |         // only include the input for the first iteration
   55|  9.90k|         input = {};
   56|       |
   57|  9.90k|         output = output.subspan(this_req);
   58|  9.90k|      }
   59|  9.90k|   }
   60|  9.90k|}
_ZN5Botan12Stateful_RNG21fill_bytes_with_inputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
   62|  13.2k|void Stateful_RNG::fill_bytes_with_input(std::span<uint8_t> output, std::span<const uint8_t> input) {
   63|  13.2k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   64|       |
   65|  13.2k|   if(output.empty()) {
  ------------------
  |  Branch (65:7): [True: 3.30k, False: 9.90k]
  ------------------
   66|       |      // Special case for exclusively adding entropy to the stateful RNG.
   67|  3.30k|      this->update(input);
   68|       |
   69|  3.30k|      if(8 * input.size() >= security_level()) {
  ------------------
  |  Branch (69:10): [True: 3.30k, False: 0]
  ------------------
   70|  3.30k|         reset_reseed_counter();
   71|  3.30k|      }
   72|  9.90k|   } else {
   73|  9.90k|      generate_batched_output(output, input);
   74|  9.90k|   }
   75|  13.2k|}
_ZN5Botan12Stateful_RNG15reseed_from_rngERNS_21RandomNumberGeneratorEm:
   89|  3.30k|void Stateful_RNG::reseed_from_rng(RandomNumberGenerator& rng, size_t poll_bits) {
   90|  3.30k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   91|       |
   92|  3.30k|   RandomNumberGenerator::reseed_from_rng(rng, poll_bits);
   93|       |
   94|  3.30k|   if(poll_bits >= security_level()) {
  ------------------
  |  Branch (94:7): [True: 3.30k, False: 0]
  ------------------
   95|  3.30k|      reset_reseed_counter();
   96|  3.30k|   }
   97|  3.30k|}
_ZN5Botan12Stateful_RNG20reset_reseed_counterEv:
   99|  6.60k|void Stateful_RNG::reset_reseed_counter() {
  100|       |   // Lock is held whenever this function is called
  101|  6.60k|   m_reseed_counter = 1;
  102|  6.60k|}
_ZN5Botan12Stateful_RNG12reseed_checkEv:
  104|  9.90k|void Stateful_RNG::reseed_check() {
  105|       |   // Lock is held whenever this function is called
  106|       |
  107|  9.90k|   const uint32_t cur_pid = OS::get_process_id();
  108|       |
  109|  9.90k|   const bool fork_detected = (m_last_pid > 0) && (cur_pid != m_last_pid);
  ------------------
  |  Branch (109:31): [True: 6.60k, False: 3.30k]
  |  Branch (109:51): [True: 0, False: 6.60k]
  ------------------
  110|       |
  111|  9.90k|   if(is_seeded() == false || fork_detected || (m_reseed_interval > 0 && m_reseed_counter >= m_reseed_interval)) {
  ------------------
  |  Branch (111:7): [True: 3.30k, False: 6.60k]
  |  Branch (111:31): [True: 0, False: 6.60k]
  |  Branch (111:49): [True: 6.60k, False: 0]
  |  Branch (111:74): [True: 0, False: 6.60k]
  ------------------
  112|  3.30k|      m_reseed_counter = 0;
  113|  3.30k|      m_last_pid = cur_pid;
  114|       |
  115|  3.30k|      if(m_underlying_rng) {
  ------------------
  |  Branch (115:10): [True: 3.30k, False: 0]
  ------------------
  116|  3.30k|         reseed_from_rng(*m_underlying_rng, security_level());
  117|  3.30k|      }
  118|       |
  119|  3.30k|      if(m_entropy_sources) {
  ------------------
  |  Branch (119:10): [True: 0, False: 3.30k]
  ------------------
  120|      0|         reseed(*m_entropy_sources, security_level());
  121|      0|      }
  122|       |
  123|  3.30k|      if(!is_seeded()) {
  ------------------
  |  Branch (123:10): [True: 0, False: 3.30k]
  ------------------
  124|      0|         if(fork_detected) {
  ------------------
  |  Branch (124:13): [True: 0, False: 0]
  ------------------
  125|      0|            throw Invalid_State("Detected use of fork but cannot reseed DRBG");
  126|      0|         } else {
  127|      0|            throw PRNG_Unseeded(name());
  128|      0|         }
  129|      0|      }
  130|  6.60k|   } else {
  131|  6.60k|      BOTAN_ASSERT(m_reseed_counter != 0, "RNG is seeded");
  ------------------
  |  |   55|  6.60k|   do {                                                                                 \
  |  |   56|  6.60k|      if(!(expr))                                                                       \
  |  |  ------------------
  |  |  |  Branch (56:10): [True: 0, False: 6.60k]
  |  |  ------------------
  |  |   57|  6.60k|         Botan::assertion_failure(#expr, assertion_made, __func__, __FILE__, __LINE__); \
  |  |   58|  6.60k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (58:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  132|  6.60k|      m_reseed_counter += 1;
  133|  6.60k|   }
  134|  9.90k|}

_ZN5Botan10system_rngEv:
  371|  9.90k|RandomNumberGenerator& system_rng() {
  372|  9.90k|   static System_RNG_Impl g_system_rng;
  373|  9.90k|   return g_system_rng;
  374|  9.90k|}
system_rng.cpp:_ZN5Botan12_GLOBAL__N_115System_RNG_Impl21fill_bytes_with_inputENSt3__14spanIhLm18446744073709551615EEENS3_IKhLm18446744073709551615EEE:
  213|  9.90k|      void fill_bytes_with_input(std::span<uint8_t> output, std::span<const uint8_t> /* ignored */) override {
  214|  9.90k|         const unsigned int flags = 0;
  215|       |
  216|  9.90k|         uint8_t* buf = output.data();
  217|  9.90k|         size_t len = output.size();
  218|  19.8k|         while(len > 0) {
  ------------------
  |  Branch (218:16): [True: 9.90k, False: 9.90k]
  ------------------
  219|       |   #if defined(__GLIBC__) && __GLIBC__ == 2 && __GLIBC_MINOR__ < 25
  220|       |            const ssize_t got = ::syscall(SYS_getrandom, buf, len, flags);
  221|       |   #else
  222|  9.90k|            const ssize_t got = ::getrandom(buf, len, flags);
  223|  9.90k|   #endif
  224|       |
  225|  9.90k|            if(got < 0) {
  ------------------
  |  Branch (225:16): [True: 0, False: 9.90k]
  ------------------
  226|      0|               if(errno == EINTR) {
  ------------------
  |  Branch (226:19): [True: 0, False: 0]
  ------------------
  227|      0|                  continue;
  228|      0|               }
  229|      0|               throw System_Error("System_RNG getrandom failed", errno);
  230|      0|            }
  231|       |
  232|  9.90k|            buf += got;
  233|  9.90k|            len -= got;
  234|  9.90k|         }
  235|  9.90k|      }

_ZN5Botan15allocate_memoryEmm:
   21|  49.5k|BOTAN_MALLOC_FN void* allocate_memory(size_t elems, size_t elem_size) {
   22|  49.5k|   if(elems == 0 || elem_size == 0) {
  ------------------
  |  Branch (22:7): [True: 0, False: 49.5k]
  |  Branch (22:21): [True: 0, False: 49.5k]
  ------------------
   23|      0|      return nullptr;
   24|      0|   }
   25|       |
   26|       |   // Some calloc implementations do not check for overflow (?!?)
   27|  49.5k|   if(!checked_mul(elems, elem_size).has_value()) {
  ------------------
  |  Branch (27:7): [True: 0, False: 49.5k]
  ------------------
   28|      0|      throw std::bad_alloc();
   29|      0|   }
   30|       |
   31|  49.5k|#if defined(BOTAN_HAS_LOCKING_ALLOCATOR)
   32|  49.5k|   if(void* p = mlock_allocator::instance().allocate(elems, elem_size)) {
  ------------------
  |  Branch (32:13): [True: 49.5k, False: 0]
  ------------------
   33|  49.5k|      return p;
   34|  49.5k|   }
   35|      0|#endif
   36|       |
   37|       |#if defined(BOTAN_TARGET_OS_HAS_ALLOC_CONCEAL)
   38|       |   void* ptr = ::calloc_conceal(elems, elem_size);
   39|       |#else
   40|      0|   void* ptr = std::calloc(elems, elem_size);  // NOLINT(*-no-malloc)
   41|      0|#endif
   42|      0|   if(!ptr) {
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
   43|      0|      [[unlikely]] throw std::bad_alloc();
   44|      0|   }
   45|      0|   return ptr;
   46|      0|}
_ZN5Botan17deallocate_memoryEPvmm:
   48|  49.5k|void deallocate_memory(void* p, size_t elems, size_t elem_size) {
   49|  49.5k|   if(p == nullptr) {
  ------------------
  |  Branch (49:7): [True: 0, False: 49.5k]
  ------------------
   50|      0|      [[unlikely]] return;
   51|      0|   }
   52|       |
   53|  49.5k|   secure_scrub_memory(p, elems * elem_size);
   54|       |
   55|  49.5k|#if defined(BOTAN_HAS_LOCKING_ALLOCATOR)
   56|  49.5k|   if(mlock_allocator::instance().deallocate(p, elems, elem_size)) {
  ------------------
  |  Branch (56:7): [True: 49.5k, False: 0]
  ------------------
   57|  49.5k|      return;
   58|  49.5k|   }
   59|      0|#endif
   60|       |
   61|      0|   std::free(p);  // NOLINT(*-no-malloc)
   62|      0|}

_ZN5Botan5CPUID10CPUID_DataC2Ev:
   79|      1|CPUID::CPUID_Data::CPUID_Data() {
   80|      1|#if defined(BOTAN_HAS_CPUID_DETECTION)
   81|      1|   m_processor_features = detect_cpu_features(~cleared_cpuid_bits());
   82|       |#else
   83|       |   m_processor_features = 0;
   84|       |#endif
   85|      1|}
cpuid.cpp:_ZN5Botan12_GLOBAL__N_118cleared_cpuid_bitsEv:
   58|      1|uint32_t cleared_cpuid_bits() {
   59|      1|   uint32_t cleared = 0;
   60|       |
   61|      1|   #if defined(BOTAN_HAS_OS_UTILS)
   62|      1|   std::string clear_cpuid_env;
   63|      1|   if(OS::read_env_variable(clear_cpuid_env, "BOTAN_CLEAR_CPUID")) {
  ------------------
  |  Branch (63:7): [True: 0, False: 1]
  ------------------
   64|      0|      for(const auto& cpuid : split_on(clear_cpuid_env, ',')) {
  ------------------
  |  Branch (64:29): [True: 0, False: 0]
  ------------------
   65|      0|         if(auto bit = CPUID::bit_from_string(cpuid)) {
  ------------------
  |  Branch (65:18): [True: 0, False: 0]
  ------------------
   66|      0|            cleared |= bit->as_u32();
   67|      0|         }
   68|      0|      }
   69|      0|   }
   70|      1|   #endif
   71|       |
   72|      1|   return cleared;
   73|      1|}

_ZN5Botan5CPUID10CPUID_Data19detect_cpu_featuresEj:
   61|      1|uint32_t CPUID::CPUID_Data::detect_cpu_features(uint32_t allowed) {
   62|      1|   enum class x86_CPUID_1_bits : uint64_t {
   63|      1|      RDTSC = (1ULL << 4),
   64|      1|      SSE2 = (1ULL << 26),
   65|      1|      CLMUL = (1ULL << 33),
   66|      1|      SSSE3 = (1ULL << 41),
   67|      1|      SSE41 = (1ULL << 51),
   68|      1|      AESNI = (1ULL << 57),
   69|       |      // AVX + OSXSAVE
   70|      1|      OSXSAVE = (1ULL << 59) | (1ULL << 60),
   71|      1|      RDRAND = (1ULL << 62)
   72|      1|   };
   73|       |
   74|      1|   enum class x86_CPUID_7_bits : uint64_t {
   75|      1|      BMI1 = (1ULL << 3),
   76|      1|      AVX2 = (1ULL << 5),
   77|      1|      BMI2 = (1ULL << 8),
   78|      1|      BMI_1_AND_2 = BMI1 | BMI2,
   79|      1|      AVX512_F = (1ULL << 16),
   80|      1|      AVX512_DQ = (1ULL << 17),
   81|      1|      RDSEED = (1ULL << 18),
   82|      1|      ADX = (1ULL << 19),
   83|      1|      AVX512_IFMA = (1ULL << 21),
   84|      1|      SHA = (1ULL << 29),
   85|      1|      AVX512_BW = (1ULL << 30),
   86|      1|      AVX512_VL = (1ULL << 31),
   87|      1|      AVX512_VBMI = (1ULL << 33),
   88|      1|      AVX512_VBMI2 = (1ULL << 38),
   89|      1|      GFNI = (1ULL << 40),
   90|      1|      AVX512_VAES = (1ULL << 41),
   91|      1|      AVX512_VCLMUL = (1ULL << 42),
   92|      1|      AVX512_VBITALG = (1ULL << 44),
   93|       |
   94|       |      /*
   95|       |      We only enable AVX512 support if all of the below flags are available
   96|       |
   97|       |      This is more than we strictly need for most uses, however it also has
   98|       |      the effect of preventing execution of AVX512 codepaths on cores that
   99|       |      have serious downclocking problems when AVX512 code executes,
  100|       |      especially Intel Skylake.
  101|       |
  102|       |      VBMI2/VBITALG are the key flags here as they restrict us to Intel Ice
  103|       |      Lake/Rocket Lake, or AMD Zen4, all of which do not have penalties for
  104|       |      executing AVX512.
  105|       |
  106|       |      There is nothing stopping some future processor from supporting the
  107|       |      above flags and having AVX512 penalties, but maybe you should not have
  108|       |      bought such a processor.
  109|       |      */
  110|      1|      AVX512_PROFILE =
  111|      1|         AVX512_F | AVX512_DQ | AVX512_IFMA | AVX512_BW | AVX512_VL | AVX512_VBMI | AVX512_VBMI2 | AVX512_VBITALG,
  112|      1|   };
  113|       |
  114|       |   // NOLINTNEXTLINE(performance-enum-size)
  115|      1|   enum class x86_CPUID_7_1_bits : uint64_t {
  116|      1|      SHA512 = (1 << 0),
  117|      1|      SM3 = (1 << 1),
  118|      1|      SM4 = (1 << 2),
  119|      1|   };
  120|       |
  121|      1|   uint32_t feat = 0;
  122|      1|   uint32_t cpuid[4] = {0};
  123|      1|   bool has_os_ymm_support = false;
  124|      1|   bool has_os_zmm_support = false;
  125|       |
  126|       |   // CPUID 0: vendor identification, max sublevel
  127|      1|   invoke_cpuid(0, cpuid);
  128|       |
  129|      1|   const uint32_t max_supported_sublevel = cpuid[0];
  130|       |
  131|      1|   if(max_supported_sublevel >= 1) {
  ------------------
  |  Branch (131:7): [True: 1, False: 0]
  ------------------
  132|       |      // CPUID 1: feature bits
  133|      1|      invoke_cpuid(1, cpuid);
  134|      1|      const uint64_t flags0 = (static_cast<uint64_t>(cpuid[2]) << 32) | cpuid[3];
  135|       |
  136|      1|      feat |= if_set(flags0, x86_CPUID_1_bits::RDTSC, CPUFeature::Bit::RDTSC, allowed);
  137|       |
  138|      1|      feat |= if_set(flags0, x86_CPUID_1_bits::RDRAND, CPUFeature::Bit::RDRAND, allowed);
  139|       |
  140|      1|      feat |= if_set(flags0, x86_CPUID_1_bits::SSE2, CPUFeature::Bit::SSE2, allowed);
  141|       |
  142|      1|      if(feat & CPUFeature::Bit::SSE2) {
  ------------------
  |  Branch (142:10): [True: 1, False: 0]
  ------------------
  143|      1|         feat |= if_set(flags0, x86_CPUID_1_bits::SSSE3, CPUFeature::Bit::SSSE3, allowed);
  144|       |
  145|      1|         if(feat & CPUFeature::Bit::SSSE3) {
  ------------------
  |  Branch (145:13): [True: 1, False: 0]
  ------------------
  146|      1|            feat |= if_set(flags0, x86_CPUID_1_bits::CLMUL, CPUFeature::Bit::CLMUL, allowed);
  147|      1|            feat |= if_set(flags0, x86_CPUID_1_bits::AESNI, CPUFeature::Bit::AESNI, allowed);
  148|      1|         }
  149|       |
  150|      1|         const uint64_t osxsave64 = static_cast<uint64_t>(x86_CPUID_1_bits::OSXSAVE);
  151|      1|         if((flags0 & osxsave64) == osxsave64) {
  ------------------
  |  Branch (151:13): [True: 1, False: 0]
  ------------------
  152|      1|            const uint64_t xcr_flags = xgetbv();
  153|      1|            if((xcr_flags & 0x6) == 0x6) {
  ------------------
  |  Branch (153:16): [True: 1, False: 0]
  ------------------
  154|      1|               has_os_ymm_support = true;
  155|      1|               has_os_zmm_support = (xcr_flags & 0xE0) == 0xE0;
  156|      1|            }
  157|      1|         }
  158|      1|      }
  159|      1|   }
  160|       |
  161|      1|   if(max_supported_sublevel >= 7) {
  ------------------
  |  Branch (161:7): [True: 1, False: 0]
  ------------------
  162|      1|      clear_mem(cpuid, 4);
  163|      1|      invoke_cpuid_sublevel(7, 0, cpuid);
  164|       |
  165|      1|      const uint64_t flags7 = (static_cast<uint64_t>(cpuid[2]) << 32) | cpuid[1];
  166|       |
  167|      1|      clear_mem(cpuid, 4);
  168|      1|      invoke_cpuid_sublevel(7, 1, cpuid);
  169|      1|      const uint32_t flags7_1 = cpuid[0];
  170|       |
  171|      1|      feat |= if_set(flags7, x86_CPUID_7_bits::RDSEED, CPUFeature::Bit::RDSEED, allowed);
  172|      1|      feat |= if_set(flags7, x86_CPUID_7_bits::ADX, CPUFeature::Bit::ADX, allowed);
  173|       |
  174|       |      /*
  175|       |      We only set the BMI bit if both BMI1 and BMI2 are supported, since
  176|       |      typically we want to use both extensions in the same code.
  177|       |      */
  178|      1|      feat |= if_set(flags7, x86_CPUID_7_bits::BMI_1_AND_2, CPUFeature::Bit::BMI, allowed);
  179|       |
  180|      1|      if(feat & CPUFeature::Bit::SSSE3) {
  ------------------
  |  Branch (180:10): [True: 1, False: 0]
  ------------------
  181|      1|         feat |= if_set(flags7, x86_CPUID_7_bits::SHA, CPUFeature::Bit::SHA, allowed);
  182|      1|         feat |= if_set(flags7_1, x86_CPUID_7_1_bits::SM3, CPUFeature::Bit::SM3, allowed);
  183|       |
  184|       |         // We only consider AVX2 if SSSE3 is supported
  185|      1|         if(has_os_ymm_support) {
  ------------------
  |  Branch (185:13): [True: 1, False: 0]
  ------------------
  186|      1|            feat |= if_set(flags7, x86_CPUID_7_bits::AVX2, CPUFeature::Bit::AVX2, allowed);
  187|       |
  188|      1|            if(feat & CPUFeature::Bit::AVX2) {
  ------------------
  |  Branch (188:16): [True: 1, False: 0]
  ------------------
  189|      1|               feat |= if_set(flags7, x86_CPUID_7_bits::GFNI, CPUFeature::Bit::GFNI, allowed);
  190|      1|               feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VAES, CPUFeature::Bit::AVX2_AES, allowed);
  191|      1|               feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VCLMUL, CPUFeature::Bit::AVX2_CLMUL, allowed);
  192|      1|               feat |= if_set(flags7_1, x86_CPUID_7_1_bits::SHA512, CPUFeature::Bit::SHA512, allowed);
  193|      1|               feat |= if_set(flags7_1, x86_CPUID_7_1_bits::SM4, CPUFeature::Bit::SM4, allowed);
  194|       |
  195|       |               // Likewise we only consider AVX-512 if AVX2 is supported
  196|      1|               if(has_os_zmm_support) {
  ------------------
  |  Branch (196:19): [True: 0, False: 1]
  ------------------
  197|      0|                  feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_PROFILE, CPUFeature::Bit::AVX512, allowed);
  198|       |
  199|      0|                  if(feat & CPUFeature::Bit::AVX512) {
  ------------------
  |  Branch (199:22): [True: 0, False: 0]
  ------------------
  200|      0|                     feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VAES, CPUFeature::Bit::AVX512_AES, allowed);
  201|      0|                     feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VCLMUL, CPUFeature::Bit::AVX512_CLMUL, allowed);
  202|      0|                  }
  203|      0|               }
  204|      1|            }
  205|      1|         }
  206|      1|      }
  207|      1|   }
  208|       |
  209|       |/*
  210|       |   * If we don't have access to CPUID, we can still safely assume that
  211|       |   * any x86-64 processor has SSE2 and RDTSC
  212|       |   */
  213|      1|#if defined(BOTAN_TARGET_ARCH_IS_X86_64)
  214|      1|   if(feat == 0) {
  ------------------
  |  Branch (214:7): [True: 0, False: 1]
  ------------------
  215|      0|      feat |= CPUFeature::Bit::SSE2 & allowed;
  216|      0|      feat |= CPUFeature::Bit::RDTSC & allowed;
  217|      0|   }
  218|      1|#endif
  219|       |
  220|      1|   return feat;
  221|      1|}
cpuid_x86.cpp:_ZN5Botan12_GLOBAL__N_112invoke_cpuidEjPj:
   25|      2|void invoke_cpuid(uint32_t type, uint32_t out[4]) {
   26|      2|   clear_mem(out, 4);
   27|       |
   28|      2|#if defined(BOTAN_USE_GCC_INLINE_ASM)
   29|      2|   asm volatile("cpuid\n\t" : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3]) : "0"(type));
   30|       |
   31|       |#elif defined(BOTAN_BUILD_COMPILER_IS_MSVC)
   32|       |   __cpuid((int*)out, type);
   33|       |
   34|       |#else
   35|       |   BOTAN_UNUSED(type);
   36|       |   #warning "No way of calling x86 cpuid instruction for this compiler"
   37|       |#endif
   38|      2|}
cpuid_x86.cpp:_ZN5Botan12_GLOBAL__N_16xgetbvEv:
   55|      1|BOTAN_FUNC_ISA("xsave") uint64_t xgetbv() {
   56|      1|   return _xgetbv(0);
   57|      1|}
cpuid_x86.cpp:_ZN5Botan12_GLOBAL__N_121invoke_cpuid_sublevelEjjPj:
   40|      2|void invoke_cpuid_sublevel(uint32_t type, uint32_t level, uint32_t out[4]) {
   41|      2|   clear_mem(out, 4);
   42|       |
   43|      2|#if defined(BOTAN_USE_GCC_INLINE_ASM)
   44|      2|   asm volatile("cpuid\n\t" : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3]) : "0"(type), "2"(level));
   45|       |
   46|       |#elif defined(BOTAN_BUILD_COMPILER_IS_MSVC)
   47|       |   __cpuidex((int*)out, type, level);
   48|       |
   49|       |#else
   50|       |   BOTAN_UNUSED(type, level);
   51|       |   #warning "No way of calling x86 cpuid instruction for this compiler"
   52|       |#endif
   53|      2|}

_ZN5Botan15mlock_allocator8allocateEmm:
   17|  49.5k|void* mlock_allocator::allocate(size_t num_elems, size_t elem_size) {
   18|  49.5k|   if(!m_pool) {
  ------------------
  |  Branch (18:7): [True: 0, False: 49.5k]
  ------------------
   19|      0|      return nullptr;
   20|      0|   }
   21|       |
   22|  49.5k|   if(auto n = checked_mul(num_elems, elem_size)) {
  ------------------
  |  Branch (22:12): [True: 49.5k, False: 0]
  ------------------
   23|  49.5k|      return m_pool->allocate(n.value());
   24|  49.5k|   } else {
   25|       |      // overflow!
   26|      0|      return nullptr;
   27|      0|   }
   28|  49.5k|}
_ZN5Botan15mlock_allocator10deallocateEPvmm:
   30|  49.5k|bool mlock_allocator::deallocate(void* p, size_t num_elems, size_t elem_size) noexcept {
   31|  49.5k|   if(!m_pool) {
  ------------------
  |  Branch (31:7): [True: 0, False: 49.5k]
  ------------------
   32|      0|      return false;
   33|      0|   }
   34|       |
   35|  49.5k|   if(auto n = checked_mul(num_elems, elem_size)) {
  ------------------
  |  Branch (35:12): [True: 49.5k, False: 0]
  ------------------
   36|  49.5k|      return m_pool->deallocate(p, n.value());
   37|  49.5k|   } else {
   38|       |      /*
   39|       |      We return nullptr in allocate if there was an overflow, so if an
   40|       |      overflow occurs here we know the pointer was not allocated by this pool.
   41|       |      */
   42|      0|      return false;
   43|      0|   }
   44|  49.5k|}
_ZN5Botan15mlock_allocatorC2Ev:
   46|      2|mlock_allocator::mlock_allocator() {
   47|      2|   const size_t mem_to_lock = OS::get_memory_locking_limit();
   48|      2|   const size_t page_size = OS::system_page_size();
   49|       |
   50|      2|   if(mem_to_lock > 0 && mem_to_lock % page_size == 0) {
  ------------------
  |  Branch (50:7): [True: 2, False: 0]
  |  Branch (50:26): [True: 2, False: 0]
  ------------------
   51|      2|      m_locked_pages = OS::allocate_locked_pages(mem_to_lock / page_size);
   52|       |
   53|      2|      if(!m_locked_pages.empty()) {
  ------------------
  |  Branch (53:10): [True: 2, False: 0]
  ------------------
   54|      2|         m_pool = std::make_unique<Memory_Pool>(m_locked_pages, page_size);
   55|      2|      }
   56|      2|   }
   57|      2|}
_ZN5Botan15mlock_allocator8instanceEv:
   74|  99.0k|mlock_allocator& mlock_allocator::instance() {
   75|  99.0k|   return g_mlock_allocator;
   76|  99.0k|}

_ZN5Botan11Memory_PoolC2ERKNSt3__16vectorIPvNS1_9allocatorIS3_EEEEm:
  295|      2|Memory_Pool::Memory_Pool(const std::vector<void*>& pages, size_t page_size) : m_page_size(page_size) {
  296|      2|   m_min_page_ptr = ~static_cast<uintptr_t>(0);
  297|      2|   m_max_page_ptr = 0;
  298|       |
  299|    256|   for(auto page : pages) {
  ------------------
  |  Branch (299:18): [True: 256, False: 2]
  ------------------
  300|    256|      const uintptr_t p = reinterpret_cast<uintptr_t>(page);
  301|       |
  302|    256|      m_min_page_ptr = std::min(p, m_min_page_ptr);
  303|    256|      m_max_page_ptr = std::max(p, m_max_page_ptr);
  304|       |
  305|    256|      clear_bytes(page, m_page_size);
  306|       |#if defined(BOTAN_MEM_POOL_USE_MMU_PROTECTIONS)
  307|       |      OS::page_prohibit_access(page);
  308|       |#endif
  309|    256|      m_free_pages.push_back(static_cast<uint8_t*>(page));
  310|    256|   }
  311|       |
  312|       |   /*
  313|       |   Right now this points to the start of the last page, adjust it to instead
  314|       |   point to the first byte of the following page
  315|       |   */
  316|      2|   m_max_page_ptr += page_size;
  317|      2|}
_ZN5Botan11Memory_Pool8allocateEm:
  328|  49.5k|void* Memory_Pool::allocate(size_t n) {
  329|  49.5k|   if(n > m_page_size) {
  ------------------
  |  Branch (329:7): [True: 0, False: 49.5k]
  ------------------
  330|      0|      return nullptr;
  331|      0|   }
  332|       |
  333|  49.5k|   const size_t n_bucket = choose_bucket(n);
  334|       |
  335|  49.5k|   if(n_bucket > 0) {
  ------------------
  |  Branch (335:7): [True: 49.5k, False: 0]
  ------------------
  336|  49.5k|      lock_guard_type<mutex_type> lock(m_mutex);
  337|       |
  338|  49.5k|      std::deque<Bucket>& buckets = m_buckets_for[n_bucket];
  339|       |
  340|       |      /*
  341|       |      It would be optimal to pick the bucket with the most usage,
  342|       |      since a bucket with say 1 item allocated out of it has a high
  343|       |      chance of becoming later freed and then the whole page can be
  344|       |      recycled.
  345|       |      */
  346|  49.5k|      for(auto& bucket : buckets) {
  ------------------
  |  Branch (346:24): [True: 33.0k, False: 16.5k]
  ------------------
  347|  33.0k|         if(uint8_t* p = bucket.alloc()) {
  ------------------
  |  Branch (347:22): [True: 33.0k, False: 0]
  ------------------
  348|  33.0k|            return p;
  349|  33.0k|         }
  350|       |
  351|       |         // If the bucket is full, maybe move it to the end of the list?
  352|       |         // Otoh bucket search should be very fast
  353|  33.0k|      }
  354|       |
  355|  16.5k|      if(!m_free_pages.empty()) {
  ------------------
  |  Branch (355:10): [True: 16.5k, False: 0]
  ------------------
  356|  16.5k|         uint8_t* ptr = m_free_pages[0];
  357|  16.5k|         m_free_pages.pop_front();
  358|       |#if defined(BOTAN_MEM_POOL_USE_MMU_PROTECTIONS)
  359|       |         OS::page_allow_access(ptr);
  360|       |#endif
  361|  16.5k|         buckets.push_front(Bucket(ptr, m_page_size, n_bucket));
  362|  16.5k|         void* p = buckets[0].alloc();
  363|  16.5k|         BOTAN_ASSERT_NOMSG(p != nullptr);
  ------------------
  |  |   64|  16.5k|   do {                                                                     \
  |  |   65|  16.5k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 16.5k]
  |  |  ------------------
  |  |   66|  16.5k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|  16.5k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  364|  16.5k|         return p;
  365|  16.5k|      }
  366|  16.5k|   }
  367|       |
  368|       |   // out of room
  369|      0|   return nullptr;
  370|  49.5k|}
_ZN5Botan11Memory_Pool10deallocateEPvm:
  372|  49.5k|bool Memory_Pool::deallocate(void* p, size_t len) noexcept {
  373|       |   // Do a fast range check first, before taking the lock
  374|  49.5k|   const uintptr_t p_val = reinterpret_cast<uintptr_t>(p);
  375|  49.5k|   if(p_val < m_min_page_ptr || p_val > m_max_page_ptr) {
  ------------------
  |  Branch (375:7): [True: 0, False: 49.5k]
  |  Branch (375:33): [True: 0, False: 49.5k]
  ------------------
  376|      0|      return false;
  377|      0|   }
  378|       |
  379|  49.5k|   const size_t n_bucket = choose_bucket(len);
  380|       |
  381|  49.5k|   if(n_bucket != 0) {
  ------------------
  |  Branch (381:7): [True: 49.5k, False: 0]
  ------------------
  382|  49.5k|      try {
  383|  49.5k|         lock_guard_type<mutex_type> lock(m_mutex);
  384|       |
  385|  49.5k|         std::deque<Bucket>& buckets = m_buckets_for[n_bucket];
  386|       |
  387|  49.5k|         for(size_t i = 0; i != buckets.size(); ++i) {
  ------------------
  |  Branch (387:28): [True: 49.5k, False: 0]
  ------------------
  388|  49.5k|            Bucket& bucket = buckets[i];
  389|  49.5k|            if(bucket.free(p)) {
  ------------------
  |  Branch (389:16): [True: 49.5k, False: 0]
  ------------------
  390|  49.5k|               if(bucket.empty()) {
  ------------------
  |  Branch (390:19): [True: 16.5k, False: 33.0k]
  ------------------
  391|       |#if defined(BOTAN_MEM_POOL_USE_MMU_PROTECTIONS)
  392|       |                  OS::page_prohibit_access(bucket.ptr());
  393|       |#endif
  394|  16.5k|                  m_free_pages.push_back(bucket.ptr());
  395|       |
  396|  16.5k|                  if(i != buckets.size() - 1) {
  ------------------
  |  Branch (396:22): [True: 0, False: 16.5k]
  ------------------
  397|      0|                     std::swap(buckets.back(), buckets[i]);
  398|      0|                  }
  399|  16.5k|                  buckets.pop_back();
  400|  16.5k|               }
  401|  49.5k|               return true;
  402|  49.5k|            }
  403|  49.5k|         }
  404|  49.5k|      } catch(...) {
  405|       |         /*
  406|       |         * The only exception throws that can occur in the above code are from
  407|       |         * either the STL or BOTAN_ASSERT failures. In either case, such an
  408|       |         * error indicates a logic error or data corruption in the memory
  409|       |         * allocator such that it is no longer safe to continue executing.
  410|       |         *
  411|       |         * Since this function is noexcept, simply letting the exception escape
  412|       |         * is sufficient for terminate to be called. However in this scenario
  413|       |         * it is implementation defined if any stack unwinding is performed.
  414|       |         * Since stack unwinding could cause further memory deallocations this
  415|       |         * could result in further corruption in this allocator state. To prevent
  416|       |         * this, call terminate directly.
  417|       |         */
  418|      0|         std::terminate();
  419|      0|      }
  420|  49.5k|   }
  421|       |
  422|      0|   return false;
  423|  49.5k|}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_113choose_bucketEm:
  110|  99.0k|size_t choose_bucket(size_t n) {
  111|  99.0k|   const size_t MINIMUM_ALLOCATION = 16;
  112|  99.0k|   const size_t MAXIMUM_ALLOCATION = 256;
  113|       |
  114|  99.0k|   if(n < MINIMUM_ALLOCATION || n > MAXIMUM_ALLOCATION) {
  ------------------
  |  Branch (114:7): [True: 0, False: 99.0k]
  |  Branch (114:33): [True: 0, False: 99.0k]
  ------------------
  115|      0|      return 0;
  116|      0|   }
  117|       |
  118|       |   // Need to tune these
  119|       |
  120|  99.0k|   const size_t buckets[] = {
  121|  99.0k|      16,
  122|  99.0k|      24,
  123|  99.0k|      32,
  124|  99.0k|      48,
  125|  99.0k|      64,
  126|  99.0k|      80,
  127|  99.0k|      96,
  128|  99.0k|      112,
  129|  99.0k|      128,
  130|  99.0k|      160,
  131|  99.0k|      192,
  132|  99.0k|      256,
  133|  99.0k|      0,
  134|  99.0k|   };
  135|       |
  136|   508k|   for(size_t i = 0; buckets[i]; ++i) {
  ------------------
  |  Branch (136:22): [True: 508k, False: 0]
  ------------------
  137|   508k|      if(n <= buckets[i]) {
  ------------------
  |  Branch (137:10): [True: 99.0k, False: 409k]
  ------------------
  138|  99.0k|         return buckets[i];
  139|  99.0k|      }
  140|   508k|   }
  141|       |
  142|      0|   return 0;
  143|  99.0k|}
_ZN5Botan6Bucket5allocEv:
  245|  49.5k|      uint8_t* alloc() {
  246|  49.5k|         if(m_is_full) {
  ------------------
  |  Branch (246:13): [True: 0, False: 49.5k]
  ------------------
  247|       |            // I know I am full
  248|      0|            return nullptr;
  249|      0|         }
  250|       |
  251|  49.5k|         size_t offset;
  252|  49.5k|         if(!m_bitmap.find_free(&offset)) {
  ------------------
  |  Branch (252:13): [True: 0, False: 49.5k]
  ------------------
  253|       |            // I just found out I am full
  254|      0|            m_is_full = true;
  255|      0|            return nullptr;
  256|      0|         }
  257|       |
  258|  49.5k|         BOTAN_ASSERT(offset * m_item_size < m_page_size, "Offset is in range");
  ------------------
  |  |   55|  49.5k|   do {                                                                                 \
  |  |   56|  49.5k|      if(!(expr))                                                                       \
  |  |  ------------------
  |  |  |  Branch (56:10): [True: 0, False: 49.5k]
  |  |  ------------------
  |  |   57|  49.5k|         Botan::assertion_failure(#expr, assertion_made, __func__, __FILE__, __LINE__); \
  |  |   58|  49.5k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (58:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  259|  49.5k|         return m_range + m_item_size * offset;
  260|  49.5k|      }
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_16BitMap9find_freeEPm:
  218|  49.5k|bool BitMap::find_free(size_t* bit) {
  219|  49.5k|   for(size_t i = 0; i != m_bits.size(); ++i) {
  ------------------
  |  Branch (219:22): [True: 49.5k, False: 0]
  ------------------
  220|  49.5k|      const bitmask_type mask = (i == m_bits.size() - 1) ? m_last_mask : m_main_mask;
  ------------------
  |  Branch (220:33): [True: 39.6k, False: 9.90k]
  ------------------
  221|  49.5k|      if((m_bits[i] & mask) != mask) {
  ------------------
  |  Branch (221:10): [True: 49.5k, False: 0]
  ------------------
  222|  49.5k|         const size_t free_bit = find_set_bit(~m_bits[i]);
  223|  49.5k|         const bitmask_type bmask = static_cast<bitmask_type>(1) << (free_bit % BITMASK_BITS);
  224|  49.5k|         BOTAN_ASSERT_NOMSG((m_bits[i] & bmask) == 0);
  ------------------
  |  |   64|  49.5k|   do {                                                                     \
  |  |   65|  49.5k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 49.5k]
  |  |  ------------------
  |  |   66|  49.5k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|  49.5k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  225|  49.5k|         m_bits[i] |= bmask;
  226|  49.5k|         *bit = BITMASK_BITS * i + free_bit;
  227|  49.5k|         return true;
  228|  49.5k|      }
  229|  49.5k|   }
  230|       |
  231|      0|   return false;
  232|  49.5k|}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_112find_set_bitImEEmT_:
  153|  49.5k|size_t find_set_bit(T b) {
  154|  49.5k|   size_t s = 8 * sizeof(T) / 2;
  155|  49.5k|   size_t bit = 0;
  156|       |
  157|       |   // In this context we don't need to be const-time
  158|   346k|   while(s > 0) {
  ------------------
  |  Branch (158:10): [True: 297k, False: 49.5k]
  ------------------
  159|   297k|      const T mask = (static_cast<T>(1) << s) - 1;
  160|   297k|      if((b & mask) == 0) {
  ------------------
  |  Branch (160:10): [True: 46.2k, False: 250k]
  ------------------
  161|  46.2k|         bit += s;
  162|  46.2k|         b >>= s;
  163|  46.2k|      }
  164|   297k|      s /= 2;
  165|   297k|   }
  166|       |
  167|  49.5k|   return bit;
  168|  49.5k|}
_ZN5Botan6BucketC2EPhmm:
  239|  16.5k|            m_item_size(item_size),
  240|  16.5k|            m_page_size(mem_size),
  241|  16.5k|            m_range(mem),
  242|  16.5k|            m_bitmap(mem_size / item_size),
  243|  16.5k|            m_is_full(false) {}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_16BitMapC2Em:
  172|  16.5k|      explicit BitMap(size_t bits) : m_len(bits) {
  173|  16.5k|         m_bits.resize((bits + BITMASK_BITS - 1) / BITMASK_BITS);
  174|       |         // MSVC warns if the cast isn't there, clang-tidy warns that the cast is pointless
  175|  16.5k|         m_main_mask = static_cast<bitmask_type>(~0);  // NOLINT(bugprone-misplaced-widening-cast)
  176|  16.5k|         m_last_mask = m_main_mask;
  177|       |
  178|  16.5k|         if(bits % BITMASK_BITS != 0) {
  ------------------
  |  Branch (178:13): [True: 3.30k, False: 13.2k]
  ------------------
  179|  3.30k|            m_last_mask = (static_cast<bitmask_type>(1) << (bits % BITMASK_BITS)) - 1;
  180|  3.30k|         }
  181|  16.5k|      }
_ZN5Botan6Bucket4freeEPv:
  262|  49.5k|      bool free(void* p) {
  263|  49.5k|         if(!in_this_bucket(p)) {
  ------------------
  |  Branch (263:13): [True: 0, False: 49.5k]
  ------------------
  264|      0|            return false;
  265|      0|         }
  266|       |
  267|       |         /*
  268|       |         Zero also any trailing bytes, which should not have been written to,
  269|       |         but maybe the user was bad and wrote past the end.
  270|       |         */
  271|  49.5k|         std::memset(p, 0, m_item_size);
  272|       |
  273|  49.5k|         const size_t offset = (reinterpret_cast<uintptr_t>(p) - reinterpret_cast<uintptr_t>(m_range)) / m_item_size;
  274|       |
  275|  49.5k|         m_bitmap.free(offset);
  276|  49.5k|         m_is_full = false;
  277|       |
  278|  49.5k|         return true;
  279|  49.5k|      }
_ZNK5Botan6Bucket14in_this_bucketEPv:
  281|  49.5k|      bool in_this_bucket(void* p) const { return ptr_in_pool(m_range, m_page_size, p, m_item_size); }
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_111ptr_in_poolEPKvmS2_m:
  145|  49.5k|inline bool ptr_in_pool(const void* pool_ptr, size_t poolsize, const void* buf_ptr, size_t bufsize) {
  146|  49.5k|   const uintptr_t pool = reinterpret_cast<uintptr_t>(pool_ptr);
  147|  49.5k|   const uintptr_t buf = reinterpret_cast<uintptr_t>(buf_ptr);
  148|  49.5k|   return (buf >= pool) && (buf + bufsize <= pool + poolsize);
  ------------------
  |  Branch (148:11): [True: 49.5k, False: 0]
  |  Branch (148:28): [True: 49.5k, False: 0]
  ------------------
  149|  49.5k|}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_16BitMap4freeEm:
  185|  49.5k|      void free(size_t bit) {
  186|  49.5k|         BOTAN_ASSERT_NOMSG(bit <= m_len);
  ------------------
  |  |   64|  49.5k|   do {                                                                     \
  |  |   65|  49.5k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 49.5k]
  |  |  ------------------
  |  |   66|  49.5k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|  49.5k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  187|  49.5k|         const size_t w = bit / BITMASK_BITS;
  188|  49.5k|         BOTAN_ASSERT_NOMSG(w < m_bits.size());
  ------------------
  |  |   64|  49.5k|   do {                                                                     \
  |  |   65|  49.5k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (65:10): [True: 0, False: 49.5k]
  |  |  ------------------
  |  |   66|  49.5k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   67|  49.5k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (67:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  189|  49.5k|         const bitmask_type mask = static_cast<bitmask_type>(1) << (bit % BITMASK_BITS);
  190|  49.5k|         m_bits[w] = m_bits[w] & (~mask);
  191|  49.5k|      }
_ZNK5Botan6Bucket5emptyEv:
  283|  49.5k|      bool empty() const { return m_bitmap.empty(); }
mem_pool.cpp:_ZNK5Botan12_GLOBAL__N_16BitMap5emptyEv:
  193|  49.5k|      bool empty() const {
  194|  59.4k|         for(auto bitset : m_bits) {
  ------------------
  |  Branch (194:26): [True: 59.4k, False: 16.5k]
  ------------------
  195|  59.4k|            if(bitset != 0) {
  ------------------
  |  Branch (195:16): [True: 33.0k, False: 26.4k]
  ------------------
  196|  33.0k|               return false;
  197|  33.0k|            }
  198|  59.4k|         }
  199|       |
  200|  16.5k|         return true;
  201|  49.5k|      }
_ZNK5Botan6Bucket3ptrEv:
  285|  16.5k|      uint8_t* ptr() const { return m_range; }

_ZN5Botan19secure_scrub_memoryEPvm:
   24|  69.3k|void secure_scrub_memory(void* ptr, size_t n) {
   25|       |#if defined(BOTAN_TARGET_OS_HAS_RTLSECUREZEROMEMORY)
   26|       |   ::RtlSecureZeroMemory(ptr, n);
   27|       |
   28|       |#elif defined(BOTAN_TARGET_OS_HAS_EXPLICIT_BZERO)
   29|       |   ::explicit_bzero(ptr, n);
   30|       |
   31|       |#elif defined(BOTAN_TARGET_OS_HAS_EXPLICIT_MEMSET)
   32|       |   (void)::explicit_memset(ptr, 0, n);
   33|       |
   34|       |#else
   35|       |   /*
   36|       |   * Call memset through a static volatile pointer, which the compiler should
   37|       |   * not elide. This construct should be safe in conforming compilers, but who
   38|       |   * knows. This has been checked to generate the expected code, which saves the
   39|       |   * memset address in the data segment and unconditionally loads and jumps to
   40|       |   * that address, with the following targets:
   41|       |   *
   42|       |   * x86-64: Clang 19, GCC 6, 11, 13, 14
   43|       |   * riscv64: GCC 14
   44|       |   * aarch64: GCC 14
   45|       |   * armv7: GCC 14
   46|       |   *
   47|       |   * Actually all of them generated the expected jump even without marking the
   48|       |   * function pointer as volatile. However this seems worth including as an
   49|       |   * additional precaution.
   50|       |   */
   51|       |   static void* (*const volatile memset_ptr)(void*, int, size_t) = std::memset;
   52|       |   (memset_ptr)(ptr, 0, n);
   53|       |#endif
   54|  69.3k|}

_ZN5Botan2OS14get_process_idEv:
   77|  16.5k|uint32_t OS::get_process_id() {
   78|  16.5k|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
   79|  16.5k|   return ::getpid();
   80|       |#elif defined(BOTAN_TARGET_OS_HAS_WIN32)
   81|       |   return ::GetCurrentProcessId();
   82|       |#elif defined(BOTAN_TARGET_OS_IS_LLVM) || defined(BOTAN_TARGET_OS_IS_NONE)
   83|       |   return 0;  // truly no meaningful value
   84|       |#else
   85|       |   #error "Missing get_process_id"
   86|       |#endif
   87|  16.5k|}
_ZN5Botan2OS21get_cpu_cycle_counterEv:
  169|  6.60k|uint64_t OS::get_cpu_cycle_counter() {
  170|  6.60k|   uint64_t rtc = 0;
  171|       |
  172|       |#if defined(BOTAN_TARGET_OS_HAS_WIN32)
  173|       |   LARGE_INTEGER tv;
  174|       |   ::QueryPerformanceCounter(&tv);
  175|       |   rtc = tv.QuadPart;
  176|       |
  177|       |#elif defined(BOTAN_USE_GCC_INLINE_ASM)
  178|       |
  179|  6.60k|   #if defined(BOTAN_TARGET_ARCH_IS_X86_64)
  180|       |
  181|  6.60k|   uint32_t rtc_low = 0, rtc_high = 0;
  182|  6.60k|   asm volatile("rdtsc" : "=d"(rtc_high), "=a"(rtc_low));
  183|  6.60k|   rtc = (static_cast<uint64_t>(rtc_high) << 32) | rtc_low;
  184|       |
  185|       |   #elif defined(BOTAN_TARGET_CPU_IS_X86_FAMILY) && defined(BOTAN_HAS_CPUID)
  186|       |
  187|       |   if(CPUID::has(CPUID::Feature::RDTSC)) {
  188|       |      uint32_t rtc_low = 0, rtc_high = 0;
  189|       |      asm volatile("rdtsc" : "=d"(rtc_high), "=a"(rtc_low));
  190|       |      rtc = (static_cast<uint64_t>(rtc_high) << 32) | rtc_low;
  191|       |   }
  192|       |
  193|       |   #elif defined(BOTAN_TARGET_ARCH_IS_PPC64)
  194|       |
  195|       |   for(;;) {
  196|       |      uint32_t rtc_low = 0, rtc_high = 0, rtc_high2 = 0;
  197|       |      asm volatile("mftbu %0" : "=r"(rtc_high));
  198|       |      asm volatile("mftb %0" : "=r"(rtc_low));
  199|       |      asm volatile("mftbu %0" : "=r"(rtc_high2));
  200|       |
  201|       |      if(rtc_high == rtc_high2) {
  202|       |         rtc = (static_cast<uint64_t>(rtc_high) << 32) | rtc_low;
  203|       |         break;
  204|       |      }
  205|       |   }
  206|       |
  207|       |   #elif defined(BOTAN_TARGET_ARCH_IS_ALPHA)
  208|       |   asm volatile("rpcc %0" : "=r"(rtc));
  209|       |
  210|       |      // OpenBSD does not trap access to the %tick register
  211|       |   #elif defined(BOTAN_TARGET_ARCH_IS_SPARC64) && !defined(BOTAN_TARGET_OS_IS_OPENBSD)
  212|       |   asm volatile("rd %%tick, %0" : "=r"(rtc));
  213|       |
  214|       |   #elif defined(BOTAN_TARGET_ARCH_IS_IA64)
  215|       |   asm volatile("mov %0=ar.itc" : "=r"(rtc));
  216|       |
  217|       |   #elif defined(BOTAN_TARGET_ARCH_IS_S390X)
  218|       |   asm volatile("stck 0(%0)" : : "a"(&rtc) : "memory", "cc");
  219|       |
  220|       |   #elif defined(BOTAN_TARGET_ARCH_IS_HPPA)
  221|       |   asm volatile("mfctl 16,%0" : "=r"(rtc));  // 64-bit only?
  222|       |
  223|       |   #else
  224|       |      //#warning "OS::get_cpu_cycle_counter not implemented"
  225|       |   #endif
  226|       |
  227|  6.60k|#endif
  228|       |
  229|  6.60k|   return rtc;
  230|  6.60k|}
_ZN5Botan2OS25get_high_resolution_clockEv:
  264|  6.60k|uint64_t OS::get_high_resolution_clock() {
  265|  6.60k|   if(uint64_t cpu_clock = OS::get_cpu_cycle_counter()) {
  ------------------
  |  Branch (265:16): [True: 6.60k, False: 0]
  ------------------
  266|  6.60k|      return cpu_clock;
  267|  6.60k|   }
  268|       |
  269|       |#if defined(BOTAN_TARGET_OS_IS_EMSCRIPTEN)
  270|       |   return emscripten_get_now();
  271|       |#endif
  272|       |
  273|       |   /*
  274|       |   If we got here either we either don't have an asm instruction
  275|       |   above, or (for x86) RDTSC is not available at runtime. Try some
  276|       |   clock_gettimes and return the first one that works, or otherwise
  277|       |   fall back to std::chrono.
  278|       |   */
  279|       |
  280|      0|#if defined(BOTAN_TARGET_OS_HAS_CLOCK_GETTIME)
  281|       |
  282|       |   // The ordering here is somewhat arbitrary...
  283|      0|   const clockid_t clock_types[] = {
  284|       |   #if defined(CLOCK_MONOTONIC_HR)
  285|       |      CLOCK_MONOTONIC_HR,
  286|       |   #endif
  287|      0|   #if defined(CLOCK_MONOTONIC_RAW)
  288|      0|      CLOCK_MONOTONIC_RAW,
  289|      0|   #endif
  290|      0|   #if defined(CLOCK_MONOTONIC)
  291|      0|      CLOCK_MONOTONIC,
  292|      0|   #endif
  293|      0|   #if defined(CLOCK_PROCESS_CPUTIME_ID)
  294|      0|      CLOCK_PROCESS_CPUTIME_ID,
  295|      0|   #endif
  296|      0|   #if defined(CLOCK_THREAD_CPUTIME_ID)
  297|      0|      CLOCK_THREAD_CPUTIME_ID,
  298|      0|   #endif
  299|      0|   };
  300|       |
  301|      0|   for(clockid_t clock : clock_types) {
  ------------------
  |  Branch (301:24): [True: 0, False: 0]
  ------------------
  302|      0|      struct timespec ts;
  303|      0|      if(::clock_gettime(clock, &ts) == 0) {
  ------------------
  |  Branch (303:10): [True: 0, False: 0]
  ------------------
  304|      0|         return (static_cast<uint64_t>(ts.tv_sec) * 1000000000) + static_cast<uint64_t>(ts.tv_nsec);
  305|      0|      }
  306|      0|   }
  307|      0|#endif
  308|       |
  309|      0|#if defined(BOTAN_TARGET_OS_HAS_SYSTEM_CLOCK)
  310|       |   // Plain C++11 fallback
  311|      0|   auto now = std::chrono::high_resolution_clock::now().time_since_epoch();
  312|      0|   return std::chrono::duration_cast<std::chrono::nanoseconds>(now).count();
  313|       |#else
  314|       |   return 0;
  315|       |#endif
  316|      0|}
_ZN5Botan2OS16system_page_sizeEv:
  354|    516|size_t OS::system_page_size() {
  355|    516|   const size_t default_page_size = 4096;
  356|       |
  357|    516|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
  358|    516|   long p = ::sysconf(_SC_PAGESIZE);
  359|    516|   if(p > 1) {
  ------------------
  |  Branch (359:7): [True: 516, False: 0]
  ------------------
  360|    516|      return static_cast<size_t>(p);
  361|    516|   } else {
  362|      0|      return default_page_size;
  363|      0|   }
  364|       |#elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  365|       |   BOTAN_UNUSED(default_page_size);
  366|       |   SYSTEM_INFO sys_info;
  367|       |   ::GetSystemInfo(&sys_info);
  368|       |   return sys_info.dwPageSize;
  369|       |#else
  370|       |   return default_page_size;
  371|       |#endif
  372|    516|}
_ZN5Botan2OS24get_memory_locking_limitEv:
  374|      2|size_t OS::get_memory_locking_limit() {
  375|       |   /*
  376|       |   * Linux defaults to only 64 KiB of mlockable memory per process (too small)
  377|       |   * but BSDs offer a small fraction of total RAM (more than we need). Bound the
  378|       |   * total mlock size to 512 KiB which is enough to run the entire test suite
  379|       |   * without spilling to non-mlock memory (and thus presumably also enough for
  380|       |   * many useful programs), but small enough that we should not cause problems
  381|       |   * even if many processes are mlocking on the same machine.
  382|       |   */
  383|      2|   const size_t max_locked_kb = 512;
  384|       |
  385|       |   /*
  386|       |   * If RLIMIT_MEMLOCK is not defined, likely the OS does not support
  387|       |   * unprivileged mlock calls.
  388|       |   */
  389|      2|#if defined(RLIMIT_MEMLOCK) && defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)
  390|      2|   const size_t mlock_requested =
  391|      2|      std::min<size_t>(read_env_variable_sz("BOTAN_MLOCK_POOL_SIZE", max_locked_kb), max_locked_kb);
  392|       |
  393|      2|   if(mlock_requested > 0) {
  ------------------
  |  Branch (393:7): [True: 2, False: 0]
  ------------------
  394|      2|      struct ::rlimit limits;
  395|       |
  396|      2|      ::getrlimit(RLIMIT_MEMLOCK, &limits);
  397|       |
  398|      2|      if(limits.rlim_cur < limits.rlim_max) {
  ------------------
  |  Branch (398:10): [True: 0, False: 2]
  ------------------
  399|      0|         limits.rlim_cur = limits.rlim_max;
  400|      0|         ::setrlimit(RLIMIT_MEMLOCK, &limits);
  401|      0|         ::getrlimit(RLIMIT_MEMLOCK, &limits);
  402|      0|      }
  403|       |
  404|      2|      return std::min<size_t>(limits.rlim_cur, mlock_requested * 1024);
  405|      2|   }
  406|       |
  407|       |#elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  408|       |   const size_t mlock_requested =
  409|       |      std::min<size_t>(read_env_variable_sz("BOTAN_MLOCK_POOL_SIZE", max_locked_kb), max_locked_kb);
  410|       |
  411|       |   SIZE_T working_min = 0, working_max = 0;
  412|       |   if(!::GetProcessWorkingSetSize(::GetCurrentProcess(), &working_min, &working_max)) {
  413|       |      return 0;
  414|       |   }
  415|       |
  416|       |   // According to Microsoft MSDN:
  417|       |   // The maximum number of pages that a process can lock is equal to the number of pages in its minimum working set minus a small overhead
  418|       |   // In the book "Windows Internals Part 2": the maximum lockable pages are minimum working set size - 8 pages
  419|       |   // But the information in the book seems to be inaccurate/outdated
  420|       |   // I've tested this on Windows 8.1 x64, Windows 10 x64 and Windows 7 x86
  421|       |   // On all three OS the value is 11 instead of 8
  422|       |   const size_t overhead = OS::system_page_size() * 11;
  423|       |   if(working_min > overhead) {
  424|       |      const size_t lockable_bytes = working_min - overhead;
  425|       |      return std::min<size_t>(lockable_bytes, mlock_requested * 1024);
  426|       |   }
  427|       |#else
  428|       |   // Not supported on this platform
  429|       |   BOTAN_UNUSED(max_locked_kb);
  430|       |#endif
  431|       |
  432|      0|   return 0;
  433|      2|}
_ZN5Botan2OS17read_env_variableERNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS1_17basic_string_viewIcS4_EE:
  435|      3|bool OS::read_env_variable(std::string& value_out, std::string_view name_view) {
  436|      3|   value_out = "";
  437|       |
  438|      3|   if(running_in_privileged_state()) {
  ------------------
  |  Branch (438:7): [True: 0, False: 3]
  ------------------
  439|      0|      return false;
  440|      0|   }
  441|       |
  442|       |#if defined(BOTAN_TARGET_OS_HAS_WIN32) && defined(BOTAN_BUILD_COMPILER_IS_MSVC)
  443|       |   const std::string name(name_view);
  444|       |   char val[128] = {0};
  445|       |   size_t req_size = 0;
  446|       |   if(getenv_s(&req_size, val, sizeof(val), name.c_str()) == 0) {
  447|       |      // Microsoft's implementation always writes a terminating \0,
  448|       |      // and includes it in the reported length of the environment variable
  449|       |      // if a value exists.
  450|       |      if(req_size > 0 && val[req_size - 1] == '\0') {
  451|       |         value_out = std::string(val);
  452|       |      } else {
  453|       |         value_out = std::string(val, req_size);
  454|       |      }
  455|       |      return true;
  456|       |   }
  457|       |#else
  458|      3|   const std::string name(name_view);
  459|      3|   if(const char* val = std::getenv(name.c_str())) {
  ------------------
  |  Branch (459:19): [True: 0, False: 3]
  ------------------
  460|      0|      value_out = val;
  461|      0|      return true;
  462|      0|   }
  463|      3|#endif
  464|       |
  465|      3|   return false;
  466|      3|}
_ZN5Botan2OS20read_env_variable_szENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEEm:
  468|      2|size_t OS::read_env_variable_sz(std::string_view name, size_t def) {
  469|      2|   std::string value;
  470|      2|   if(read_env_variable(value, name) && !value.empty()) {
  ------------------
  |  Branch (470:7): [True: 0, False: 2]
  |  Branch (470:41): [True: 0, False: 0]
  ------------------
  471|      0|      try {
  472|      0|         const size_t val = std::stoul(value, nullptr);
  473|      0|         return val;
  474|      0|      } catch(std::exception&) { /* ignore it */
  475|      0|      }
  476|      0|   }
  477|       |
  478|      2|   return def;
  479|      2|}
_ZN5Botan2OS21allocate_locked_pagesEm:
  508|      2|std::vector<void*> OS::allocate_locked_pages(size_t count) {
  509|      2|   std::vector<void*> result;
  510|       |
  511|      2|#if(defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)) || \
  512|      2|   defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  513|       |
  514|      2|   result.reserve(count);
  515|       |
  516|      2|   const size_t page_size = OS::system_page_size();
  517|       |
  518|      2|   #if defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)
  519|      2|   static const int locked_fd = get_locked_fd();
  520|      2|   #endif
  521|       |
  522|    258|   for(size_t i = 0; i != count; ++i) {
  ------------------
  |  Branch (522:22): [True: 256, False: 2]
  ------------------
  523|    256|      void* ptr = nullptr;
  524|       |
  525|    256|   #if defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)
  526|       |
  527|    256|      int mmap_flags = MAP_PRIVATE;
  528|       |
  529|    256|      #if defined(MAP_ANONYMOUS)
  530|    256|      mmap_flags |= MAP_ANONYMOUS;
  531|       |      #elif defined(MAP_ANON)
  532|       |      mmap_flags |= MAP_ANON;
  533|       |      #endif
  534|       |
  535|       |      #if defined(MAP_CONCEAL)
  536|       |      mmap_flags |= MAP_CONCEAL;
  537|       |      #elif defined(MAP_NOCORE)
  538|       |      mmap_flags |= MAP_NOCORE;
  539|       |      #endif
  540|       |
  541|    256|      int mmap_prot = PROT_READ | PROT_WRITE;
  542|       |
  543|       |      #if defined(PROT_MAX)
  544|       |      mmap_prot |= PROT_MAX(mmap_prot);
  545|       |      #endif
  546|       |
  547|    256|      ptr = ::mmap(nullptr,
  548|    256|                   3 * page_size,
  549|    256|                   mmap_prot,
  550|    256|                   mmap_flags,
  551|    256|                   /*fd=*/locked_fd,
  552|    256|                   /*offset=*/0);
  553|       |
  554|    256|      if(ptr == MAP_FAILED) {
  ------------------
  |  Branch (554:10): [True: 0, False: 256]
  ------------------
  555|      0|         continue;
  556|      0|      }
  557|       |
  558|       |      // lock the data page
  559|    256|      if(::mlock(static_cast<uint8_t*>(ptr) + page_size, page_size) != 0) {
  ------------------
  |  Branch (559:10): [True: 0, False: 256]
  ------------------
  560|      0|         ::munmap(ptr, 3 * page_size);
  561|      0|         continue;
  562|      0|      }
  563|       |
  564|    256|      #if defined(MADV_DONTDUMP)
  565|       |      // we ignore errors here, as DONTDUMP is just a bonus
  566|    256|      ::madvise(static_cast<uint8_t*>(ptr) + page_size, page_size, MADV_DONTDUMP);
  567|    256|      #endif
  568|       |
  569|       |   #elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  570|       |      ptr = ::VirtualAlloc(nullptr, 3 * page_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  571|       |
  572|       |      if(ptr == nullptr)
  573|       |         continue;
  574|       |
  575|       |      if(::VirtualLock(static_cast<uint8_t*>(ptr) + page_size, page_size) == 0) {
  576|       |         ::VirtualFree(ptr, 0, MEM_RELEASE);
  577|       |         continue;
  578|       |      }
  579|       |   #endif
  580|       |
  581|    256|      std::memset(ptr, 0, 3 * page_size);  // zero data page and both guard pages
  582|       |
  583|       |      // Attempts to name the data page
  584|    256|      page_named(ptr, 3 * page_size);
  585|       |      // Make guard page preceeding the data page
  586|    256|      page_prohibit_access(static_cast<uint8_t*>(ptr));
  587|       |      // Make guard page following the data page
  588|    256|      page_prohibit_access(static_cast<uint8_t*>(ptr) + 2 * page_size);
  589|       |
  590|    256|      result.push_back(static_cast<uint8_t*>(ptr) + page_size);
  591|    256|   }
  592|       |#else
  593|       |   BOTAN_UNUSED(count);
  594|       |#endif
  595|       |
  596|      2|   return result;
  597|      2|}
_ZN5Botan2OS20page_prohibit_accessEPv:
  613|    512|void OS::page_prohibit_access(void* page) {
  614|    512|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
  615|    512|   const size_t page_size = OS::system_page_size();
  616|    512|   ::mprotect(page, page_size, PROT_NONE);
  617|       |#elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  618|       |   const size_t page_size = OS::system_page_size();
  619|       |   DWORD old_perms = 0;
  620|       |   ::VirtualProtect(page, page_size, PAGE_NOACCESS, &old_perms);
  621|       |   BOTAN_UNUSED(old_perms);
  622|       |#else
  623|       |   BOTAN_UNUSED(page);
  624|       |#endif
  625|    512|}
_ZN5Botan2OS10page_namedEPvm:
  649|    256|void OS::page_named(void* page, size_t size) {
  650|       |#if defined(BOTAN_TARGET_OS_HAS_PRCTL) && defined(PR_SET_VMA) && defined(PR_SET_VMA_ANON_NAME)
  651|       |   static constexpr char name[] = "Botan mlock pool";
  652|       |   int r = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, reinterpret_cast<uintptr_t>(page), size, name);
  653|       |   BOTAN_UNUSED(r);
  654|       |#else
  655|    256|   BOTAN_UNUSED(page, size);
  ------------------
  |  |  122|    256|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
  656|    256|#endif
  657|    256|}
os_utils.cpp:_ZN5Botan12_GLOBAL__N_110get_auxvalENSt3__18optionalImEE:
  119|      3|std::optional<unsigned long> get_auxval(std::optional<unsigned long> id) {
  120|      3|   if(id) {
  ------------------
  |  Branch (120:7): [True: 3, False: 0]
  ------------------
  121|      3|#if defined(BOTAN_TARGET_OS_HAS_GETAUXVAL)
  122|      3|      return ::getauxval(*id);
  123|       |#elif defined(BOTAN_TARGET_OS_HAS_ELF_AUX_INFO)
  124|       |      unsigned long auxinfo = 0;
  125|       |      if(::elf_aux_info(static_cast<int>(*id), &auxinfo, sizeof(auxinfo)) == 0) {
  126|       |         return auxinfo;
  127|       |      }
  128|       |#endif
  129|      3|   }
  130|       |
  131|      0|   return {};
  132|      3|}
os_utils.cpp:_ZN5Botan12_GLOBAL__N_127running_in_privileged_stateEv:
  153|      3|bool running_in_privileged_state() {
  154|      3|#if defined(AT_SECURE)
  155|      3|   if(auto at_secure = get_auxval(AT_SECURE)) {
  ------------------
  |  Branch (155:12): [True: 3, False: 0]
  ------------------
  156|      3|      return at_secure != 0;
  157|      3|   }
  158|      0|#endif
  159|       |
  160|      0|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
  161|      0|   return (::getuid() != ::geteuid()) || (::getgid() != ::getegid());
  ------------------
  |  Branch (161:11): [True: 0, False: 0]
  |  Branch (161:42): [True: 0, False: 0]
  ------------------
  162|       |#else
  163|       |   return false;
  164|       |#endif
  165|      3|}
os_utils.cpp:_ZN5Botan12_GLOBAL__N_113get_locked_fdEv:
  485|      2|int get_locked_fd() {
  486|       |   #if defined(BOTAN_TARGET_OS_IS_IOS) || defined(BOTAN_TARGET_OS_IS_MACOS)
  487|       |   // On Darwin, tagging anonymous pages allows vmmap to track these.
  488|       |   // Allowed from 240 to 255 for userland applications
  489|       |   static constexpr int default_locked_fd = 255;
  490|       |   int locked_fd = default_locked_fd;
  491|       |
  492|       |   if(size_t locked_fdl = OS::read_env_variable_sz("BOTAN_LOCKED_FD", default_locked_fd)) {
  493|       |      if(locked_fdl < 240 || locked_fdl > 255) {
  494|       |         locked_fdl = default_locked_fd;
  495|       |      }
  496|       |      locked_fd = static_cast<int>(locked_fdl);
  497|       |   }
  498|       |   return VM_MAKE_TAG(locked_fd);
  499|       |   #else
  500|      2|   return -1;
  501|      2|   #endif
  502|      2|}

_ZN5Botan9SCAN_NameC2ENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
   58|  3.30k|SCAN_Name::SCAN_Name(std::string_view algo_spec) : m_orig_algo_spec(algo_spec), m_alg_name(), m_args(), m_mode_info() {
   59|  3.30k|   if(algo_spec.empty()) {
  ------------------
  |  Branch (59:7): [True: 0, False: 3.30k]
  ------------------
   60|      0|      throw Invalid_Argument("Expected algorithm name, got empty string");
   61|      0|   }
   62|       |
   63|  3.30k|   std::vector<std::pair<size_t, std::string>> name;
   64|  3.30k|   size_t level = 0;
   65|  3.30k|   std::pair<size_t, std::string> accum = std::make_pair(level, "");
   66|       |
   67|  3.30k|   const std::string decoding_error = "Bad SCAN name '" + m_orig_algo_spec + "': ";
   68|       |
   69|  42.9k|   for(char c : algo_spec) {
  ------------------
  |  Branch (69:15): [True: 42.9k, False: 3.30k]
  ------------------
   70|  42.9k|      if(c == '/' || c == ',' || c == '(' || c == ')') {
  ------------------
  |  Branch (70:10): [True: 0, False: 42.9k]
  |  Branch (70:22): [True: 0, False: 42.9k]
  |  Branch (70:34): [True: 3.30k, False: 39.6k]
  |  Branch (70:46): [True: 3.30k, False: 36.3k]
  ------------------
   71|  6.60k|         if(c == '(') {
  ------------------
  |  Branch (71:13): [True: 3.30k, False: 3.30k]
  ------------------
   72|  3.30k|            ++level;
   73|  3.30k|         } else if(c == ')') {
  ------------------
  |  Branch (73:20): [True: 3.30k, False: 0]
  ------------------
   74|  3.30k|            if(level == 0) {
  ------------------
  |  Branch (74:16): [True: 0, False: 3.30k]
  ------------------
   75|      0|               throw Decoding_Error(decoding_error + "Mismatched parens");
   76|      0|            }
   77|  3.30k|            --level;
   78|  3.30k|         }
   79|       |
   80|  6.60k|         if(c == '/' && level > 0) {
  ------------------
  |  Branch (80:13): [True: 0, False: 6.60k]
  |  Branch (80:25): [True: 0, False: 0]
  ------------------
   81|      0|            accum.second.push_back(c);
   82|  6.60k|         } else {
   83|  6.60k|            if(!accum.second.empty()) {
  ------------------
  |  Branch (83:16): [True: 6.60k, False: 0]
  ------------------
   84|  6.60k|               name.push_back(accum);
   85|  6.60k|            }
   86|  6.60k|            accum = std::make_pair(level, "");
   87|  6.60k|         }
   88|  36.3k|      } else {
   89|  36.3k|         accum.second.push_back(c);
   90|  36.3k|      }
   91|  42.9k|   }
   92|       |
   93|  3.30k|   if(!accum.second.empty()) {
  ------------------
  |  Branch (93:7): [True: 0, False: 3.30k]
  ------------------
   94|      0|      name.push_back(accum);
   95|      0|   }
   96|       |
   97|  3.30k|   if(level != 0) {
  ------------------
  |  Branch (97:7): [True: 0, False: 3.30k]
  ------------------
   98|      0|      throw Decoding_Error(decoding_error + "Missing close paren");
   99|      0|   }
  100|       |
  101|  3.30k|   if(name.empty()) {
  ------------------
  |  Branch (101:7): [True: 0, False: 3.30k]
  ------------------
  102|      0|      throw Decoding_Error(decoding_error + "Empty name");
  103|      0|   }
  104|       |
  105|  3.30k|   m_alg_name = name[0].second;
  106|       |
  107|  3.30k|   bool in_modes = false;
  108|       |
  109|  6.60k|   for(size_t i = 1; i != name.size(); ++i) {
  ------------------
  |  Branch (109:22): [True: 3.30k, False: 3.30k]
  ------------------
  110|  3.30k|      if(name[i].first == 0) {
  ------------------
  |  Branch (110:10): [True: 0, False: 3.30k]
  ------------------
  111|      0|         m_mode_info.push_back(make_arg(name, i));
  112|      0|         in_modes = true;
  113|  3.30k|      } else if(name[i].first == 1 && !in_modes) {
  ------------------
  |  Branch (113:17): [True: 3.30k, False: 0]
  |  Branch (113:39): [True: 3.30k, False: 0]
  ------------------
  114|  3.30k|         m_args.push_back(make_arg(name, i));
  115|  3.30k|      }
  116|  3.30k|   }
  117|  3.30k|}
_ZNK5Botan9SCAN_Name3argEm:
  119|  3.30k|std::string SCAN_Name::arg(size_t i) const {
  120|  3.30k|   if(i >= arg_count()) {
  ------------------
  |  Branch (120:7): [True: 0, False: 3.30k]
  ------------------
  121|      0|      throw Invalid_Argument("SCAN_Name::arg " + std::to_string(i) + " out of range for '" + to_string() + "'");
  122|      0|   }
  123|  3.30k|   return m_args[i];
  124|  3.30k|}
scan_name.cpp:_ZN5Botan12_GLOBAL__N_18make_argERKNSt3__16vectorINS1_4pairImNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEENS7_ISA_EEEEm:
   17|  3.30k|std::string make_arg(const std::vector<std::pair<size_t, std::string>>& name, size_t start) {
   18|  3.30k|   std::string output = name[start].second;
   19|  3.30k|   size_t level = name[start].first;
   20|       |
   21|  3.30k|   size_t paren_depth = 0;
   22|       |
   23|  3.30k|   for(size_t i = start + 1; i != name.size(); ++i) {
  ------------------
  |  Branch (23:30): [True: 0, False: 3.30k]
  ------------------
   24|      0|      if(name[i].first <= name[start].first) {
  ------------------
  |  Branch (24:10): [True: 0, False: 0]
  ------------------
   25|      0|         break;
   26|      0|      }
   27|       |
   28|      0|      if(name[i].first > level) {
  ------------------
  |  Branch (28:10): [True: 0, False: 0]
  ------------------
   29|      0|         output += "(" + name[i].second;
   30|      0|         ++paren_depth;
   31|      0|      } else if(name[i].first < level) {
  ------------------
  |  Branch (31:17): [True: 0, False: 0]
  ------------------
   32|      0|         for(size_t j = name[i].first; j < level; j++) {
  ------------------
  |  Branch (32:40): [True: 0, False: 0]
  ------------------
   33|      0|            output += ")";
   34|      0|            --paren_depth;
   35|      0|         }
   36|      0|         output += "," + name[i].second;
   37|      0|      } else {
   38|      0|         if(output[output.size() - 1] != '(') {
  ------------------
  |  Branch (38:13): [True: 0, False: 0]
  ------------------
   39|      0|            output += ",";
   40|      0|         }
   41|      0|         output += name[i].second;
   42|      0|      }
   43|       |
   44|      0|      level = name[i].first;
   45|      0|   }
   46|       |
   47|  3.30k|   for(size_t i = 0; i != paren_depth; ++i) {
  ------------------
  |  Branch (47:22): [True: 0, False: 3.30k]
  ------------------
   48|      0|      output += ")";
   49|      0|   }
   50|       |
   51|  3.30k|   return output;
   52|  3.30k|}

LLVMFuzzerInitialize:
    9|      2|extern "C" int LLVMFuzzerInitialize() { return 0; }
LLVMFuzzerTestOneInput:
   12|  3.30k|{
   13|  3.30k|    if (Size == 0)
  ------------------
  |  Branch (13:9): [True: 0, False: 3.30k]
  ------------------
   14|      0|    {
   15|      0|        return -1;
   16|      0|    }
   17|       |
   18|  3.30k|    spank_olm::Account account;
   19|  3.30k|    Botan::AutoSeeded_RNG rng;
   20|  3.30k|    account.new_account(rng);
   21|       |
   22|  3.30k|    const std::string_view message(reinterpret_cast<const char *>(Data), Size);
   23|  3.30k|    auto signature = account.sign(rng, message);
   24|       |
   25|       |    // Verify the signature
   26|  3.30k|    Botan::PK_Verifier verifier(account.identity_keys->ed25519_key, "Ed25519ph");
   27|  3.30k|    verifier.update(message);
   28|  3.30k|    assert(verifier.check_signature(signature));
   29|       |
   30|  3.30k|    return 0;
   31|  3.30k|}

_ZN9spank_olm7AccountC2Ev:
   50|  3.30k|        Account() : next_one_time_key_id(0) {}

_ZN9spank_olm14FixedSizeArrayINS_10OneTimeKeyELm100EEC2Ev:
   24|  3.30k|        FixedSizeArray() : current_size(0)
   25|  3.30k|        {
   26|  3.30k|            data = std::make_unique<T*[]>(max_size + 1);
   27|  3.30k|        }
_ZN9spank_olm14FixedSizeArrayINS_10OneTimeKeyELm100EED2Ev:
   49|  3.30k|        {
   50|  3.30k|            clear();
   51|  3.30k|        }
_ZN9spank_olm14FixedSizeArrayINS_10OneTimeKeyELm100EE5clearEv:
  250|  3.30k|        {
  251|  3.30k|            for (std::size_t i = 0; i < current_size; ++i)
  ------------------
  |  Branch (251:37): [True: 0, False: 3.30k]
  ------------------
  252|      0|            {
  253|      0|                delete data[i];
  254|      0|            }
  255|  3.30k|            current_size = 0;
  256|  3.30k|        }

_ZN9spank_olm7Account11new_accountERN5Botan21RandomNumberGeneratorE:
   11|  3.30k|    {
   12|  3.30k|        identity_keys = IdentityKeys{Botan::Ed25519_PrivateKey(rng), Botan::X25519_PrivateKey(rng)};
   13|       |
   14|       |        // Make sure we check the key pairs.
   15|  3.30k|        if (!identity_keys->ed25519_key.check_key(rng, false) || !identity_keys->curve25519_key.check_key(rng, false) ||
  ------------------
  |  Branch (15:13): [True: 0, False: 3.30k]
  |  Branch (15:13): [True: 0, False: 3.30k]
  |  Branch (15:66): [True: 0, False: 3.30k]
  ------------------
   16|  3.30k|            !identity_keys->ed25519_key.public_key()->check_key(rng, false) ||
  ------------------
  |  Branch (16:13): [True: 0, False: 3.30k]
  ------------------
   17|  3.30k|            !identity_keys->curve25519_key.public_key()->check_key(rng, false))
  ------------------
  |  Branch (17:13): [True: 0, False: 3.30k]
  ------------------
   18|      0|        {
   19|      0|            throw SpankOlmErrorKeyGeneration();
   20|      0|        }
   21|  3.30k|    }
_ZNK9spank_olm7Account4signERN5Botan21RandomNumberGeneratorENSt3__117basic_string_viewIcNS4_11char_traitsIcEEEE:
   36|  3.30k|    {
   37|       |        // According to https://botan.randombit.net/handbook/api_ref/pubkey.html#ed25519-ed448-variants
   38|  3.30k|        const std::string padding_scheme = "Ed25519ph";
   39|       |
   40|       |        // Use the Ed25519 key to sign the message using the Botan library.
   41|       |
   42|       |
   43|  3.30k|        Botan::PK_Signer signer(identity_keys->ed25519_key, rng, padding_scheme);
   44|  3.30k|        signer.update(message);
   45|  3.30k|        auto signature = signer.signature(rng);
   46|       |
   47|  3.30k|        return signature;
   48|  3.30k|    }

_ZNK5Botan18Ed25519_PrivateKey20raw_private_key_bitsEv:
  117|  3.30k|      secure_vector<uint8_t> raw_private_key_bits() const override { return m_private; }

_ZN5Botan14Asymmetric_KeyD2Ev:
   62|  19.8k|      virtual ~Asymmetric_Key() = default;

_ZN5Botan11PK_Verifier15check_signatureENSt3__14spanIKhLm18446744073709551615EEE:
  372|  3.30k|      bool check_signature(std::span<const uint8_t> sig) { return check_signature(sig.data(), sig.size()); }

_ZN5Botan16secure_allocatorIhE10deallocateEPhm:
   54|  29.7k|      void deallocate(T* p, std::size_t n) { deallocate_memory(p, n, sizeof(T)); }
_ZN5Botan16secure_allocatorIhE8allocateEm:
   52|  29.7k|      T* allocate(std::size_t n) { return static_cast<T*>(allocate_memory(n, sizeof(T))); }
_ZN5BotanneIhhEEbRKNS_16secure_allocatorIT_EERKNS1_IT0_EE:
   63|  3.30k|inline bool operator!=(const secure_allocator<T>&, const secure_allocator<U>&) {
   64|  3.30k|   return false;
   65|  3.30k|}

