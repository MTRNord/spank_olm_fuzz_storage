_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EEC2Ev:
   63|  78.7k|      AlignmentBuffer() : m_position(0) {}
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE5clearEv:
   72|   984k|      void clear() {
   73|   984k|         clear_mem(m_buffer.data(), m_buffer.size());
   74|   984k|         m_position = 0;
   75|   984k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EED2Ev:
   65|  78.7k|      ~AlignmentBuffer() { secure_scrub_memory(m_buffer.data(), m_buffer.size()); }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE21handle_unaligned_dataERNS_12BufferSlicerE:
  167|  1.99M|      [[nodiscard]] std::optional<std::span<const T>> handle_unaligned_data(BufferSlicer& slicer) {
  168|       |         // When the final block is to be deferred, we would need to store and
  169|       |         // hold a buffer that contains exactly one block until more data is
  170|       |         // passed or it is explicitly consumed.
  171|  1.99M|         const size_t defer = (defers_final_block()) ? 1 : 0;
  ------------------
  |  Branch (171:31): [True: 0, False: 1.99M]
  ------------------
  172|       |
  173|  1.99M|         if(in_alignment() && slicer.remaining() >= m_buffer.size() + defer) {
  ------------------
  |  Branch (173:13): [True: 1.61M, False: 380k]
  |  Branch (173:31): [True: 833k, False: 780k]
  ------------------
  174|       |            // We are currently in alignment and the passed-in data source
  175|       |            // contains enough data to benefit from aligned processing.
  176|       |            // Therefore, we don't copy anything into the intermittent buffer.
  177|   833k|            return std::nullopt;
  178|   833k|         }
  179|       |
  180|       |         // Fill the buffer with as much input data as needed to reach alignment
  181|       |         // or until the input source is depleted.
  182|  1.16M|         const auto elements_to_consume = std::min(m_buffer.size() - m_position, slicer.remaining());
  183|  1.16M|         append(slicer.take(elements_to_consume));
  184|       |
  185|       |         // If we collected enough data, we push out one full block. When
  186|       |         // deferring the final block is enabled, we additionally check that
  187|       |         // more input data is available to continue processing a consecutive
  188|       |         // block.
  189|  1.16M|         if(ready_to_consume() && (!defers_final_block() || !slicer.empty())) {
  ------------------
  |  Branch (189:13): [True: 39.3k, False: 1.12M]
  |  Branch (189:36): [True: 39.3k, False: 0]
  |  Branch (189:61): [True: 0, False: 0]
  ------------------
  190|  39.3k|            return consume();
  191|  1.12M|         } else {
  192|  1.12M|            return std::nullopt;
  193|  1.12M|         }
  194|  1.16M|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE18defers_final_blockEv:
  234|  2.90M|      constexpr bool defers_final_block() const {
  235|  2.90M|         return FINAL_BLOCK_STRATEGY == AlignmentBufferFinalBlock::must_be_deferred;
  236|  2.90M|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE6appendENSt3__14spanIKhLm18446744073709551615EEE:
   91|  1.90M|      void append(std::span<const T> elements) {
   92|  1.90M|         BOTAN_ASSERT_NOMSG(elements.size() <= elements_until_alignment());
  ------------------
  |  |   62|  1.90M|   do {                                                                     \
  |  |   63|  1.90M|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 1.90M]
  |  |  ------------------
  |  |   64|  1.90M|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|  1.90M|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   93|  1.90M|         std::copy(elements.begin(), elements.end(), m_buffer.begin() + m_position);
   94|  1.90M|         m_position += elements.size();
   95|  1.90M|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE24elements_until_alignmentEv:
  222|  4.15M|      size_t elements_until_alignment() const { return m_buffer.size() - m_position; }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE16ready_to_consumeEv:
  232|  3.44M|      bool ready_to_consume() const { return m_position == m_buffer.size(); }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE7consumeEv:
  201|   788k|      [[nodiscard]] std::span<const T> consume() {
  202|   788k|         BOTAN_ASSERT_NOMSG(ready_to_consume());
  ------------------
  |  |   62|   788k|   do {                                                                     \
  |  |   63|   788k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 788k]
  |  |  ------------------
  |  |   64|   788k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   788k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  203|   788k|         m_position = 0;
  204|   788k|         return m_buffer;
  205|   788k|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE12in_alignmentEv:
  227|  4.86M|      bool in_alignment() const { return m_position == 0; }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE23aligned_data_to_processERNS_12BufferSlicerE:
  127|   873k|      [[nodiscard]] std::tuple<std::span<const uint8_t>, size_t> aligned_data_to_process(BufferSlicer& slicer) const {
  128|   873k|         BOTAN_ASSERT_NOMSG(in_alignment());
  ------------------
  |  |   62|   873k|   do {                                                                     \
  |  |   63|   873k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 873k]
  |  |  ------------------
  |  |   64|   873k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   873k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  129|       |
  130|       |         // When the final block is to be deferred, the last block must not be
  131|       |         // selected for processing if there is no (unaligned) extra input data.
  132|   873k|         const size_t defer = (defers_final_block()) ? 1 : 0;
  ------------------
  |  Branch (132:31): [True: 0, False: 873k]
  ------------------
  133|   873k|         const size_t full_blocks_to_process = (slicer.remaining() - defer) / m_buffer.size();
  134|   873k|         return {slicer.take(full_blocks_to_process * m_buffer.size()), full_blocks_to_process};
  135|   873k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE18fill_up_with_zerosEv:
   80|   749k|      void fill_up_with_zeros() {
   81|   749k|         if(!ready_to_consume()) {
  ------------------
  |  Branch (81:13): [True: 749k, False: 84]
  ------------------
   82|   749k|            clear_mem(&m_buffer[m_position], elements_until_alignment());
   83|   749k|            m_position = m_buffer.size();
   84|   749k|         }
   85|   749k|      }
_ZN5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE20directly_modify_lastEm:
  114|   748k|      std::span<T> directly_modify_last(size_t elements) {
  115|   748k|         BOTAN_ASSERT_NOMSG(size() >= elements);
  ------------------
  |  |   62|   748k|   do {                                                                     \
  |  |   63|   748k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 748k]
  |  |  ------------------
  |  |   64|   748k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   748k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  116|   748k|         return std::span(m_buffer).last(elements);
  117|   748k|      }
_ZNK5Botan15AlignmentBufferIhLm128ELNS_25AlignmentBufferFinalBlockE0EE4sizeEv:
  218|   748k|      constexpr size_t size() const { return m_buffer.size(); }

_ZN5Botan14expand_top_bitImEET_S1_Qsr3std11is_integralIS1_EE5value:
   28|  6.71M|{
   29|  6.71M|   return static_cast<T>(0) - (a >> (sizeof(T) * 8 - 1));
   30|  6.71M|}
_ZN5Botan6chooseImEET_S1_S1_S1_:
  204|   318M|inline constexpr T choose(T mask, T a, T b) {
  205|       |   //return (mask & a) | (~mask & b);
  206|   318M|   return (b ^ (mask & (a ^ b)));
  207|   318M|}
_ZN5Botan10ct_is_zeroIhEET_S1_Qsr3std11is_integralIS1_EE5value:
   38|  39.3k|{
   39|  39.3k|   return expand_top_bit<T>(~x & (x - 1));
   40|  39.3k|}
_ZN5Botan14expand_top_bitIhEET_S1_Qsr3std11is_integralIS1_EE5value:
   28|  39.3k|{
   29|  39.3k|   return static_cast<T>(0) - (a >> (sizeof(T) * 8 - 1));
   30|  39.3k|}
_ZN5Botan8majorityImEET_S1_S1_S1_:
  210|   159M|inline constexpr T majority(T a, T b, T c) {
  211|       |   /*
  212|       |   Considering each bit of a, b, c individually
  213|       |
  214|       |   If a xor b is set, then c is the deciding vote.
  215|       |
  216|       |   If a xor b is not set then either a and b are both set or both unset.
  217|       |   In either case the value of c doesn't matter, and examining b (or a)
  218|       |   allows us to determine which case we are in.
  219|       |   */
  220|   159M|   return choose(a ^ b, c, b);
  221|   159M|}

_ZN5Botan13reverse_bytesITkNSt3__117unsigned_integralEmQooooooeqstT_Li1EeqstS2_Li2EeqstS2_Li4EeqstS2_Li8EEES2_S2_:
   27|  6.73M|inline constexpr T reverse_bytes(T x) {
   28|       |   if constexpr(sizeof(T) == 1) {
   29|       |      return x;
   30|       |   } else if constexpr(sizeof(T) == 2) {
   31|       |#if BOTAN_COMPILER_HAS_BUILTIN(__builtin_bswap16)
   32|       |      return static_cast<T>(__builtin_bswap16(x));
   33|       |#else
   34|       |      return static_cast<T>((x << 8) | (x >> 8));
   35|       |#endif
   36|       |   } else if constexpr(sizeof(T) == 4) {
   37|       |#if BOTAN_COMPILER_HAS_BUILTIN(__builtin_bswap32)
   38|       |      return static_cast<T>(__builtin_bswap32(x));
   39|       |#else
   40|       |      // MSVC at least recognizes this as a bswap
   41|       |      return static_cast<T>(((x & 0x000000FF) << 24) | ((x & 0x0000FF00) << 8) | ((x & 0x00FF0000) >> 8) |
   42|       |                            ((x & 0xFF000000) >> 24));
   43|       |#endif
   44|  6.73M|   } else if constexpr(sizeof(T) == 8) {
   45|  6.73M|#if BOTAN_COMPILER_HAS_BUILTIN(__builtin_bswap64)
   46|  6.73M|      return static_cast<T>(__builtin_bswap64(x));
   47|       |#else
   48|       |      uint32_t hi = static_cast<uint32_t>(x >> 32);
   49|       |      uint32_t lo = static_cast<uint32_t>(x);
   50|       |
   51|       |      hi = reverse_bytes(hi);
   52|       |      lo = reverse_bytes(lo);
   53|       |
   54|       |      return (static_cast<T>(lo) << 32) | hi;
   55|       |#endif
   56|  6.73M|   }
   57|  6.73M|}

_ZN5Botan5CPUID3hasENS_10CPUFeatureE:
  110|  4.86M|      static bool has(CPUID::Feature elem) { return state().has_bit(elem.as_u32()); }
_ZNK5Botan5CPUID10CPUID_Data7has_bitEj:
  145|  4.86M|            bool has_bit(uint32_t bit) const { return (m_processor_features & bit) == bit; }
_ZN5Botan5CPUID5stateEv:
  157|  4.86M|      static CPUID_Data& state() {
  158|  4.86M|         static CPUID::CPUID_Data g_cpuid;
  159|  4.86M|         return g_cpuid;
  160|  4.86M|      }
cpuid_x86.cpp:_ZN5Botan5CPUID6if_setIZNS0_10CPUID_Data19detect_cpu_featuresEjE16x86_CPUID_1_bitsEEjmT_NS_10CPUFeatureEj:
  126|      6|      static inline uint32_t if_set(uint64_t cpuid, T flag, CPUID::Feature bit, uint32_t allowed) {
  127|      6|         const uint64_t flag64 = static_cast<uint64_t>(flag);
  128|      6|         if((cpuid & flag64) == flag64) {
  ------------------
  |  Branch (128:13): [True: 6, False: 0]
  ------------------
  129|      6|            return (bit.as_u32() & allowed);
  130|      6|         } else {
  131|      0|            return 0;
  132|      0|         }
  133|      6|      }
cpuid_x86.cpp:_ZN5Botan5CPUID6if_setIZNS0_10CPUID_Data19detect_cpu_featuresEjE16x86_CPUID_7_bitsEEjmT_NS_10CPUFeatureEj:
  126|      8|      static inline uint32_t if_set(uint64_t cpuid, T flag, CPUID::Feature bit, uint32_t allowed) {
  127|      8|         const uint64_t flag64 = static_cast<uint64_t>(flag);
  128|      8|         if((cpuid & flag64) == flag64) {
  ------------------
  |  Branch (128:13): [True: 7, False: 1]
  ------------------
  129|      7|            return (bit.as_u32() & allowed);
  130|      7|         } else {
  131|      1|            return 0;
  132|      1|         }
  133|      8|      }
cpuid_x86.cpp:_ZN5Botan5CPUID6if_setIZNS0_10CPUID_Data19detect_cpu_featuresEjE18x86_CPUID_7_1_bitsEEjmT_NS_10CPUFeatureEj:
  126|      3|      static inline uint32_t if_set(uint64_t cpuid, T flag, CPUID::Feature bit, uint32_t allowed) {
  127|      3|         const uint64_t flag64 = static_cast<uint64_t>(flag);
  128|      3|         if((cpuid & flag64) == flag64) {
  ------------------
  |  Branch (128:13): [True: 0, False: 3]
  ------------------
  129|      0|            return (bit.as_u32() & allowed);
  130|      3|         } else {
  131|      3|            return 0;
  132|      3|         }
  133|      3|      }

_ZN5Botan10CPUFeatureC2ENS0_3BitE:
   46|  4.86M|      CPUFeature(Bit b) : m_bit(b) {}
_ZNK5Botan10CPUFeature6as_u32Ev:
   48|  4.86M|      uint32_t as_u32() const { return static_cast<uint32_t>(m_bit); }

_ZN5Botan2CT13value_barrierImEET_S2_Qaasr3stdE17unsigned_integralIS2_Entsr3stdE7same_asIbS2_E:
  275|  94.0M|{
  276|  94.0M|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (276:7): [Folded - Ignored]
  ------------------
  277|      0|      return x;
  278|  94.0M|   } else {
  279|  94.0M|#if defined(BOTAN_CT_VALUE_BARRIER_USE_ASM)
  280|       |      /*
  281|       |      * We may want a "stronger" statement such as
  282|       |      *     asm volatile("" : "+r,m"(x) : : "memory);
  283|       |      * (see https://theunixzoo.co.uk/blog/2021-10-14-preventing-optimisations.html)
  284|       |      * however the current approach seems sufficient with current compilers,
  285|       |      * and is minimally damaging with regards to degrading code generation.
  286|       |      */
  287|  94.0M|      asm("" : "+r"(x) : /* no input */);
  288|  94.0M|      return x;
  289|       |#elif defined(BOTAN_CT_VALUE_BARRIER_USE_VOLATILE)
  290|       |      volatile T vx = x;
  291|       |      return vx;
  292|       |#else
  293|       |      return x;
  294|       |#endif
  295|  94.0M|   }
  296|  94.0M|}
_ZNK5Botan2CT4MaskImE5valueEv:
  636|  87.3M|      constexpr T value() const { return value_barrier<T>(m_mask); }
_ZN5Botan2CT8is_equalIhEENS0_4MaskIT_EEPKS3_S6_m:
  789|  39.3k|constexpr inline CT::Mask<T> is_equal(const T x[], const T y[], size_t len) {
  790|  39.3k|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (790:7): [Folded - Ignored]
  ------------------
  791|      0|      T difference = 0;
  792|       |
  793|      0|      for(size_t i = 0; i != len; ++i) {
  ------------------
  |  Branch (793:25): [True: 0, False: 0]
  ------------------
  794|      0|         difference = difference | (x[i] ^ y[i]);
  795|      0|      }
  796|       |
  797|      0|      return CT::Mask<T>::is_zero(difference);
  798|  39.3k|   } else {
  799|  39.3k|      volatile T difference = 0;
  800|       |
  801|  1.29M|      for(size_t i = 0; i != len; ++i) {
  ------------------
  |  Branch (801:25): [True: 1.25M, False: 39.3k]
  ------------------
  802|  1.25M|         difference = difference | (x[i] ^ y[i]);
  803|  1.25M|      }
  804|       |
  805|  39.3k|      return CT::Mask<T>::is_zero(difference);
  806|  39.3k|   }
  807|  39.3k|}
_ZN5Botan2CT4MaskIhE7is_zeroEh:
  449|  39.3k|      static constexpr Mask<T> is_zero(T x) { return Mask<T>(ct_is_zero<T>(value_barrier<T>(x))); }
_ZN5Botan2CT13value_barrierIhEET_S2_Qaasr3stdE17unsigned_integralIS2_Entsr3stdE7same_asIbS2_E:
  275|  78.7k|{
  276|  78.7k|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (276:7): [Folded - Ignored]
  ------------------
  277|      0|      return x;
  278|  78.7k|   } else {
  279|  78.7k|#if defined(BOTAN_CT_VALUE_BARRIER_USE_ASM)
  280|       |      /*
  281|       |      * We may want a "stronger" statement such as
  282|       |      *     asm volatile("" : "+r,m"(x) : : "memory);
  283|       |      * (see https://theunixzoo.co.uk/blog/2021-10-14-preventing-optimisations.html)
  284|       |      * however the current approach seems sufficient with current compilers,
  285|       |      * and is minimally damaging with regards to degrading code generation.
  286|       |      */
  287|  78.7k|      asm("" : "+r"(x) : /* no input */);
  288|  78.7k|      return x;
  289|       |#elif defined(BOTAN_CT_VALUE_BARRIER_USE_VOLATILE)
  290|       |      volatile T vx = x;
  291|       |      return vx;
  292|       |#else
  293|       |      return x;
  294|       |#endif
  295|  78.7k|   }
  296|  78.7k|}
_ZN5Botan2CT4MaskIhEC2Eh:
  643|  39.3k|      constexpr Mask(T m) : m_mask(m) {}
_ZNK5Botan2CT4MaskIhE7as_boolEv:
  626|  39.3k|      constexpr bool as_bool() const { return unpoisoned_value() != 0; }
_ZNK5Botan2CT4MaskIhE16unpoisoned_valueEv:
  610|  39.3k|      constexpr T unpoisoned_value() const {
  611|  39.3k|         T r = value();
  612|  39.3k|         CT::unpoison(r);
  613|  39.3k|         return r;
  614|  39.3k|      }
_ZNK5Botan2CT4MaskIhE5valueEv:
  636|  39.3k|      constexpr T value() const { return value_barrier<T>(m_mask); }
_ZN5Botan2CT8unpoisonITkNSt3__18integralEhEEvRT_:
  105|  39.3k|constexpr void unpoison(T& p) {
  106|  39.3k|   unpoison(&p, 1);
  107|  39.3k|}
_ZN5Botan2CT8unpoisonIhEEvPKT_m:
   65|   118k|constexpr inline void unpoison(const T* p, size_t n) {
   66|       |#if defined(BOTAN_HAS_VALGRIND)
   67|       |   if(!std::is_constant_evaluated()) {
   68|       |      VALGRIND_MAKE_MEM_DEFINED(p, n * sizeof(T));
   69|       |   }
   70|       |#endif
   71|       |
   72|   118k|   BOTAN_UNUSED(p, n);
  ------------------
  |  |  120|   118k|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
   73|   118k|}
_ZN5Botan2CT4MaskImEC2Em:
  643|  12.5M|      constexpr Mask(T m) : m_mask(m) {}
_ZN5Botan2CT4MaskImE14expand_top_bitEm:
  427|  6.71M|      static constexpr Mask<T> expand_top_bit(T v) { return Mask<T>(Botan::expand_top_bit<T>(value_barrier<T>(v))); }
_ZNK5Botan2CT4MaskImE13if_set_returnEm:
  550|  75.5M|      constexpr T if_set_return(T x) const { return value() & x; }
_ZN5Botan2CT6poisonIhEEvPKT_m:
   54|  52.4k|constexpr inline void poison(const T* p, size_t n) {
   55|       |#if defined(BOTAN_HAS_VALGRIND)
   56|       |   if(!std::is_constant_evaluated()) {
   57|       |      VALGRIND_MAKE_MEM_UNDEFINED(p, n * sizeof(T));
   58|       |   }
   59|       |#endif
   60|       |
   61|  52.4k|   BOTAN_UNUSED(p, n);
  ------------------
  |  |  120|  52.4k|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
   62|  52.4k|}
_ZN5Botan2CT4MaskImE10expand_bitEmm:
  433|  6.71M|      static constexpr Mask<T> expand_bit(T v, size_t bit) {
  434|  6.71M|         return CT::Mask<T>::expand_top_bit(v << (sizeof(v) * 8 - 1 - bit));
  435|  6.71M|      }
_ZN5Botan2CTeoENS0_4MaskImEES2_:
  535|  5.87M|      friend Mask<T> operator^(Mask<T> x, Mask<T> y) { return Mask<T>(x.value() ^ y.value()); }

_ZN5Botan11carry_shiftEom:
  143|   370M|inline uint64_t carry_shift(const uint128_t a, size_t shift) {
  144|   370M|   return static_cast<uint64_t>(a >> shift);
  145|   370M|}
_ZN5Botan13combine_lowerEomom:
  147|   104k|inline uint64_t combine_lower(const uint128_t a, size_t s1, const uint128_t b, size_t s2) {
  148|   104k|   return static_cast<uint64_t>((a >> s1) | (b << s2));
  149|   104k|}

_ZN5Botan8FE_25519C2Ei:
   29|  78.3M|      FE_25519(int init = 0) {
   30|  78.3M|         if(init != 0 && init != 1) {
  ------------------
  |  Branch (30:13): [True: 3.49M, False: 74.8M]
  |  Branch (30:26): [True: 0, False: 3.49M]
  ------------------
   31|      0|            throw Invalid_Argument("Invalid FE_25519 initial value");
   32|      0|         }
   33|  78.3M|         clear_mem(m_fe, 10);
   34|  78.3M|         m_fe[0] = init;
   35|  78.3M|      }
_ZN5Botan8FE_25519D2Ev:
   24|   152M|      ~FE_25519() { secure_scrub_memory(m_fe, sizeof(m_fe)); }
_ZN5Botan8FE_25519C2ESt16initializer_listIiE:
   37|  1.56k|      FE_25519(std::initializer_list<int32_t> x) {
   38|  1.56k|         if(x.size() != 10) {
  ------------------
  |  Branch (38:13): [True: 0, False: 1.56k]
  ------------------
   39|      0|            throw Invalid_Argument("Invalid FE_25519 initializer list");
   40|      0|         }
   41|  1.56k|         copy_mem(m_fe, x.begin(), 10);
   42|  1.56k|      }
_ZN5Botan8FE_25519C2Ellllllllll:
   53|  73.6M|               int64_t h9) {
   54|  73.6M|         m_fe[0] = static_cast<int32_t>(h0);
   55|  73.6M|         m_fe[1] = static_cast<int32_t>(h1);
   56|  73.6M|         m_fe[2] = static_cast<int32_t>(h2);
   57|  73.6M|         m_fe[3] = static_cast<int32_t>(h3);
   58|  73.6M|         m_fe[4] = static_cast<int32_t>(h4);
   59|  73.6M|         m_fe[5] = static_cast<int32_t>(h5);
   60|  73.6M|         m_fe[6] = static_cast<int32_t>(h6);
   61|  73.6M|         m_fe[7] = static_cast<int32_t>(h7);
   62|  73.6M|         m_fe[8] = static_cast<int32_t>(h8);
   63|  73.6M|         m_fe[9] = static_cast<int32_t>(h9);
   64|  73.6M|      }
_ZNK5Botan8FE_255197is_zeroEv:
   75|  39.3k|      bool is_zero() const {
   76|  39.3k|         uint8_t s[32];
   77|  39.3k|         to_bytes(s);
   78|       |
   79|  39.3k|         uint8_t sum = 0;
   80|  1.29M|         for(size_t i = 0; i != 32; ++i) {
  ------------------
  |  Branch (80:28): [True: 1.25M, False: 39.3k]
  ------------------
   81|  1.25M|            sum |= s[i];
   82|  1.25M|         }
   83|       |
   84|  39.3k|         return (sum == 0);
   85|  39.3k|      }
_ZNK5Botan8FE_2551911is_negativeEv:
   91|  78.7k|      bool is_negative() const {
   92|       |         // TODO could avoid most of the to_bytes computation here
   93|  78.7k|         uint8_t s[32];
   94|  78.7k|         to_bytes(s);
   95|  78.7k|         return s[0] & 1;
   96|  78.7k|      }
_ZN5Botan8FE_255193addERKS0_S2_:
   98|  26.8M|      static FE_25519 add(const FE_25519& a, const FE_25519& b) {
   99|  26.8M|         FE_25519 z;
  100|   295M|         for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (100:28): [True: 268M, False: 26.8M]
  ------------------
  101|   268M|            z[i] = a[i] + b[i];
  102|   268M|         }
  103|  26.8M|         return z;
  104|  26.8M|      }
_ZN5Botan8FE_255193subERKS0_S2_:
  106|  30.3M|      static FE_25519 sub(const FE_25519& a, const FE_25519& b) {
  107|  30.3M|         FE_25519 z;
  108|   333M|         for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (108:28): [True: 303M, False: 30.3M]
  ------------------
  109|   303M|            z[i] = a[i] - b[i];
  110|   303M|         }
  111|  30.3M|         return z;
  112|  30.3M|      }
_ZN5Botan8FE_255196negateERKS0_:
  114|  1.69M|      static FE_25519 negate(const FE_25519& a) {
  115|  1.69M|         FE_25519 z;
  116|  18.6M|         for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (116:28): [True: 16.9M, False: 1.69M]
  ------------------
  117|  16.9M|            z[i] = -a[i];
  118|  16.9M|         }
  119|  1.69M|         return z;
  120|  1.69M|      }
_ZN5Botan8FE_255193sqrERKS0_:
  125|  20.5M|      static FE_25519 sqr(const FE_25519& a) { return sqr_iter(a, 1); }
_ZNK5Botan8FE_25519ixEm:
  132|  2.75G|      int32_t operator[](size_t i) const { return m_fe[i]; }
_ZN5Botan8FE_25519ixEm:
  134|  1.29G|      int32_t& operator[](size_t i) { return m_fe[i]; }
_ZN5Botan12fe_frombytesERNS_8FE_25519EPKh:
  148|  26.2k|inline void fe_frombytes(FE_25519& x, const uint8_t* b) {
  149|  26.2k|   x.from_bytes(b);
  150|  26.2k|}
_ZN5Botan10fe_tobytesEPhRKNS_8FE_25519E:
  152|  52.4k|inline void fe_tobytes(uint8_t* b, const FE_25519& x) {
  153|  52.4k|   x.to_bytes(b);
  154|  52.4k|}
_ZN5Botan7fe_copyERNS_8FE_25519ERKS0_:
  156|   209k|inline void fe_copy(FE_25519& a, const FE_25519& b) {
  157|   209k|   a = b;
  158|   209k|}
_ZN5Botan12fe_isnonzeroERKNS_8FE_25519E:
  160|  39.3k|inline int fe_isnonzero(const FE_25519& x) {
  161|  39.3k|   return x.is_zero() ? 0 : 1;
  ------------------
  |  Branch (161:11): [True: 26.2k, False: 13.0k]
  ------------------
  162|  39.3k|}
_ZN5Botan13fe_isnegativeERKNS_8FE_25519E:
  164|  78.7k|inline int fe_isnegative(const FE_25519& x) {
  165|  78.7k|   return x.is_negative();
  166|  78.7k|}
_ZN5Botan4fe_0ERNS_8FE_25519E:
  168|  1.75M|inline void fe_0(FE_25519& x) {
  169|  1.75M|   x = FE_25519();
  170|  1.75M|}
_ZN5Botan4fe_1ERNS_8FE_25519E:
  172|  3.49M|inline void fe_1(FE_25519& x) {
  173|  3.49M|   x = FE_25519(1);
  174|  3.49M|}
_ZN5Botan6fe_addERNS_8FE_25519ERKS0_S3_:
  176|  26.8M|inline void fe_add(FE_25519& x, const FE_25519& a, const FE_25519& b) {
  177|  26.8M|   x = FE_25519::add(a, b);
  178|  26.8M|}
_ZN5Botan6fe_subERNS_8FE_25519ERKS0_S3_:
  180|  30.3M|inline void fe_sub(FE_25519& x, const FE_25519& a, const FE_25519& b) {
  181|  30.3M|   x = FE_25519::sub(a, b);
  182|  30.3M|}
_ZN5Botan6fe_negERNS_8FE_25519ERKS0_:
  184|  1.69M|inline void fe_neg(FE_25519& x, const FE_25519& z) {
  185|  1.69M|   x = FE_25519::negate(z);
  186|  1.69M|}
_ZN5Botan6fe_mulERNS_8FE_25519ERKS0_S3_:
  188|  45.7M|inline void fe_mul(FE_25519& x, const FE_25519& a, const FE_25519& b) {
  189|  45.7M|   x = FE_25519::mul(a, b);
  190|  45.7M|}
_ZN5Botan5fe_sqERNS_8FE_25519ERKS0_:
  192|  20.5M|inline void fe_sq(FE_25519& x, const FE_25519& z) {
  193|  20.5M|   x = FE_25519::sqr(z);
  194|  20.5M|}
_ZN5Botan10fe_sq_iterERNS_8FE_25519ERKS0_m:
  196|   708k|inline void fe_sq_iter(FE_25519& x, const FE_25519& z, size_t iter) {
  197|   708k|   x = FE_25519::sqr_iter(z, iter);
  198|   708k|}
_ZN5Botan6fe_sq2ERNS_8FE_25519ERKS0_:
  200|  6.75M|inline void fe_sq2(FE_25519& x, const FE_25519& z) {
  201|  6.75M|   x = FE_25519::sqr2(z);
  202|  6.75M|}
_ZN5Botan9fe_invertERNS_8FE_25519ERKS0_:
  204|  52.4k|inline void fe_invert(FE_25519& x, const FE_25519& z) {
  205|  52.4k|   x = FE_25519::invert(z);
  206|  52.4k|}
_ZN5Botan11fe_pow22523ERNS_8FE_25519ERKS0_:
  208|  26.2k|inline void fe_pow22523(FE_25519& x, const FE_25519& y) {
  209|  26.2k|   x = FE_25519::pow_22523(y);
  210|  26.2k|}

_ZN5Botan6load_3EPKh:
   19|   879k|inline uint64_t load_3(const uint8_t in[3]) {
   20|   879k|   return static_cast<uint64_t>(in[0]) | (static_cast<uint64_t>(in[1]) << 8) | (static_cast<uint64_t>(in[2]) << 16);
   21|   879k|}
_ZN5Botan6load_4EPKh:
   23|   800k|inline uint64_t load_4(const uint8_t* in) {
   24|   800k|   return load_le<uint32_t>(in, 0);
   25|   800k|}
_ZN5Botan8redc_mulERlS0_S0_S0_S0_S0_S0_:
   58|   734k|inline void redc_mul(int64_t& s1, int64_t& s2, int64_t& s3, int64_t& s4, int64_t& s5, int64_t& s6, int64_t& X) {
   59|   734k|   s1 += X * 666643;
   60|   734k|   s2 += X * 470296;
   61|   734k|   s3 += X * 654183;
   62|   734k|   s4 -= X * 997805;
   63|   734k|   s5 += X * 136657;
   64|   734k|   s6 -= X * 683901;
   65|   734k|   X = 0;
   66|   734k|}
_ZN5Botan5carryILm26ELl1EEEvRlS1_QaagtT_Li0EltT_Li64E:
   30|   649M|{
   31|   649M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   32|   649M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   33|   649M|   int64_t c = (h0 + X2) >> S;
   34|   649M|   h1 += c * MUL;
   35|   649M|   h0 -= c * X1;
   36|   649M|}
_ZN5Botan5carryILm25ELl1EEEvRlS1_QaagtT_Li0EltT_Li64E:
   30|   371M|{
   31|   371M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   32|   371M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   33|   371M|   int64_t c = (h0 + X2) >> S;
   34|   371M|   h1 += c * MUL;
   35|   371M|   h0 -= c * X1;
   36|   371M|}
_ZN5Botan5carryILm25ELl19EEEvRlS1_QaagtT_Li0EltT_Li64E:
   30|  92.7M|{
   31|  92.7M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   32|  92.7M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   33|  92.7M|   int64_t c = (h0 + X2) >> S;
   34|  92.7M|   h1 += c * MUL;
   35|  92.7M|   h0 -= c * X1;
   36|  92.7M|}
_ZN5Botan6carry0ILm26EEEvRiS1_QaagtT_Li0EltT_Li32E:
   51|   852k|{
   52|   852k|   const int32_t X1 = (static_cast<int64_t>(1) << S);
   53|   852k|   int32_t c = h0 >> S;
   54|   852k|   h1 += c;
   55|   852k|   h0 -= c * X1;
   56|   852k|}
_ZN5Botan6carry0ILm25EEEvRiS1_QaagtT_Li0EltT_Li32E:
   51|   682k|{
   52|   682k|   const int32_t X1 = (static_cast<int64_t>(1) << S);
   53|   682k|   int32_t c = h0 >> S;
   54|   682k|   h1 += c;
   55|   682k|   h0 -= c * X1;
   56|   682k|}
_ZN5Botan5carryILm21ELl1EEEvRlS1_QaagtT_Li0EltT_Li64E:
   30|  1.50M|{
   31|  1.50M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   32|  1.50M|   const int64_t X2 = (static_cast<int64_t>(1) << (S - 1));
   33|  1.50M|   int64_t c = (h0 + X2) >> S;
   34|  1.50M|   h1 += c * MUL;
   35|  1.50M|   h0 -= c * X1;
   36|  1.50M|}
_ZN5Botan6carry0ILm21EEEvRlS1_QaagtT_Li0EltT_Li64E:
   41|  1.24M|{
   42|  1.24M|   const int64_t X1 = (static_cast<int64_t>(1) << S);
   43|  1.24M|   int64_t c = h0 >> S;
   44|  1.24M|   h1 += c;
   45|  1.24M|   h0 -= c * X1;
   46|  1.24M|}

_ZN5Botan11checked_mulITkNSt3__117unsigned_integralEmEENS1_8optionalIT_EES3_S3_:
   46|   590k|constexpr inline std::optional<T> checked_mul(T a, T b) {
   47|       |   // Multiplication by 1U is a hack to work around C's insane
   48|       |   // integer promotion rules.
   49|       |   // https://stackoverflow.com/questions/24795651
   50|   590k|   const T r = (1U * a) * b;
   51|       |   // If a == 0 then the multiply certainly did not overflow
   52|       |   // Otherwise r / a == b unless overflow occured
   53|   590k|   if(a != 0 && r / a != b) {
  ------------------
  |  Branch (53:7): [True: 590k, False: 0]
  |  Branch (53:17): [True: 0, False: 590k]
  ------------------
   54|      0|      return {};
   55|      0|   }
   56|   590k|   return r;
   57|   590k|}

_ZN5Botan6detail24wrap_strong_type_or_enumITkNS0_20unsigned_integralishEjTkNSt3__117unsigned_integralEjEEDaT0_:
  200|   800k|constexpr auto wrap_strong_type_or_enum(T t) {
  201|       |   if constexpr(std::is_enum_v<OutT>) {
  202|       |      return static_cast<OutT>(t);
  203|   800k|   } else {
  204|   800k|      return Botan::wrap_strong_type<OutT>(t);
  205|   800k|   }
  206|   800k|}
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm4EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_:
  278|   800k|inline constexpr WrappedOutT load_any(InR&& in_range) {
  279|   800k|   using OutT = detail::wrapped_type<WrappedOutT>;
  280|   800k|   ranges::assert_exact_byte_length<sizeof(OutT)>(in_range);
  281|       |
  282|   800k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|   800k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  287|   800k|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|   800k|      } else {
  289|   800k|         std::span in{in_range};
  290|   800k|         if constexpr(sizeof(OutT) == 1) {
  291|   800k|            return static_cast<OutT>(in[0]);
  292|   800k|         } else if constexpr(endianness == std::endian::native) {
  293|   800k|            return typecast_copy<OutT>(in);
  294|   800k|         } else {
  295|   800k|            static_assert(opposite(endianness) == std::endian::native);
  296|   800k|            return reverse_bytes(typecast_copy<OutT>(in));
  297|   800k|         }
  298|   800k|      }
  299|   800k|   }());
  300|   800k|}
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjEET0_PKhm:
  454|   800k|inline constexpr OutT load_any(const uint8_t in[], size_t off) {
  455|       |   // asserts that *in points to enough bytes to read at offset off
  456|   800k|   constexpr size_t out_size = sizeof(OutT);
  457|   800k|   return load_any<endianness, OutT>(std::span<const uint8_t, out_size>(in + off * out_size, out_size));
  458|   800k|}
_ZN5Botan7load_leIjJRPKhiEEEDaDpOT0_:
  495|   800k|inline constexpr auto load_le(ParamTs&&... params) {
  496|   800k|   return detail::load_any<std::endian::little, OutT>(std::forward<ParamTs>(params)...);
  497|   800k|}
_ZN5Botan8store_leINS_6detail10AutoDetectEJNSt3__14spanIhLm8EEEmEEEDaDpOT0_:
  736|  26.2k|inline constexpr auto store_le(ParamTs&&... params) {
  737|  26.2k|   return detail::store_any<std::endian::little, ModifierT>(std::forward<ParamTs>(params)...);
  738|  26.2k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  26.2k|inline constexpr void store_any(OutR&& out, Ts... ins) {
  583|  26.2k|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  26.2k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  26.2k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  26.2k|      off += sizeof(T);
  587|  26.2k|   };
  588|       |
  589|  26.2k|   (store_one(std::span{out}, ins), ...);
  590|  26.2k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clImS8_EEDaS9_SE_:
  584|  26.2k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  26.2k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  26.2k|      off += sizeof(T);
  587|  26.2k|   };
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEEQnt15custom_storableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEEvS9_OT1_:
  525|   131k|inline constexpr void store_any(WrappedInT wrapped_in, OutR&& out_range) {
  526|   131k|   const auto in = detail::unwrap_strong_type_or_enum(wrapped_in);
  527|   131k|   using InT = decltype(in);
  528|   131k|   ranges::assert_exact_byte_length<sizeof(in)>(out_range);
  529|   131k|   std::span out{out_range};
  530|       |
  531|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  532|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  533|       |   // in a `constexpr` context.
  534|   131k|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (534:7): [Folded - Ignored]
  ------------------
  535|      0|      return fallback_store_any<endianness, InT>(in, std::forward<OutR>(out_range));
  536|   131k|   } else {
  537|       |      if constexpr(sizeof(InT) == 1) {
  538|       |         out[0] = static_cast<uint8_t>(in);
  539|   131k|      } else if constexpr(endianness == std::endian::native) {
  540|   131k|         typecast_copy(out, in);
  541|       |      } else {
  542|       |         static_assert(opposite(endianness) == std::endian::native);
  543|       |         typecast_copy(out, reverse_bytes(in));
  544|       |      }
  545|   131k|   }
  546|   131k|}
_ZN5Botan6detail26unwrap_strong_type_or_enumITkNS0_20unsigned_integralishEmEEDaT_:
  190|  6.86M|constexpr auto unwrap_strong_type_or_enum(InT t) {
  191|       |   if constexpr(std::is_enum_v<InT>) {
  192|       |      // TODO: C++23: use std::to_underlying(in) instead
  193|       |      return static_cast<std::underlying_type_t<InT>>(t);
  194|  6.86M|   } else {
  195|  6.86M|      return Botan::unwrap_strong_type(t);
  196|  6.86M|   }
  197|  6.86M|}
_ZN5Botan8store_leINS_6detail10AutoDetectEJNSt3__14spanIhLm4EEEjEEEDaDpOT0_:
  736|  26.2k|inline constexpr auto store_le(ParamTs&&... params) {
  737|  26.2k|   return detail::store_any<std::endian::little, ModifierT>(std::forward<ParamTs>(params)...);
  738|  26.2k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm4EEETpTkNS0_20unsigned_integralishEJjEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  26.2k|inline constexpr void store_any(OutR&& out, Ts... ins) {
  583|  26.2k|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  26.2k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  26.2k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  26.2k|      off += sizeof(T);
  587|  26.2k|   };
  588|       |
  589|  26.2k|   (store_one(std::span{out}, ins), ...);
  590|  26.2k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm4EEETpTkNS0_20unsigned_integralishEJjEQaagtsZT2_Li0Eooaasr3stdE7same_asIS4_T0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clIjS8_EEDaS9_SE_:
  584|  26.2k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  26.2k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  26.2k|      off += sizeof(T);
  587|  26.2k|   };
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm4EEEQnt15custom_storableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEEvS9_OT1_:
  525|  26.2k|inline constexpr void store_any(WrappedInT wrapped_in, OutR&& out_range) {
  526|  26.2k|   const auto in = detail::unwrap_strong_type_or_enum(wrapped_in);
  527|  26.2k|   using InT = decltype(in);
  528|  26.2k|   ranges::assert_exact_byte_length<sizeof(in)>(out_range);
  529|  26.2k|   std::span out{out_range};
  530|       |
  531|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  532|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  533|       |   // in a `constexpr` context.
  534|  26.2k|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (534:7): [Folded - Ignored]
  ------------------
  535|      0|      return fallback_store_any<endianness, InT>(in, std::forward<OutR>(out_range));
  536|  26.2k|   } else {
  537|       |      if constexpr(sizeof(InT) == 1) {
  538|       |         out[0] = static_cast<uint8_t>(in);
  539|  26.2k|      } else if constexpr(endianness == std::endian::native) {
  540|  26.2k|         typecast_copy(out, in);
  541|       |      } else {
  542|       |         static_assert(opposite(endianness) == std::endian::native);
  543|       |         typecast_copy(out, reverse_bytes(in));
  544|       |      }
  545|  26.2k|   }
  546|  26.2k|}
_ZN5Botan6detail26unwrap_strong_type_or_enumITkNS0_20unsigned_integralishEjEEDaT_:
  190|  26.2k|constexpr auto unwrap_strong_type_or_enum(InT t) {
  191|       |   if constexpr(std::is_enum_v<InT>) {
  192|       |      // TODO: C++23: use std::to_underlying(in) instead
  193|       |      return static_cast<std::underlying_type_t<InT>>(t);
  194|  26.2k|   } else {
  195|  26.2k|      return Botan::unwrap_strong_type(t);
  196|  26.2k|   }
  197|  26.2k|}
_ZN5Botan8store_beINS_6detail10AutoDetectEJRKmPhEEEDaDpOT0_:
  745|   748k|inline constexpr auto store_be(ParamTs&&... params) {
  746|   748k|   return detail::store_any<std::endian::big, ModifierT>(std::forward<ParamTs>(params)...);
  747|   748k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206ENS0_10AutoDetectETkNS0_20unsigned_integralishEmQoosr3stdE7same_asIS4_T0_Esr3stdE7same_asIT1_S5_EEEvS6_Ph:
  711|   748k|inline constexpr void store_any(T in, uint8_t out[]) {
  712|       |   // asserts that *out points to enough bytes to write into
  713|   748k|   store_any<endianness, InT>(in, std::span<uint8_t, sizeof(T)>(out, sizeof(T)));
  714|   748k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206ENS0_10AutoDetectETkNS0_20unsigned_integralishEmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEEQsr3stdE7same_asIS4_T0_EEEvT1_OT2_:
  646|   748k|inline constexpr void store_any(T in, OutR&& out_range) {
  647|   748k|   store_any<endianness, T>(in, std::forward<OutR>(out_range));
  648|   748k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206ETkNS0_20unsigned_integralishEmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEEQnt15custom_storableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEEvS9_OT1_:
  525|  6.73M|inline constexpr void store_any(WrappedInT wrapped_in, OutR&& out_range) {
  526|  6.73M|   const auto in = detail::unwrap_strong_type_or_enum(wrapped_in);
  527|  6.73M|   using InT = decltype(in);
  528|  6.73M|   ranges::assert_exact_byte_length<sizeof(in)>(out_range);
  529|  6.73M|   std::span out{out_range};
  530|       |
  531|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  532|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  533|       |   // in a `constexpr` context.
  534|  6.73M|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (534:7): [Folded - Ignored]
  ------------------
  535|      0|      return fallback_store_any<endianness, InT>(in, std::forward<OutR>(out_range));
  536|  6.73M|   } else {
  537|       |      if constexpr(sizeof(InT) == 1) {
  538|       |         out[0] = static_cast<uint8_t>(in);
  539|       |      } else if constexpr(endianness == std::endian::native) {
  540|       |         typecast_copy(out, in);
  541|  6.73M|      } else {
  542|  6.73M|         static_assert(opposite(endianness) == std::endian::native);
  543|  6.73M|         typecast_copy(out, reverse_bytes(in));
  544|  6.73M|      }
  545|  6.73M|   }
  546|  6.73M|}
_ZN5Botan6detail24wrap_strong_type_or_enumITkNS0_20unsigned_integralishEmTkNSt3__117unsigned_integralEmEEDaT0_:
  200|   183k|constexpr auto wrap_strong_type_or_enum(T t) {
  201|       |   if constexpr(std::is_enum_v<OutT>) {
  202|       |      return static_cast<OutT>(t);
  203|   183k|   } else {
  204|   183k|      return Botan::wrap_strong_type<OutT>(t);
  205|   183k|   }
  206|   183k|}
_ZN5Botan11copy_out_beITkNS_6ranges14spanable_rangeERNSt3__16vectorImNS_16secure_allocatorImEEEEEEvNS2_4spanIhLm18446744073709551615EEEOT_:
  773|   748k|inline void copy_out_be(std::span<uint8_t> out, InR&& in) {
  774|   748k|   using T = std::ranges::range_value_t<InR>;
  775|   748k|   std::span<const T> in_s{in};
  776|   748k|   const auto remaining_bytes = detail::copy_out_any_word_aligned_portion<std::endian::big>(out, in_s);
  777|       |
  778|       |   // copy remaining bytes as a partial word
  779|   748k|   for(size_t i = 0; i < remaining_bytes; ++i) {
  ------------------
  |  Branch (779:22): [True: 0, False: 748k]
  ------------------
  780|      0|      out[i] = get_byte_var(i, in_s.front());
  781|      0|   }
  782|   748k|}
_ZN5Botan6detail33copy_out_any_word_aligned_portionILNSt3__16endianE64206ETkNS0_20unsigned_integralishEmEEmRNS2_4spanIhLm18446744073709551615EEERNS4_IKT0_Lm18446744073709551615EEE:
  752|   748k|inline size_t copy_out_any_word_aligned_portion(std::span<uint8_t>& out, std::span<const T>& in) {
  753|   748k|   const size_t full_words = out.size() / sizeof(T);
  754|   748k|   const size_t full_word_bytes = full_words * sizeof(T);
  755|   748k|   const size_t remaining_bytes = out.size() - full_word_bytes;
  756|   748k|   BOTAN_ASSERT_NOMSG(in.size_bytes() >= full_word_bytes + remaining_bytes);
  ------------------
  |  |   62|   748k|   do {                                                                     \
  |  |   63|   748k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 748k]
  |  |  ------------------
  |  |   64|   748k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   748k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  757|       |
  758|       |   // copy full words
  759|   748k|   store_any<endianness, T>(out.first(full_word_bytes), in.first(full_words));
  760|   748k|   out = out.subspan(full_word_bytes);
  761|   748k|   in = in.subspan(full_words);
  762|       |
  763|   748k|   return remaining_bytes;
  764|   748k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm18446744073709551615EEETkNS4_14spanable_rangeENS6_IKmLm18446744073709551615EEEQoosr3stdE7same_asINS0_10AutoDetectET0_Esr3stdE7same_asISB_NS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT2_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISJ_EESK_E4type10value_typeEEEEvOT1_OSG_:
  603|   748k|inline constexpr void store_any(OutR&& out, InR&& in) {
  604|   748k|   ranges::assert_equal_byte_lengths(out, in);
  605|   748k|   using element_type = std::ranges::range_value_t<InR>;
  606|       |
  607|   748k|   auto store_elementwise = [&] {
  608|   748k|      constexpr size_t bytes_per_element = sizeof(element_type);
  609|   748k|      std::span<uint8_t> out_s(out);
  610|   748k|      for(auto in_elem : in) {
  611|   748k|         store_any<endianness, element_type>(out_s.template first<bytes_per_element>(), in_elem);
  612|   748k|         out_s = out_s.subspan(bytes_per_element);
  613|   748k|      }
  614|   748k|   };
  615|       |
  616|       |   // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  617|       |   // internally to copy ranges on a byte-by-byte basis, which is not allowed
  618|       |   // in a `constexpr` context.
  619|   748k|   if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (619:7): [Folded - Ignored]
  ------------------
  620|      0|      store_elementwise();
  621|   748k|   } else {
  622|       |      if constexpr(endianness == std::endian::native && !custom_storable<element_type>) {
  623|       |         typecast_copy(out, in);
  624|   748k|      } else {
  625|   748k|         store_elementwise();
  626|   748k|      }
  627|   748k|   }
  628|   748k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm18446744073709551615EEETkNS4_14spanable_rangeENS6_IKmLm18446744073709551615EEEQoosr3stdE7same_asINS0_10AutoDetectET0_Esr3stdE7same_asISB_NS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT2_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISJ_EESK_E4type10value_typeEEEEvOT1_OSG_ENKUlvE_clEv:
  607|   748k|   auto store_elementwise = [&] {
  608|   748k|      constexpr size_t bytes_per_element = sizeof(element_type);
  609|   748k|      std::span<uint8_t> out_s(out);
  610|  5.98M|      for(auto in_elem : in) {
  ------------------
  |  Branch (610:24): [True: 5.98M, False: 748k]
  ------------------
  611|  5.98M|         store_any<endianness, element_type>(out_s.template first<bytes_per_element>(), in_elem);
  612|  5.98M|         out_s = out_s.subspan(bytes_per_element);
  613|  5.98M|      }
  614|   748k|   };
_ZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  5.98M|inline constexpr void store_any(OutR&& out, Ts... ins) {
  583|  5.98M|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  5.98M|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  5.98M|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  5.98M|      off += sizeof(T);
  587|  5.98M|   };
  588|       |
  589|  5.98M|   (store_one(std::span{out}, ins), ...);
  590|  5.98M|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE64206EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm8EEETpTkNS0_20unsigned_integralishEJmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clImS7_EEDaS9_SE_:
  584|  5.98M|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  5.98M|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  5.98M|      off += sizeof(T);
  587|  5.98M|   };
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm8EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_:
  278|   183k|inline constexpr WrappedOutT load_any(InR&& in_range) {
  279|   183k|   using OutT = detail::wrapped_type<WrappedOutT>;
  280|   183k|   ranges::assert_exact_byte_length<sizeof(OutT)>(in_range);
  281|       |
  282|   183k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|   183k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  287|   183k|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|   183k|      } else {
  289|   183k|         std::span in{in_range};
  290|   183k|         if constexpr(sizeof(OutT) == 1) {
  291|   183k|            return static_cast<OutT>(in[0]);
  292|   183k|         } else if constexpr(endianness == std::endian::native) {
  293|   183k|            return typecast_copy<OutT>(in);
  294|   183k|         } else {
  295|   183k|            static_assert(opposite(endianness) == std::endian::native);
  296|   183k|            return reverse_bytes(typecast_copy<OutT>(in));
  297|   183k|         }
  298|   183k|      }
  299|   183k|   }());
  300|   183k|}
_ZN5Botan7load_leImJRPKhiEEEDaDpOT0_:
  495|  26.2k|inline constexpr auto load_le(ParamTs&&... params) {
  496|  26.2k|   return detail::load_any<std::endian::little, OutT>(std::forward<ParamTs>(params)...);
  497|  26.2k|}
_ZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmEET0_PKhm:
  454|   183k|inline constexpr OutT load_any(const uint8_t in[], size_t off) {
  455|       |   // asserts that *in points to enough bytes to read at offset off
  456|   183k|   constexpr size_t out_size = sizeof(OutT);
  457|   183k|   return load_any<endianness, OutT>(std::span<const uint8_t, out_size>(in + off * out_size, out_size));
  458|   183k|}
_ZZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEmTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm8EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_ENKUlvE_clEv:
  282|   183k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|   183k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (286:10): [Folded - Ignored]
  ------------------
  287|      0|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|   183k|      } else {
  289|   183k|         std::span in{in_range};
  290|       |         if constexpr(sizeof(OutT) == 1) {
  291|       |            return static_cast<OutT>(in[0]);
  292|   183k|         } else if constexpr(endianness == std::endian::native) {
  293|   183k|            return typecast_copy<OutT>(in);
  294|       |         } else {
  295|       |            static_assert(opposite(endianness) == std::endian::native);
  296|       |            return reverse_bytes(typecast_copy<OutT>(in));
  297|       |         }
  298|   183k|      }
  299|   183k|   }());
_ZN5Botan7load_leImJPKhiEEEDaDpOT0_:
  495|   157k|inline constexpr auto load_le(ParamTs&&... params) {
  496|   157k|   return detail::load_any<std::endian::little, OutT>(std::forward<ParamTs>(params)...);
  497|   157k|}
_ZZN5Botan6detail8load_anyILNSt3__16endianE57005ETkNS0_20unsigned_integralishEjTkNS_6ranges16contiguous_rangeIhEENS2_4spanIKhLm4EEEQnt15custom_loadableINS0_19wrapped_type_helperIu14__remove_cvrefIT0_EE4typeEEEESA_OT1_ENKUlvE_clEv:
  282|   800k|   return detail::wrap_strong_type_or_enum<WrappedOutT>([&]() -> OutT {
  283|       |      // At compile time we cannot use `typecast_copy` as it uses `std::memcpy`
  284|       |      // internally to copy ranges on a byte-by-byte basis, which is not allowed
  285|       |      // in a `constexpr` context.
  286|   800k|      if(std::is_constant_evaluated()) /* TODO: C++23: if consteval {} */ {
  ------------------
  |  Branch (286:10): [Folded - Ignored]
  ------------------
  287|      0|         return fallback_load_any<endianness, OutT>(std::forward<InR>(in_range));
  288|   800k|      } else {
  289|   800k|         std::span in{in_range};
  290|       |         if constexpr(sizeof(OutT) == 1) {
  291|       |            return static_cast<OutT>(in[0]);
  292|   800k|         } else if constexpr(endianness == std::endian::native) {
  293|   800k|            return typecast_copy<OutT>(in);
  294|       |         } else {
  295|       |            static_assert(opposite(endianness) == std::endian::native);
  296|       |            return reverse_bytes(typecast_copy<OutT>(in));
  297|       |         }
  298|   800k|      }
  299|   800k|   }());
_ZN5Botan8store_leINS_6detail10AutoDetectEJRPhmmmmEEEDaDpOT0_:
  736|  26.2k|inline constexpr auto store_le(ParamTs&&... params) {
  737|  26.2k|   return detail::store_any<std::endian::little, ModifierT>(std::forward<ParamTs>(params)...);
  738|  26.2k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005ENS0_10AutoDetectETkNS0_20unsigned_integralishEmTpTkNS0_20unsigned_integralishEJmmmEQaaoosr3stdE7same_asIS4_T0_Esr3stdE7same_asIT1_S5_E10all_same_vIS6_DpT2_EEEvPhS6_S8_:
  723|  26.2k|inline constexpr void store_any(uint8_t out[], T0 in0, Ts... ins) {
  724|  26.2k|   constexpr auto bytes = sizeof(in0) + (sizeof(ins) + ... + 0);
  725|       |   // asserts that *out points to the correct amount of memory
  726|  26.2k|   store_any<endianness, T0>(std::span<uint8_t, bytes>(out, bytes), in0, ins...);
  727|  26.2k|}
_ZN5Botan6detail9store_anyILNSt3__16endianE57005EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm32EEETpTkNS0_20unsigned_integralishEJmmmmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_:
  582|  26.2k|inline constexpr void store_any(OutR&& out, Ts... ins) {
  583|  26.2k|   ranges::assert_exact_byte_length<(sizeof(Ts) + ...)>(out);
  584|  26.2k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|  26.2k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|  26.2k|      off += sizeof(T);
  587|  26.2k|   };
  588|       |
  589|  26.2k|   (store_one(std::span{out}, ins), ...);
  590|  26.2k|}
_ZZN5Botan6detail9store_anyILNSt3__16endianE57005EmTkNS_6ranges23contiguous_output_rangeIhEENS2_4spanIhLm32EEETpTkNS0_20unsigned_integralishEJmmmmEQaagtsZT2_Li0Eooaasr3stdE7same_asINS0_10AutoDetectET0_E10all_same_vIDpT2_Eaa20unsigned_integralishIS9_E10all_same_vIS9_SB_EEEvOT1_SB_ENUlTyS9_T_E_clImS7_EEDaS9_SE_:
  584|   104k|   auto store_one = [off = 0]<typename T>(auto o, T i) mutable {
  585|   104k|      store_any<endianness, T>(i, o.subspan(off).template first<sizeof(T)>());
  586|   104k|      off += sizeof(T);
  587|   104k|   };

_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EEC2Ev:
   42|  78.7k|      MerkleDamgard_Hash() { clear(); }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE5clearEv:
   70|   984k|      void clear() {
   71|   984k|         MD::init(m_digest);
   72|   984k|         m_buffer.clear();
   73|   984k|         m_count = 0;
   74|   984k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE6updateENSt3__14spanIKhLm18446744073709551615EEE:
   44|  1.94M|      void update(std::span<const uint8_t> input) {
   45|  1.94M|         BufferSlicer in(input);
   46|       |
   47|  3.93M|         while(!in.empty()) {
  ------------------
  |  Branch (47:16): [True: 1.99M, False: 1.94M]
  ------------------
   48|  1.99M|            if(const auto one_block = m_buffer.handle_unaligned_data(in)) {
  ------------------
  |  Branch (48:27): [True: 39.3k, False: 1.95M]
  ------------------
   49|  39.3k|               MD::compress_n(m_digest, one_block.value(), 1);
   50|  39.3k|            }
   51|       |
   52|  1.99M|            if(m_buffer.in_alignment()) {
  ------------------
  |  Branch (52:16): [True: 873k, False: 1.12M]
  ------------------
   53|   873k|               const auto [aligned_data, full_blocks] = m_buffer.aligned_data_to_process(in);
   54|   873k|               if(full_blocks > 0) {
  ------------------
  |  Branch (54:19): [True: 833k, False: 39.3k]
  ------------------
   55|   833k|                  MD::compress_n(m_digest, aligned_data, full_blocks);
   56|   833k|               }
   57|   873k|            }
   58|  1.99M|         }
   59|       |
   60|  1.94M|         m_count += input.size();
   61|  1.94M|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE5finalENSt3__14spanIhLm18446744073709551615EEE:
   63|   748k|      void final(std::span<uint8_t> output) {
   64|   748k|         append_padding_bit();
   65|   748k|         append_counter_and_finalize();
   66|   748k|         copy_output(output);
   67|   748k|         clear();
   68|   748k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE18append_padding_bitEv:
   77|   748k|      void append_padding_bit() {
   78|   748k|         BOTAN_ASSERT_NOMSG(!m_buffer.ready_to_consume());
  ------------------
  |  |   62|   748k|   do {                                                                     \
  |  |   63|   748k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 748k]
  |  |  ------------------
  |  |   64|   748k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   748k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|   748k|         if constexpr(MD::bit_endianness == MD_Endian::Big) {
   80|   748k|            const uint8_t final_byte = 0x80;
   81|   748k|            m_buffer.append({&final_byte, 1});
   82|       |         } else {
   83|       |            const uint8_t final_byte = 0x01;
   84|       |            m_buffer.append({&final_byte, 1});
   85|       |         }
   86|   748k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE27append_counter_and_finalizeEv:
   88|   748k|      void append_counter_and_finalize() {
   89|       |         // Compress the remaining data if the final data block does not provide
   90|       |         // enough space for the counter bytes.
   91|   748k|         if(m_buffer.elements_until_alignment() < MD::ctr_bytes) {
  ------------------
  |  Branch (91:13): [True: 1.36k, False: 746k]
  ------------------
   92|  1.36k|            m_buffer.fill_up_with_zeros();
   93|  1.36k|            MD::compress_n(m_digest, m_buffer.consume(), 1);
   94|  1.36k|         }
   95|       |
   96|       |         // Make sure that any remaining bytes in the very last block are zero.
   97|   748k|         BOTAN_ASSERT_NOMSG(m_buffer.elements_until_alignment() >= MD::ctr_bytes);
  ------------------
  |  |   62|   748k|   do {                                                                     \
  |  |   63|   748k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 748k]
  |  |  ------------------
  |  |   64|   748k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   748k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   98|   748k|         m_buffer.fill_up_with_zeros();
   99|       |
  100|       |         // Replace a bunch of the right-most zero-padding with the counter bytes.
  101|   748k|         const uint64_t bit_count = m_count * 8;
  102|   748k|         auto last_bytes = m_buffer.directly_modify_last(sizeof(bit_count));
  103|   748k|         if constexpr(MD::byte_endianness == MD_Endian::Big) {
  104|   748k|            store_be(bit_count, last_bytes.data());
  105|       |         } else {
  106|       |            store_le(bit_count, last_bytes.data());
  107|       |         }
  108|       |
  109|       |         // Compress the very last block.
  110|   748k|         MD::compress_n(m_digest, m_buffer.consume(), 1);
  111|   748k|      }
_ZN5Botan18MerkleDamgard_HashINS_7SHA_512EE11copy_outputENSt3__14spanIhLm18446744073709551615EEE:
  113|   748k|      void copy_output(std::span<uint8_t> output) {
  114|   748k|         BOTAN_ASSERT_NOMSG(output.size() >= MD::output_bytes);
  ------------------
  |  |   62|   748k|   do {                                                                     \
  |  |   63|   748k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 748k]
  |  |  ------------------
  |  |   64|   748k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   748k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  115|       |
  116|   748k|         if constexpr(MD::byte_endianness == MD_Endian::Big) {
  117|   748k|            copy_out_be(output.first(MD::output_bytes), m_digest);
  118|       |         } else {
  119|       |            copy_out_le(output.first(MD::output_bytes), m_digest);
  120|       |         }
  121|   748k|      }

_ZN5Botan3rhoILm14ELm18ELm41EmEET2_S1_:
   51|   159M|inline constexpr T rho(T x) {
   52|   159M|   return rotr<R1>(x) ^ rotr<R2>(x) ^ rotr<R3>(x);
   53|   159M|}
_ZN5Botan4rotrILm14EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   35|   159M|{
   36|   159M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   37|   159M|}
_ZN5Botan4rotrILm18EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   35|   159M|{
   36|   159M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   37|   159M|}
_ZN5Botan4rotrILm41EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   35|   159M|{
   36|   159M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   37|   159M|}
_ZN5Botan3rhoILm28ELm34ELm39EmEET2_S1_:
   51|   159M|inline constexpr T rho(T x) {
   52|   159M|   return rotr<R1>(x) ^ rotr<R2>(x) ^ rotr<R3>(x);
   53|   159M|}
_ZN5Botan4rotrILm28EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   35|   159M|{
   36|   159M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   37|   159M|}
_ZN5Botan4rotrILm34EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   35|   159M|{
   36|   159M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   37|   159M|}
_ZN5Botan4rotrILm39EmEET0_S1_QaagtT_Li0EltT_mlLi8EstS1_:
   35|   159M|{
   36|   159M|   return static_cast<T>((input >> ROT) | (input << (8 * sizeof(T) - ROT)));
   37|   159M|}

_ZNK5Botan9SCAN_Name9algo_nameEv:
   44|  52.4k|      const std::string& algo_name() const { return m_alg_name; }
_ZNK5Botan9SCAN_Name9arg_countEv:
   49|  26.2k|      size_t arg_count() const { return m_args.size(); }

_ZNK5Botan7SHA_51213output_lengthEv:
   74|   787k|      size_t output_length() const override { return output_bytes; }
_ZNK5Botan7SHA_51215hash_block_sizeEv:
   76|  13.1k|      size_t hash_block_size() const override { return block_bytes; }
_ZN5Botan7SHA_5125clearEv:
   84|   157k|      void clear() override { m_md.clear(); }

_ZN5Botan9SHA2_64_FEmmmRmmmmS0_m:
   46|   159M|   uint64_t A, uint64_t B, uint64_t C, uint64_t& D, uint64_t E, uint64_t F, uint64_t G, uint64_t& H, uint64_t M) {
   47|   159M|   const uint64_t E_rho = rho<14, 18, 41>(E);
   48|   159M|   const uint64_t A_rho = rho<28, 34, 39>(A);
   49|   159M|   H += E_rho + choose(E, F, G) + M;
   50|   159M|   D += H;
   51|   159M|   H += A_rho + majority(A, B, C);
   52|   159M|}

_ZN5Botan9SIMD_2x64C2Ev:
   34|  12.8M|      SIMD_2x64() { m_simd = _mm_setzero_si128(); }
_ZN5Botan9SIMD_2x647load_beEPKv:
   40|  12.8M|      static SIMD_2x64 load_be(const void* in) { return SIMD_2x64::load_le(in).bswap(); }
_ZNK5Botan9SIMD_2x645bswapEv:
   42|  12.8M|      SIMD_2x64 BOTAN_FN_ISA_SIMD_2X64 bswap() const {
   43|  12.8M|         const auto idx = _mm_set_epi8(8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7);
   44|  12.8M|         return SIMD_2x64(_mm_shuffle_epi8(m_simd, idx));
   45|  12.8M|      }
_ZN5Botan9SIMD_2x64C2EDv2_x:
  147|   501M|      explicit SIMD_2x64(__m128i x) : m_simd(x) {}
_ZNK5Botan9SIMD_2x64plERKS0_:
   51|   218M|      SIMD_2x64 operator+(const SIMD_2x64& other) const {
   52|   218M|         SIMD_2x64 retval(*this);
   53|   218M|         retval += other;
   54|   218M|         return retval;
   55|   218M|      }
_ZN5Botan9SIMD_2x64pLERKS0_:
   63|   218M|      void operator+=(const SIMD_2x64& other) { m_simd = _mm_add_epi64(m_simd, other.m_simd); }
_ZN5Botan9SIMD_2x647load_leEPKv:
   36|  77.1M|      static SIMD_2x64 load_le(const void* in) {
   37|  77.1M|         return SIMD_2x64(_mm_loadu_si128(reinterpret_cast<const __m128i*>(in)));
   38|  77.1M|      }
_ZNK5Botan9SIMD_2x648store_leEPm:
   47|  64.2M|      void store_le(uint64_t out[2]) const { this->store_le(reinterpret_cast<uint8_t*>(out)); }
_ZNK5Botan9SIMD_2x648store_leEPh:
   49|  64.2M|      void store_le(uint8_t out[]) const { _mm_storeu_si128(reinterpret_cast<__m128i*>(out), m_simd); }
_ZN5Botan9SIMD_2x647alignr8ERKS0_S2_:
   99|   102M|      static SIMD_2x64 BOTAN_FN_ISA_SIMD_2X64 alignr8(const SIMD_2x64& a, const SIMD_2x64& b) {
  100|   102M|         return SIMD_2x64(_mm_alignr_epi8(a.m_simd, b.m_simd, 8));
  101|   102M|      }
_ZNK5Botan9SIMD_2x644rotrILm1EEES0_vQaagtT_Li0EltT_Li64E:
   70|  51.4M|      {
   71|       |         if constexpr(ROT == 8) {
   72|       |            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|  51.4M|         } else {
   84|  51.4M|            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|  51.4M|                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|  51.4M|         }
   87|  51.4M|      }
_ZNK5Botan9SIMD_2x64eoERKS0_:
   57|   205M|      SIMD_2x64 operator^(const SIMD_2x64& other) const {
   58|   205M|         SIMD_2x64 retval(*this);
   59|   205M|         retval ^= other;
   60|   205M|         return retval;
   61|   205M|      }
_ZN5Botan9SIMD_2x64eOERKS0_:
   65|   205M|      void operator^=(const SIMD_2x64& other) { m_simd = _mm_xor_si128(m_simd, other.m_simd); }
_ZNK5Botan9SIMD_2x644rotrILm8EEES0_vQaagtT_Li0EltT_Li64E:
   70|  51.4M|      {
   71|  51.4M|         if constexpr(ROT == 8) {
   72|  51.4M|            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|  51.4M|            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|       |         } else {
   84|       |            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|       |                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|       |         }
   87|  51.4M|      }
_ZNK5Botan9SIMD_2x643shrILi7EEES0_v:
   95|  51.4M|      SIMD_2x64 shr() const noexcept {
   96|  51.4M|         return SIMD_2x64(_mm_srli_epi64(m_simd, SHIFT));
   97|  51.4M|      }
_ZNK5Botan9SIMD_2x644rotrILm19EEES0_vQaagtT_Li0EltT_Li64E:
   70|  51.4M|      {
   71|       |         if constexpr(ROT == 8) {
   72|       |            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|  51.4M|         } else {
   84|  51.4M|            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|  51.4M|                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|  51.4M|         }
   87|  51.4M|      }
_ZNK5Botan9SIMD_2x644rotrILm61EEES0_vQaagtT_Li0EltT_Li64E:
   70|  51.4M|      {
   71|       |         if constexpr(ROT == 8) {
   72|       |            auto tab = _mm_setr_epi8(1, 2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 14, 15, 8);
   73|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   74|       |         } else if constexpr(ROT == 16) {
   75|       |            auto tab = _mm_setr_epi8(2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9);
   76|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   77|       |         } else if constexpr(ROT == 24) {
   78|       |            auto tab = _mm_setr_epi8(3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10);
   79|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   80|       |         } else if constexpr(ROT == 32) {
   81|       |            auto tab = _mm_setr_epi8(4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11);
   82|       |            return SIMD_2x64(_mm_shuffle_epi8(m_simd, tab));
   83|  51.4M|         } else {
   84|  51.4M|            return SIMD_2x64(_mm_or_si128(_mm_srli_epi64(m_simd, static_cast<int>(ROT)),
   85|  51.4M|                                          _mm_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
   86|  51.4M|         }
   87|  51.4M|      }
_ZNK5Botan9SIMD_2x643shrILi6EEES0_v:
   95|  51.4M|      SIMD_2x64 shr() const noexcept {
   96|  51.4M|         return SIMD_2x64(_mm_srli_epi64(m_simd, SHIFT));
   97|  51.4M|      }

_ZN5Botan9SIMD_4x32C2EDv2_x:
  756|      2|      explicit SIMD_4x32(native_simd_type x) noexcept : m_simd(x) {}
_ZN5Botan9SIMD_4x32C2Ejjjj:
   92|     96|      SIMD_4x32(uint32_t B0, uint32_t B1, uint32_t B2, uint32_t B3) noexcept {
   93|     96|#if defined(BOTAN_SIMD_USE_SSSE3)
   94|     96|         m_simd = _mm_set_epi32(B3, B2, B1, B0);
   95|       |#elif defined(BOTAN_SIMD_USE_ALTIVEC)
   96|       |         __vector unsigned int val = {B0, B1, B2, B3};
   97|       |         m_simd = val;
   98|       |#elif defined(BOTAN_SIMD_USE_NEON)
   99|       |         // Better way to do this?
  100|       |         const uint32_t B[4] = {B0, B1, B2, B3};
  101|       |         m_simd = vld1q_u32(B);
  102|       |#elif defined(BOTAN_SIMD_USE_LSX)
  103|       |         // Better way to do this?
  104|       |         const uint32_t B[4] = {B0, B1, B2, B3};
  105|       |         m_simd = __lsx_vld(B, 0);
  106|       |#endif
  107|     96|      }
_ZN5Botan9SIMD_4x328splat_u8Eh:
  127|      2|      static SIMD_4x32 splat_u8(uint8_t B) noexcept {
  128|      2|#if defined(BOTAN_SIMD_USE_SSSE3)
  129|      2|         return SIMD_4x32(_mm_set1_epi8(B));
  130|       |#elif defined(BOTAN_SIMD_USE_NEON)
  131|       |         return SIMD_4x32(vreinterpretq_u32_u8(vdupq_n_u8(B)));
  132|       |#elif defined(BOTAN_SIMD_USE_LSX)
  133|       |         return SIMD_4x32(__lsx_vreplgr2vr_b(B));
  134|       |#else
  135|       |         const uint32_t B4 = make_uint32(B, B, B, B);
  136|       |         return SIMD_4x32(B4, B4, B4, B4);
  137|       |#endif
  138|      2|      }

_ZN5Botan9SIMD_4x64C2Ev:
   32|  1.52M|      BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64() { m_simd = _mm256_setzero_si256(); }
_ZN5Botan9SIMD_4x648load_be2EPKvS2_:
   40|  1.52M|      static BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64 load_be2(const void* inl, const void* inh) {
   41|  1.52M|         return SIMD_4x64::load_le2(inl, inh).bswap();
   42|  1.52M|      }
_ZN5Botan9SIMD_4x648load_le2EPKvS2_:
   35|  1.52M|      static BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64 load_le2(const void* inl, const void* inh) {
   36|  1.52M|         return SIMD_4x64(
   37|  1.52M|            _mm256_loadu2_m128i(reinterpret_cast<const __m128i*>(inl), reinterpret_cast<const __m128i*>(inh)));
   38|  1.52M|      }
_ZN5Botan9SIMD_4x64C2EDv4_x:
  160|  59.4M|      explicit BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64(__m256i x) : m_simd(x) {}
_ZNK5Botan9SIMD_4x645bswapEv:
   50|  1.52M|      SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 bswap() const {
   51|  1.52M|         const auto idx = _mm256_set_epi8(
   52|  1.52M|            8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7);
   53|       |
   54|  1.52M|         return SIMD_4x64(_mm256_shuffle_epi8(m_simd, idx));
   55|  1.52M|      }
_ZNK5Botan9SIMD_4x64plERKS0_:
   67|  25.9M|      SIMD_4x64 operator+(const SIMD_4x64& other) const {
   68|  25.9M|         SIMD_4x64 retval(*this);
   69|  25.9M|         retval += other;
   70|  25.9M|         return retval;
   71|  25.9M|      }
_ZN5Botan9SIMD_4x64pLERKS0_:
   79|  25.9M|      BOTAN_FN_ISA_SIMD_4X64 void operator+=(const SIMD_4x64& other) {
   80|  25.9M|         m_simd = _mm256_add_epi64(m_simd, other.m_simd);
   81|  25.9M|      }
_ZN5Botan9SIMD_4x647load_leEPKv:
   44|  7.61M|      static BOTAN_FN_ISA_SIMD_4X64 SIMD_4x64 load_le(const void* in) {
   45|  7.61M|         return SIMD_4x64(_mm256_loadu_si256(reinterpret_cast<const __m256i*>(in)));
   46|  7.61M|      }
_ZN5Botan9SIMD_4x649store_le2EPvS1_:
   63|  7.61M|      BOTAN_FN_ISA_SIMD_4X64 void store_le2(void* outh, void* outl) {
   64|  7.61M|         _mm256_storeu2_m128i(reinterpret_cast<__m128i*>(outh), reinterpret_cast<__m128i*>(outl), m_simd);
   65|  7.61M|      }
_ZN5Botan9SIMD_4x647alignr8ERKS0_S2_:
  131|  12.1M|      static SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 alignr8(const SIMD_4x64& a, const SIMD_4x64& b) {
  132|  12.1M|         return SIMD_4x64(_mm256_alignr_epi8(a.m_simd, b.m_simd, 8));
  133|  12.1M|      }
_ZNK5Botan9SIMD_4x644rotrILm1EEES0_vQaagtT_Li0EltT_Li64E:
   90|  6.09M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|       |         if constexpr(ROT == 8) {
   95|       |            auto shuf_rot_8 =
   96|       |               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|  6.09M|         } else {
  115|  6.09M|            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|  6.09M|                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|  6.09M|         }
  118|  6.09M|#endif
  119|  6.09M|      }
_ZNK5Botan9SIMD_4x64eoERKS0_:
   73|  24.3M|      SIMD_4x64 operator^(const SIMD_4x64& other) const {
   74|  24.3M|         SIMD_4x64 retval(*this);
   75|  24.3M|         retval ^= other;
   76|  24.3M|         return retval;
   77|  24.3M|      }
_ZN5Botan9SIMD_4x64eOERKS0_:
   83|  24.3M|      BOTAN_FN_ISA_SIMD_4X64 void operator^=(const SIMD_4x64& other) {
   84|  24.3M|         m_simd = _mm256_xor_si256(m_simd, other.m_simd);
   85|  24.3M|      }
_ZNK5Botan9SIMD_4x644rotrILm8EEES0_vQaagtT_Li0EltT_Li64E:
   90|  6.09M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|  6.09M|         if constexpr(ROT == 8) {
   95|  6.09M|            auto shuf_rot_8 =
   96|  6.09M|               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|  6.09M|            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|       |         } else {
  115|       |            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|       |                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|       |         }
  118|  6.09M|#endif
  119|  6.09M|      }
_ZNK5Botan9SIMD_4x643shrILi7EEES0_v:
  127|  6.09M|      SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 shr() const noexcept {
  128|  6.09M|         return SIMD_4x64(_mm256_srli_epi64(m_simd, SHIFT));
  129|  6.09M|      }
_ZNK5Botan9SIMD_4x644rotrILm19EEES0_vQaagtT_Li0EltT_Li64E:
   90|  6.09M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|       |         if constexpr(ROT == 8) {
   95|       |            auto shuf_rot_8 =
   96|       |               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|  6.09M|         } else {
  115|  6.09M|            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|  6.09M|                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|  6.09M|         }
  118|  6.09M|#endif
  119|  6.09M|      }
_ZNK5Botan9SIMD_4x644rotrILm61EEES0_vQaagtT_Li0EltT_Li64E:
   90|  6.09M|      {
   91|       |#if defined(__AVX512VL__)
   92|       |         return SIMD_4x64(_mm256_ror_epi64(m_simd, ROT));
   93|       |#else
   94|       |         if constexpr(ROT == 8) {
   95|       |            auto shuf_rot_8 =
   96|       |               _mm256_set_epi64x(0x080f0e0d0c0b0a09, 0x0007060504030201, 0x080f0e0d0c0b0a09, 0x0007060504030201);
   97|       |
   98|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_8));
   99|       |         } else if constexpr(ROT == 16) {
  100|       |            auto shuf_rot_16 =
  101|       |               _mm256_set_epi64x(0x09080f0e0d0c0b0a, 0x0100070605040302, 0x09080f0e0d0c0b0a, 0x0100070605040302);
  102|       |
  103|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_16));
  104|       |         } else if constexpr(ROT == 24) {
  105|       |            auto shuf_rot_24 =
  106|       |               _mm256_set_epi64x(0x0a09080f0e0d0c0b, 0x0201000706050403, 0x0a09080f0e0d0c0b, 0x0201000706050403);
  107|       |
  108|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_24));
  109|       |         } else if constexpr(ROT == 32) {
  110|       |            auto shuf_rot_32 =
  111|       |               _mm256_set_epi64x(0x0b0a09080f0e0d0c, 0x0302010007060504, 0x0b0a09080f0e0d0c, 0x0302010007060504);
  112|       |
  113|       |            return SIMD_4x64(_mm256_shuffle_epi8(m_simd, shuf_rot_32));
  114|  6.09M|         } else {
  115|  6.09M|            return SIMD_4x64(_mm256_or_si256(_mm256_srli_epi64(m_simd, static_cast<int>(ROT)),
  116|  6.09M|                                             _mm256_slli_epi64(m_simd, static_cast<int>(64 - ROT))));
  117|  6.09M|         }
  118|  6.09M|#endif
  119|  6.09M|      }
_ZNK5Botan9SIMD_4x643shrILi6EEES0_v:
  127|  6.09M|      SIMD_4x64 BOTAN_FN_ISA_SIMD_4X64 shr() const noexcept {
  128|  6.09M|         return SIMD_4x64(_mm256_srli_epi64(m_simd, SHIFT));
  129|  6.09M|      }

_ZN5Botan12BufferSlicerC2ENSt3__14spanIKhLm18446744073709551615EEE:
   87|  1.94M|      BufferSlicer(std::span<const uint8_t> buffer) : m_remaining(buffer) {}
_ZN5Botan12BufferSlicer4takeEm:
   99|  2.03M|      std::span<const uint8_t> take(const size_t count) {
  100|  2.03M|         BOTAN_STATE_CHECK(remaining() >= count);
  ------------------
  |  |   44|  2.03M|   do {                                                         \
  |  |   45|  2.03M|      if(!(expr))                                               \
  |  |  ------------------
  |  |  |  Branch (45:10): [True: 0, False: 2.03M]
  |  |  ------------------
  |  |   46|  2.03M|         Botan::throw_invalid_state(#expr, __func__, __FILE__); \
  |  |   47|  2.03M|   } while(0)
  |  |  ------------------
  |  |  |  Branch (47:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  101|  2.03M|         auto result = m_remaining.first(count);
  102|  2.03M|         m_remaining = m_remaining.subspan(count);
  103|  2.03M|         return result;
  104|  2.03M|      }
_ZNK5Botan12BufferSlicer9remainingEv:
  128|  5.68M|      size_t remaining() const { return m_remaining.size(); }
_ZNK5Botan12BufferSlicer5emptyEv:
  130|  3.93M|      bool empty() const { return m_remaining.empty(); }

_ZN5Botan13ignore_paramsIJRPKhRmEEEvDpOT_:
  116|   170k|constexpr void ignore_params(T&&... args) {
  117|   170k|   (ignore_param(args), ...);
  118|   170k|}
_ZN5Botan12ignore_paramIRPKhEEvOT_:
  113|   170k|constexpr void ignore_param(T&&) {}
_ZN5Botan12ignore_paramIRmEEvOT_:
  113|   170k|constexpr void ignore_param(T&&) {}
_ZN5Botan13ignore_paramsIJRPvRmEEEvDpOT_:
  116|    256|constexpr void ignore_params(T&&... args) {
  117|    256|   (ignore_param(args), ...);
  118|    256|}
_ZN5Botan12ignore_paramIRPvEEvOT_:
  113|    256|constexpr void ignore_param(T&&) {}

_ZN5Botan20Buffered_Computation6updateENSt3__14spanIKhLm18446744073709551615EEE:
   40|  2.23M|      void update(std::span<const uint8_t> in) { add_data(in); }
_ZN5Botan20Buffered_Computation5finalEPh:
   69|  91.8k|      void final(uint8_t out[]) { final_result({out, output_length()}); }
_ZN5Botan20Buffered_Computation6updateEPKhm:
   34|   170k|      void update(const uint8_t in[], size_t length) { add_data({in, length}); }
_ZN5Botan20Buffered_Computation6updateEh:
   61|   144k|      void update(uint8_t in) { add_data({&in, 1}); }
_ZN5Botan20Buffered_ComputationD2Ev:
  130|  91.8k|      virtual ~Buffered_Computation() = default;
_ZN5Botan20Buffered_Computation5finalITkNS_8concepts21resizable_byte_bufferENSt3__16vectorIhNS_16secure_allocatorIhEEEEEEvRT_:
   88|   328k|      void final(T& out) {
   89|   328k|         out.resize(output_length());
   90|   328k|         final_result(out);
   91|   328k|      }

_ZN5Botan6ranges24assert_exact_byte_lengthILm32ETkNS0_14spanable_rangeERNSt3__14spanIhLm32EEEEEvOT0_:
  108|  26.2k|inline constexpr void assert_exact_byte_length(R&& r) {
  109|  26.2k|   const std::span s{r};
  110|  26.2k|   if constexpr(statically_spanable_range<R>) {
  111|  26.2k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|  26.2k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeERNSt3__14spanIhLm18446744073709551615EEETpTkNS0_14spanable_rangeEJRNS3_IKhLm18446744073709551615EEEEEEvOT_DpOT0_QgtsZT0_Li0E:
  131|   157k|{
  132|   157k|   const std::span s0{r0};
  133|       |
  134|       |   if constexpr(statically_spanable_range<R0>) {
  135|       |      constexpr size_t expected_size = s0.size_bytes();
  136|       |      (assert_exact_byte_length<expected_size>(rs), ...);
  137|   157k|   } else {
  138|   157k|      const size_t expected_size = s0.size_bytes();
  139|   157k|      const bool correct_size =
  140|   157k|         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  141|       |
  142|   157k|      if(!correct_size) {
  ------------------
  |  Branch (142:10): [True: 0, False: 157k]
  ------------------
  143|      0|         throw Invalid_Argument("Memory regions did not have equal lengths");
  144|      0|      }
  145|   157k|   }
  146|   157k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm4ETkNS0_14spanable_rangeERNSt3__14spanIKhLm4EEEEEvOT0_:
  108|  1.60M|inline constexpr void assert_exact_byte_length(R&& r) {
  109|  1.60M|   const std::span s{r};
  110|  1.60M|   if constexpr(statically_spanable_range<R>) {
  111|  1.60M|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|  1.60M|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeERNSt3__14spanIjLm1EEETpTkNS0_14spanable_rangeEJRNS3_IKhLm4EEEEEEvOT_DpOT0_QgtsZT0_Li0E:
  131|   800k|{
  132|   800k|   const std::span s0{r0};
  133|       |
  134|   800k|   if constexpr(statically_spanable_range<R0>) {
  135|   800k|      constexpr size_t expected_size = s0.size_bytes();
  136|   800k|      (assert_exact_byte_length<expected_size>(rs), ...);
  137|       |   } else {
  138|       |      const size_t expected_size = s0.size_bytes();
  139|       |      const bool correct_size =
  140|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  141|       |
  142|       |      if(!correct_size) {
  143|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  144|       |      }
  145|       |   }
  146|   800k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeERNSt3__14spanIjLm1EEEEEmOT_:
   95|   800k|inline constexpr size_t size_bytes(spanable_range auto&& r) {
   96|   800k|   return std::span{r}.size_bytes();
   97|   800k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm8ETkNS0_14spanable_rangeERNSt3__14spanIhLm8EEEEEvOT0_:
  108|  12.8M|inline constexpr void assert_exact_byte_length(R&& r) {
  109|  12.8M|   const std::span s{r};
  110|  12.8M|   if constexpr(statically_spanable_range<R>) {
  111|  12.8M|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|  12.8M|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeERNSt3__14spanIhLm8EEETpTkNS0_14spanable_rangeEJRNS3_IKmLm1EEEEEEvOT_DpOT0_QgtsZT0_Li0E:
  131|  6.86M|{
  132|  6.86M|   const std::span s0{r0};
  133|       |
  134|  6.86M|   if constexpr(statically_spanable_range<R0>) {
  135|  6.86M|      constexpr size_t expected_size = s0.size_bytes();
  136|  6.86M|      (assert_exact_byte_length<expected_size>(rs), ...);
  137|       |   } else {
  138|       |      const size_t expected_size = s0.size_bytes();
  139|       |      const bool correct_size =
  140|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  141|       |
  142|       |      if(!correct_size) {
  143|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  144|       |      }
  145|       |   }
  146|  6.86M|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm8ETkNS0_14spanable_rangeERNSt3__14spanIKmLm1EEEEEvOT0_:
  108|  6.86M|inline constexpr void assert_exact_byte_length(R&& r) {
  109|  6.86M|   const std::span s{r};
  110|  6.86M|   if constexpr(statically_spanable_range<R>) {
  111|  6.86M|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|  6.86M|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeERNSt3__14spanIhLm8EEEEEmOT_:
   95|  6.86M|inline constexpr size_t size_bytes(spanable_range auto&& r) {
   96|  6.86M|   return std::span{r}.size_bytes();
   97|  6.86M|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm4ETkNS0_14spanable_rangeERNSt3__14spanIhLm4EEEEEvOT0_:
  108|  52.4k|inline constexpr void assert_exact_byte_length(R&& r) {
  109|  52.4k|   const std::span s{r};
  110|  52.4k|   if constexpr(statically_spanable_range<R>) {
  111|  52.4k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|  52.4k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeERNSt3__14spanIhLm4EEETpTkNS0_14spanable_rangeEJRNS3_IKjLm1EEEEEEvOT_DpOT0_QgtsZT0_Li0E:
  131|  26.2k|{
  132|  26.2k|   const std::span s0{r0};
  133|       |
  134|  26.2k|   if constexpr(statically_spanable_range<R0>) {
  135|  26.2k|      constexpr size_t expected_size = s0.size_bytes();
  136|  26.2k|      (assert_exact_byte_length<expected_size>(rs), ...);
  137|       |   } else {
  138|       |      const size_t expected_size = s0.size_bytes();
  139|       |      const bool correct_size =
  140|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  141|       |
  142|       |      if(!correct_size) {
  143|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  144|       |      }
  145|       |   }
  146|  26.2k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm4ETkNS0_14spanable_rangeERNSt3__14spanIKjLm1EEEEEvOT0_:
  108|  26.2k|inline constexpr void assert_exact_byte_length(R&& r) {
  109|  26.2k|   const std::span s{r};
  110|  26.2k|   if constexpr(statically_spanable_range<R>) {
  111|  26.2k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|  26.2k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeERNSt3__14spanIhLm4EEEEEmOT_:
   95|  26.2k|inline constexpr size_t size_bytes(spanable_range auto&& r) {
   96|  26.2k|   return std::span{r}.size_bytes();
   97|  26.2k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeERNSt3__14spanIhLm18446744073709551615EEEEEmOT_:
   95|   314k|inline constexpr size_t size_bytes(spanable_range auto&& r) {
   96|   314k|   return std::span{r}.size_bytes();
   97|   314k|}
_ZN5Botan6ranges24assert_exact_byte_lengthILm8ETkNS0_14spanable_rangeERNSt3__14spanIKhLm8EEEEEvOT0_:
  108|   367k|inline constexpr void assert_exact_byte_length(R&& r) {
  109|   367k|   const std::span s{r};
  110|   367k|   if constexpr(statically_spanable_range<R>) {
  111|   367k|      static_assert(s.size_bytes() == expected, "memory region does not have expected byte lengths");
  112|       |   } else {
  113|       |      if(s.size_bytes() != expected) {
  114|       |         throw Invalid_Argument("Memory regions did not have expected byte lengths");
  115|       |      }
  116|       |   }
  117|   367k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeERNSt3__14spanImLm1EEETpTkNS0_14spanable_rangeEJRNS3_IKhLm8EEEEEEvOT_DpOT0_QgtsZT0_Li0E:
  131|   183k|{
  132|   183k|   const std::span s0{r0};
  133|       |
  134|   183k|   if constexpr(statically_spanable_range<R0>) {
  135|   183k|      constexpr size_t expected_size = s0.size_bytes();
  136|   183k|      (assert_exact_byte_length<expected_size>(rs), ...);
  137|       |   } else {
  138|       |      const size_t expected_size = s0.size_bytes();
  139|       |      const bool correct_size =
  140|       |         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  141|       |
  142|       |      if(!correct_size) {
  143|       |         throw Invalid_Argument("Memory regions did not have equal lengths");
  144|       |      }
  145|       |   }
  146|   183k|}
_ZN5Botan6ranges10size_bytesITkNS0_14spanable_rangeERNSt3__14spanImLm1EEEEEmOT_:
   95|   183k|inline constexpr size_t size_bytes(spanable_range auto&& r) {
   96|   183k|   return std::span{r}.size_bytes();
   97|   183k|}
_ZN5Botan6ranges25assert_equal_byte_lengthsITkNS0_14spanable_rangeERNSt3__14spanIhLm18446744073709551615EEETpTkNS0_14spanable_rangeEJRNS3_IKmLm18446744073709551615EEEEEEvOT_DpOT0_QgtsZT0_Li0E:
  131|   748k|{
  132|   748k|   const std::span s0{r0};
  133|       |
  134|       |   if constexpr(statically_spanable_range<R0>) {
  135|       |      constexpr size_t expected_size = s0.size_bytes();
  136|       |      (assert_exact_byte_length<expected_size>(rs), ...);
  137|   748k|   } else {
  138|   748k|      const size_t expected_size = s0.size_bytes();
  139|   748k|      const bool correct_size =
  140|   748k|         ((std::span<const std::ranges::range_value_t<Rs>>{rs}.size_bytes() == expected_size) && ...);
  141|       |
  142|   748k|      if(!correct_size) {
  ------------------
  |  Branch (142:10): [True: 0, False: 748k]
  ------------------
  143|      0|         throw Invalid_Argument("Memory regions did not have equal lengths");
  144|      0|      }
  145|   748k|   }
  146|   748k|}

_ZNK5Botan17Ed25519_PublicKey14get_public_keyEv:
   37|  26.2k|      BOTAN_DEPRECATED("Use raw_public_key_bits") const std::vector<uint8_t>& get_public_key() const {
   38|  26.2k|         return m_public;
   39|  26.2k|      }
_ZN5Botan17Ed25519_PublicKeyC2Ev:
   59|  13.1k|      Ed25519_PublicKey() = default;
_ZN5Botan17Ed25519_PublicKeyC1ENSt3__14spanIKhLm18446744073709551615EEE:
   48|  13.1k|      Ed25519_PublicKey(std::span<const uint8_t> pub) : Ed25519_PublicKey(pub.data(), pub.size()) {}

_ZNK5Botan9HMAC_DRBG31max_number_of_bytes_per_requestEv:
  130|  39.3k|      size_t max_number_of_bytes_per_request() const override { return m_max_number_of_bytes_per_request; }

_ZN5Botan25MessageAuthenticationCodeD2Ev:
   50|  13.1k|      ~MessageAuthenticationCode() override = default;

_ZN5Botan9clear_memIhEEvPT_m:
  123|  2.04M|inline constexpr void clear_mem(T* ptr, size_t n) {
  124|  2.04M|   clear_bytes(ptr, sizeof(T) * n);
  125|  2.04M|}
_ZN5Botan11clear_bytesEPvm:
  106|  80.3M|inline constexpr void clear_bytes(void* ptr, size_t bytes) {
  107|  80.3M|   if(bytes > 0) {
  ------------------
  |  Branch (107:7): [True: 80.3M, False: 0]
  ------------------
  108|  80.3M|      std::memset(ptr, 0, bytes);
  109|  80.3M|   }
  110|  80.3M|}
_ZN5Botan22cast_char_ptr_to_uint8EPKc:
  276|  26.2k|inline const uint8_t* cast_char_ptr_to_uint8(const char* s) {
  277|  26.2k|   return reinterpret_cast<const uint8_t*>(s);
  278|  26.2k|}
_ZN5Botan8copy_memIhQsr3std10is_trivialINSt3__15decayIT_E4typeEEE5valueEEvPS3_PKS3_m:
  149|   104k|inline constexpr void copy_mem(T* out, const T* in, size_t n) {
  150|   104k|   BOTAN_ASSERT_IMPLICATION(n > 0, in != nullptr && out != nullptr, "If n > 0 then args are not null");
  ------------------
  |  |   80|   104k|   do {                                                                                          \
  |  |   81|   209k|      if((expr1) && !(expr2))                                                                    \
  |  |  ------------------
  |  |  |  Branch (81:10): [True: 104k, False: 0]
  |  |  |  Branch (81:23): [True: 104k, False: 0]
  |  |  |  Branch (81:23): [True: 104k, False: 0]
  |  |  ------------------
  |  |   82|   104k|         Botan::assertion_failure(#expr1 " implies " #expr2, msg, __func__, __FILE__, __LINE__); \
  |  |   83|   104k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (83:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  151|       |
  152|   104k|   if(in != nullptr && out != nullptr && n > 0) {
  ------------------
  |  Branch (152:7): [True: 104k, False: 0]
  |  Branch (152:24): [True: 104k, False: 0]
  |  Branch (152:42): [True: 104k, False: 0]
  ------------------
  153|   104k|      std::memmove(out, in, sizeof(T) * n);
  154|   104k|   }
  155|   104k|}
_ZN5Botan9clear_memIiEEvPT_m:
  123|  78.3M|inline constexpr void clear_mem(T* ptr, size_t n) {
  124|  78.3M|   clear_bytes(ptr, sizeof(T) * n);
  125|  78.3M|}
_ZN5Botan8copy_memIiQsr3std10is_trivialINSt3__15decayIT_E4typeEEE5valueEEvPS3_PKS3_m:
  149|  1.56k|inline constexpr void copy_mem(T* out, const T* in, size_t n) {
  150|  1.56k|   BOTAN_ASSERT_IMPLICATION(n > 0, in != nullptr && out != nullptr, "If n > 0 then args are not null");
  ------------------
  |  |   80|  1.56k|   do {                                                                                          \
  |  |   81|  3.12k|      if((expr1) && !(expr2))                                                                    \
  |  |  ------------------
  |  |  |  Branch (81:10): [True: 1.56k, False: 0]
  |  |  |  Branch (81:23): [True: 1.56k, False: 0]
  |  |  |  Branch (81:23): [True: 1.56k, False: 0]
  |  |  ------------------
  |  |   82|  1.56k|         Botan::assertion_failure(#expr1 " implies " #expr2, msg, __func__, __FILE__, __LINE__); \
  |  |   83|  1.56k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (83:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  151|       |
  152|  1.56k|   if(in != nullptr && out != nullptr && n > 0) {
  ------------------
  |  Branch (152:7): [True: 1.56k, False: 0]
  |  Branch (152:24): [True: 1.56k, False: 0]
  |  Branch (152:42): [True: 1.56k, False: 0]
  ------------------
  153|  1.56k|      std::memmove(out, in, sizeof(T) * n);
  154|  1.56k|   }
  155|  1.56k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeENSt3__14spanIjLm1EEETkNS1_16contiguous_rangeERNS3_IKhLm4EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEEEvOSM_OSC_:
  181|   800k|inline constexpr void typecast_copy(ToR&& out, FromR&& in) {
  182|   800k|   ranges::assert_equal_byte_lengths(out, in);
  183|   800k|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|   800k|}
_ZN5Botan13typecast_copyIjTkNS_6ranges16contiguous_rangeERNSt3__14spanIKhLm4EEEQaaaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEsr3stdE23is_trivially_copyable_vIT_Entsr3std6rangesE5rangeISL_EEEvRSL_OSB_:
  193|   800k|inline constexpr void typecast_copy(ToT& out, FromR&& in) noexcept {
  194|   800k|   typecast_copy(std::span<ToT, 1>(&out, 1), in);
  195|   800k|}
_ZN5Botan13typecast_copyIjTkNS_6ranges16contiguous_rangeERNSt3__14spanIKhLm4EEEQaaaasr3stdE26is_default_constructible_vIT_Esr3stdE23is_trivially_copyable_vIS7_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEEES7_OSC_:
  215|   800k|inline constexpr ToT typecast_copy(FromR&& src) noexcept {
  216|   800k|   ToT dst;
  217|   800k|   typecast_copy(dst, src);
  218|   800k|   return dst;
  219|   800k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm8EEEmQaaaasr3stdE23is_trivially_copyable_vIT0_Entsr3std6rangesE5rangeIS6_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEEEvOSB_RKS6_:
  204|  6.86M|inline constexpr void typecast_copy(ToR&& out, const FromT& in) {
  205|  6.86M|   typecast_copy(out, std::span<const FromT, 1>(&in, 1));
  206|  6.86M|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm8EEETkNS1_16contiguous_rangeENS3_IKmLm1EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEEEvOSM_OSC_:
  181|  6.86M|inline constexpr void typecast_copy(ToR&& out, FromR&& in) {
  182|  6.86M|   ranges::assert_equal_byte_lengths(out, in);
  183|  6.86M|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|  6.86M|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm4EEEjQaaaasr3stdE23is_trivially_copyable_vIT0_Entsr3std6rangesE5rangeIS6_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEEEvOSB_RKS6_:
  204|  26.2k|inline constexpr void typecast_copy(ToR&& out, const FromT& in) {
  205|  26.2k|   typecast_copy(out, std::span<const FromT, 1>(&in, 1));
  206|  26.2k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeERNSt3__14spanIhLm4EEETkNS1_16contiguous_rangeENS3_IKjLm1EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEEEvOSM_OSC_:
  181|  26.2k|inline constexpr void typecast_copy(ToR&& out, FromR&& in) {
  182|  26.2k|   ranges::assert_equal_byte_lengths(out, in);
  183|  26.2k|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|  26.2k|}
_ZN5Botan13typecast_copyImTkNS_6ranges16contiguous_rangeERNSt3__14spanIKhLm8EEEQaaaasr3stdE26is_default_constructible_vIT_Esr3stdE23is_trivially_copyable_vIS7_Esr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEEES7_OSC_:
  215|   183k|inline constexpr ToT typecast_copy(FromR&& src) noexcept {
  216|   183k|   ToT dst;
  217|   183k|   typecast_copy(dst, src);
  218|   183k|   return dst;
  219|   183k|}
_ZN5Botan13typecast_copyImTkNS_6ranges16contiguous_rangeERNSt3__14spanIKhLm8EEEQaaaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISE_EESF_E4type10value_typeEEsr3stdE23is_trivially_copyable_vIT_Entsr3std6rangesE5rangeISL_EEEvRSL_OSB_:
  193|   183k|inline constexpr void typecast_copy(ToT& out, FromR&& in) noexcept {
  194|   183k|   typecast_copy(std::span<ToT, 1>(&out, 1), in);
  195|   183k|}
_ZN5Botan13typecast_copyITkNS_6ranges23contiguous_output_rangeENSt3__14spanImLm1EEETkNS1_16contiguous_rangeERNS3_IKhLm8EEEQaasr3stdE23is_trivially_copyable_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeEEsr3stdE23is_trivially_copyable_vINS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEEEvOSM_OSC_:
  181|   183k|inline constexpr void typecast_copy(ToR&& out, FromR&& in) {
  182|   183k|   ranges::assert_equal_byte_lengths(out, in);
  183|   183k|   std::memcpy(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  184|   183k|}
_ZN5Botan8copy_memImQsr3std10is_trivialINSt3__15decayIT_E4typeEEE5valueEEvPS3_PKS3_m:
  149|  20.2M|inline constexpr void copy_mem(T* out, const T* in, size_t n) {
  150|  20.2M|   BOTAN_ASSERT_IMPLICATION(n > 0, in != nullptr && out != nullptr, "If n > 0 then args are not null");
  ------------------
  |  |   80|  20.2M|   do {                                                                                          \
  |  |   81|  40.4M|      if((expr1) && !(expr2))                                                                    \
  |  |  ------------------
  |  |  |  Branch (81:10): [True: 20.2M, False: 0]
  |  |  |  Branch (81:23): [True: 20.2M, False: 0]
  |  |  |  Branch (81:23): [True: 20.2M, False: 0]
  |  |  ------------------
  |  |   82|  20.2M|         Botan::assertion_failure(#expr1 " implies " #expr2, msg, __func__, __FILE__, __LINE__); \
  |  |   83|  20.2M|   } while(0)
  |  |  ------------------
  |  |  |  Branch (83:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  151|       |
  152|  20.2M|   if(in != nullptr && out != nullptr && n > 0) {
  ------------------
  |  Branch (152:7): [True: 20.2M, False: 0]
  |  Branch (152:24): [True: 20.2M, False: 0]
  |  Branch (152:42): [True: 20.2M, False: 0]
  ------------------
  153|  20.2M|      std::memmove(out, in, sizeof(T) * n);
  154|  20.2M|   }
  155|  20.2M|}
_ZN5Botan8copy_memITkNS_6ranges23contiguous_output_rangeENSt3__14spanIhLm18446744073709551615EEETkNS1_16contiguous_rangeERNS3_IKhLm18446744073709551615EEEQaasr3stdE9is_same_vINS2_11conditionalIXsr21__is_primary_templateINS2_15iterator_traitsIu14__remove_cvrefIDTclL_ZNS2_6ranges5__cpo5beginEEclsr3stdE7declvalIRT_EEEEEEEEE5valueENS2_26indirectly_readable_traitsISF_EESG_E4type10value_typeENS8_IXsr21__is_primary_templateINS9_Iu14__remove_cvrefIDTclL_ZNSB_5beginEEclsr3stdE7declvalIRT0_EEEEEEEEE5valueENSH_ISP_EESQ_E4type10value_typeEEsr3stdE23is_trivially_copyable_vISU_EEEvOSC_OSM_:
  165|   157k|inline constexpr void copy_mem(OutR&& out, InR&& in) {
  166|   157k|   ranges::assert_equal_byte_lengths(out, in);
  167|   157k|   if(std::is_constant_evaluated()) {
  ------------------
  |  Branch (167:7): [Folded - Ignored]
  ------------------
  168|      0|      std::copy(std::ranges::begin(in), std::ranges::end(in), std::ranges::begin(out));
  169|   157k|   } else if(ranges::size_bytes(out) > 0) {
  ------------------
  |  Branch (169:14): [True: 157k, False: 0]
  ------------------
  170|   157k|      std::memmove(std::ranges::data(out), std::ranges::data(in), ranges::size_bytes(out));
  171|   157k|   }
  172|   157k|}
_ZN5Botan9clear_memIjEEvPT_m:
  123|      6|inline constexpr void clear_mem(T* ptr, size_t n) {
  124|      6|   clear_bytes(ptr, sizeof(T) * n);
  125|      6|}

_ZNK5Botan14Asymmetric_Key40_signature_element_size_for_DER_encodingEv:
  137|  26.2k|      virtual std::optional<size_t> _signature_element_size_for_DER_encoding() const { return {}; }

_ZN5Botan6PK_Ops12VerificationD2Ev:
   99|  13.1k|      virtual ~Verification() = default;
_ZN5Botan6PK_Ops9SignatureD2Ev:
  136|  13.1k|      virtual ~Signature() = default;

_ZN5Botan21RandomNumberGenerator9randomizeENSt3__14spanIhLm18446744073709551615EEE:
   68|  65.6k|      void randomize(std::span<uint8_t> output) { this->fill_bytes_with_input(output, {}); }
_ZN5Botan21RandomNumberGenerator11add_entropyENSt3__14spanIKhLm18446744073709551615EEE:
   91|  13.1k|      void add_entropy(std::span<const uint8_t> input) { this->fill_bytes_with_input({}, input); }
_ZN5Botan21RandomNumberGenerator10random_vecENSt3__14spanIhLm18446744073709551615EEE:
  196|  39.3k|      void random_vec(std::span<uint8_t> v) { this->randomize(v); }
_ZN5Botan21RandomNumberGenerator9next_byteEv:
  244|  13.1k|      uint8_t next_byte() {
  245|  13.1k|         uint8_t b;
  246|  13.1k|         this->fill_bytes_with_input(std::span(&b, 1), {});
  247|  13.1k|         return b;
  248|  13.1k|      }
_ZN5Botan21RandomNumberGenerator10random_vecITkNS_8concepts21resizable_byte_bufferENSt3__16vectorIhNS_16secure_allocatorIhEEEEQsr3stdE21default_initializableIT_EEES8_m:
  222|  39.3k|      T random_vec(size_t bytes) {
  223|  39.3k|         T result;
  224|  39.3k|         random_vec(result, bytes);
  225|  39.3k|         return result;
  226|  39.3k|      }
_ZN5Botan21RandomNumberGenerator10random_vecITkNS_8concepts21resizable_byte_bufferENSt3__16vectorIhNS_16secure_allocatorIhEEEEEEvRT_m:
  207|  39.3k|      void random_vec(T& v, size_t bytes) {
  208|  39.3k|         v.resize(bytes);
  209|  39.3k|         random_vec(v);
  210|  39.3k|      }
_ZN5Botan21RandomNumberGeneratorD2Ev:
   48|  26.2k|      virtual ~RandomNumberGenerator() = default;
_ZN5Botan21RandomNumberGeneratorC2Ev:
   50|  26.2k|      RandomNumberGenerator() = default;

_ZN5Botan16secure_allocatorImE8allocateEm:
   48|  78.7k|      T* allocate(std::size_t n) { return static_cast<T*>(allocate_memory(n, sizeof(T))); }
_ZN5Botan16secure_allocatorImE10deallocateEPmm:
   50|  78.7k|      void deallocate(T* p, std::size_t n) { deallocate_memory(p, n, sizeof(T)); }

_ZN5Botan12Stateful_RNGC2ERNS_21RandomNumberGeneratorEm:
   45|  13.1k|            m_underlying_rng(&rng), m_reseed_interval(reseed_interval) {}
_ZNK5Botan12Stateful_RNG13accepts_inputEv:
   71|  39.3k|      bool accepts_input() const final { return true; }

_ZN5Botan16wrap_strong_typeIjRjQoosr3stdE18constructible_fromIT_T0_Eaasr8conceptsE11strong_typeIS2_Esr3stdE18constructible_fromINS2_12wrapped_typeES3_EEEDcOS3_:
  248|   800k|[[nodiscard]] constexpr decltype(auto) wrap_strong_type(ParamT&& t) {
  249|   800k|   if constexpr(std::same_as<std::remove_cvref_t<ParamT>, T>) {
  250|       |      // Noop, if the parameter type already is the desired return type.
  251|   800k|      return std::forward<ParamT>(t);
  252|       |   } else if constexpr(std::constructible_from<T, ParamT>) {
  253|       |      // Implicit conversion from the parameter type to the return type.
  254|       |      return T{std::forward<ParamT>(t)};
  255|       |   } else {
  256|       |      // Explicitly calling the wrapped type's constructor to support
  257|       |      // implicit conversions on types that mark their constructors as explicit.
  258|       |      static_assert(concepts::strong_type<T> && std::constructible_from<typename T::wrapped_type, ParamT>);
  259|       |      return T{typename T::wrapped_type{std::forward<ParamT>(t)}};
  260|       |   }
  261|   800k|}
_ZN5Botan18unwrap_strong_typeIRmEEDcOT_:
  223|  6.86M|[[nodiscard]] constexpr decltype(auto) unwrap_strong_type(T&& t) {
  224|  6.86M|   if constexpr(!concepts::strong_type<std::remove_cvref_t<T>>) {
  225|       |      // If the parameter type isn't a strong type, return it as is.
  226|  6.86M|      return std::forward<T>(t);
  227|       |   } else {
  228|       |      // Unwrap the strong type and return the underlying value.
  229|       |      return std::forward<T>(t).get();
  230|       |   }
  231|  6.86M|}
_ZN5Botan18unwrap_strong_typeIRjEEDcOT_:
  223|  26.2k|[[nodiscard]] constexpr decltype(auto) unwrap_strong_type(T&& t) {
  224|  26.2k|   if constexpr(!concepts::strong_type<std::remove_cvref_t<T>>) {
  225|       |      // If the parameter type isn't a strong type, return it as is.
  226|  26.2k|      return std::forward<T>(t);
  227|       |   } else {
  228|       |      // Unwrap the strong type and return the underlying value.
  229|       |      return std::forward<T>(t).get();
  230|       |   }
  231|  26.2k|}
_ZN5Botan16wrap_strong_typeImRmQoosr3stdE18constructible_fromIT_T0_Eaasr8conceptsE11strong_typeIS2_Esr3stdE18constructible_fromINS2_12wrapped_typeES3_EEEDcOS3_:
  248|   183k|[[nodiscard]] constexpr decltype(auto) wrap_strong_type(ParamT&& t) {
  249|   183k|   if constexpr(std::same_as<std::remove_cvref_t<ParamT>, T>) {
  250|       |      // Noop, if the parameter type already is the desired return type.
  251|   183k|      return std::forward<ParamT>(t);
  252|       |   } else if constexpr(std::constructible_from<T, ParamT>) {
  253|       |      // Implicit conversion from the parameter type to the return type.
  254|       |      return T{std::forward<ParamT>(t)};
  255|       |   } else {
  256|       |      // Explicitly calling the wrapped type's constructor to support
  257|       |      // implicit conversions on types that mark their constructors as explicit.
  258|       |      static_assert(concepts::strong_type<T> && std::constructible_from<typename T::wrapped_type, ParamT>);
  259|       |      return T{typename T::wrapped_type{std::forward<ParamT>(t)}};
  260|       |   }
  261|   183k|}

_ZN5Botan24Key_Length_SpecificationC2Emmm:
   38|   157k|            m_min_keylen(min_k), m_max_keylen(max_k ? max_k : min_k), m_keylen_mod(k_mod) {}
  ------------------
  |  Branch (38:47): [True: 157k, False: 0]
  ------------------
_ZNK5Botan24Key_Length_Specification15valid_keylengthEm:
   44|   157k|      bool valid_keylength(size_t length) const {
   45|   157k|         return ((length >= m_min_keylen) && (length <= m_max_keylen) && (length % m_keylen_mod == 0));
  ------------------
  |  Branch (45:18): [True: 157k, False: 0]
  |  Branch (45:46): [True: 157k, False: 0]
  |  Branch (45:74): [True: 157k, False: 0]
  ------------------
   46|   157k|      }
_ZNK5Botan18SymmetricAlgorithm15valid_keylengthEm:
  109|   157k|      bool valid_keylength(size_t length) const { return key_spec().valid_keylength(length); }
_ZNK5Botan18SymmetricAlgorithm23assert_key_material_setEv:
  141|   931k|      void assert_key_material_set() const { assert_key_material_set(has_keying_material()); }
_ZNK5Botan18SymmetricAlgorithm23assert_key_material_setEb:
  143|   931k|      void assert_key_material_set(bool predicate) const {
  144|   931k|         if(!predicate) {
  ------------------
  |  Branch (144:13): [True: 0, False: 931k]
  ------------------
  145|      0|            throw_key_not_set_error();
  146|      0|         }
  147|   931k|      }
_ZN5Botan18SymmetricAlgorithmD2Ev:
   81|  13.1k|      virtual ~SymmetricAlgorithm() = default;

_ZNK5Botan17X25519_PrivateKey12public_valueEv:
   82|  13.1k|      std::vector<uint8_t> public_value() const override { return raw_public_key_bits(); }
_ZN5Botan16X25519_PublicKeyC2Ev:
   52|  13.1k|      X25519_PublicKey() = default;

_ZN5Botan20Buffered_Computation5finalENSt3__14spanIhLm18446744073709551615EEE:
   53|   656k|void Buffered_Computation::final(std::span<uint8_t> out) {
   54|   656k|   BOTAN_ARG_CHECK(out.size() >= output_length(), "provided output buffer has insufficient capacity");
  ------------------
  |  |   32|   656k|   do {                                                          \
  |  |   33|   656k|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (33:10): [True: 0, False: 656k]
  |  |  ------------------
  |  |   34|   656k|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   35|   656k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (35:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   55|   656k|   final_result(out);
   56|   656k|}

_ZN5Botan18SymmetricAlgorithm7set_keyENSt3__14spanIKhLm18446744073709551615EEE:
   22|   157k|void SymmetricAlgorithm::set_key(std::span<const uint8_t> key) {
   23|   157k|   if(!valid_keylength(key.size())) {
  ------------------
  |  Branch (23:7): [True: 0, False: 157k]
  ------------------
   24|      0|      throw Invalid_Key_Length(name(), key.size());
   25|      0|   }
   26|   157k|   key_schedule(key);
   27|   157k|}

_ZN5Botan12HashFunction6createENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
  107|  39.3k|std::unique_ptr<HashFunction> HashFunction::create(std::string_view algo_spec, std::string_view provider) {
  108|       |#if defined(BOTAN_HAS_COMMONCRYPTO)
  109|       |   if(provider.empty() || provider == "commoncrypto") {
  110|       |      if(auto hash = make_commoncrypto_hash(algo_spec))
  111|       |         return hash;
  112|       |
  113|       |      if(!provider.empty())
  114|       |         return nullptr;
  115|       |   }
  116|       |#endif
  117|       |
  118|  39.3k|   if(provider.empty() == false && provider != "base") {
  ------------------
  |  Branch (118:7): [True: 0, False: 39.3k]
  |  Branch (118:36): [True: 0, False: 0]
  ------------------
  119|      0|      return nullptr;  // unknown provider
  120|      0|   }
  121|       |
  122|  39.3k|#if defined(BOTAN_HAS_SHA1)
  123|  39.3k|   if(algo_spec == "SHA-1") {
  ------------------
  |  Branch (123:7): [True: 0, False: 39.3k]
  ------------------
  124|      0|      return std::make_unique<SHA_1>();
  125|      0|   }
  126|  39.3k|#endif
  127|       |
  128|  39.3k|#if defined(BOTAN_HAS_SHA2_32)
  129|  39.3k|   if(algo_spec == "SHA-224") {
  ------------------
  |  Branch (129:7): [True: 0, False: 39.3k]
  ------------------
  130|      0|      return std::make_unique<SHA_224>();
  131|      0|   }
  132|       |
  133|  39.3k|   if(algo_spec == "SHA-256") {
  ------------------
  |  Branch (133:7): [True: 0, False: 39.3k]
  ------------------
  134|      0|      return std::make_unique<SHA_256>();
  135|      0|   }
  136|  39.3k|#endif
  137|       |
  138|  39.3k|#if defined(BOTAN_HAS_SHA2_64)
  139|  39.3k|   if(algo_spec == "SHA-384") {
  ------------------
  |  Branch (139:7): [True: 0, False: 39.3k]
  ------------------
  140|      0|      return std::make_unique<SHA_384>();
  141|      0|   }
  142|       |
  143|  39.3k|   if(algo_spec == "SHA-512") {
  ------------------
  |  Branch (143:7): [True: 39.3k, False: 0]
  ------------------
  144|  39.3k|      return std::make_unique<SHA_512>();
  145|  39.3k|   }
  146|       |
  147|      0|   if(algo_spec == "SHA-512-256") {
  ------------------
  |  Branch (147:7): [True: 0, False: 0]
  ------------------
  148|      0|      return std::make_unique<SHA_512_256>();
  149|      0|   }
  150|      0|#endif
  151|       |
  152|      0|#if defined(BOTAN_HAS_RIPEMD_160)
  153|      0|   if(algo_spec == "RIPEMD-160") {
  ------------------
  |  Branch (153:7): [True: 0, False: 0]
  ------------------
  154|      0|      return std::make_unique<RIPEMD_160>();
  155|      0|   }
  156|      0|#endif
  157|       |
  158|      0|#if defined(BOTAN_HAS_WHIRLPOOL)
  159|      0|   if(algo_spec == "Whirlpool") {
  ------------------
  |  Branch (159:7): [True: 0, False: 0]
  ------------------
  160|      0|      return std::make_unique<Whirlpool>();
  161|      0|   }
  162|      0|#endif
  163|       |
  164|      0|#if defined(BOTAN_HAS_MD5)
  165|      0|   if(algo_spec == "MD5") {
  ------------------
  |  Branch (165:7): [True: 0, False: 0]
  ------------------
  166|      0|      return std::make_unique<MD5>();
  167|      0|   }
  168|      0|#endif
  169|       |
  170|      0|#if defined(BOTAN_HAS_MD4)
  171|      0|   if(algo_spec == "MD4") {
  ------------------
  |  Branch (171:7): [True: 0, False: 0]
  ------------------
  172|      0|      return std::make_unique<MD4>();
  173|      0|   }
  174|      0|#endif
  175|       |
  176|      0|#if defined(BOTAN_HAS_GOST_34_11)
  177|      0|   if(algo_spec == "GOST-R-34.11-94" || algo_spec == "GOST-34.11") {
  ------------------
  |  Branch (177:7): [True: 0, False: 0]
  |  Branch (177:41): [True: 0, False: 0]
  ------------------
  178|      0|      return std::make_unique<GOST_34_11>();
  179|      0|   }
  180|      0|#endif
  181|       |
  182|      0|#if defined(BOTAN_HAS_ADLER32)
  183|      0|   if(algo_spec == "Adler32") {
  ------------------
  |  Branch (183:7): [True: 0, False: 0]
  ------------------
  184|      0|      return std::make_unique<Adler32>();
  185|      0|   }
  186|      0|#endif
  187|       |
  188|      0|#if defined(BOTAN_HAS_CRC24)
  189|      0|   if(algo_spec == "CRC24") {
  ------------------
  |  Branch (189:7): [True: 0, False: 0]
  ------------------
  190|      0|      return std::make_unique<CRC24>();
  191|      0|   }
  192|      0|#endif
  193|       |
  194|      0|#if defined(BOTAN_HAS_CRC32)
  195|      0|   if(algo_spec == "CRC32") {
  ------------------
  |  Branch (195:7): [True: 0, False: 0]
  ------------------
  196|      0|      return std::make_unique<CRC32>();
  197|      0|   }
  198|      0|#endif
  199|       |
  200|      0|#if defined(BOTAN_HAS_STREEBOG)
  201|      0|   if(algo_spec == "Streebog-256") {
  ------------------
  |  Branch (201:7): [True: 0, False: 0]
  ------------------
  202|      0|      return std::make_unique<Streebog>(256);
  203|      0|   }
  204|      0|   if(algo_spec == "Streebog-512") {
  ------------------
  |  Branch (204:7): [True: 0, False: 0]
  ------------------
  205|      0|      return std::make_unique<Streebog>(512);
  206|      0|   }
  207|      0|#endif
  208|       |
  209|      0|#if defined(BOTAN_HAS_SM3)
  210|      0|   if(algo_spec == "SM3") {
  ------------------
  |  Branch (210:7): [True: 0, False: 0]
  ------------------
  211|      0|      return std::make_unique<SM3>();
  212|      0|   }
  213|      0|#endif
  214|       |
  215|      0|   const SCAN_Name req(algo_spec);
  216|       |
  217|      0|#if defined(BOTAN_HAS_SKEIN_512)
  218|      0|   if(req.algo_name() == "Skein-512") {
  ------------------
  |  Branch (218:7): [True: 0, False: 0]
  ------------------
  219|      0|      return std::make_unique<Skein_512>(req.arg_as_integer(0, 512), req.arg(1, ""));
  220|      0|   }
  221|      0|#endif
  222|       |
  223|      0|#if defined(BOTAN_HAS_BLAKE2B)
  224|      0|   if(req.algo_name() == "Blake2b" || req.algo_name() == "BLAKE2b") {
  ------------------
  |  Branch (224:7): [True: 0, False: 0]
  |  Branch (224:39): [True: 0, False: 0]
  ------------------
  225|      0|      return std::make_unique<BLAKE2b>(req.arg_as_integer(0, 512));
  226|      0|   }
  227|      0|#endif
  228|       |
  229|      0|#if defined(BOTAN_HAS_BLAKE2S)
  230|      0|   if(req.algo_name() == "Blake2s" || req.algo_name() == "BLAKE2s") {
  ------------------
  |  Branch (230:7): [True: 0, False: 0]
  |  Branch (230:39): [True: 0, False: 0]
  ------------------
  231|      0|      return std::make_unique<BLAKE2s>(req.arg_as_integer(0, 256));
  232|      0|   }
  233|      0|#endif
  234|       |
  235|      0|#if defined(BOTAN_HAS_KECCAK)
  236|      0|   if(req.algo_name() == "Keccak-1600") {
  ------------------
  |  Branch (236:7): [True: 0, False: 0]
  ------------------
  237|      0|      return std::make_unique<Keccak_1600>(req.arg_as_integer(0, 512));
  238|      0|   }
  239|      0|#endif
  240|       |
  241|      0|#if defined(BOTAN_HAS_SHA3)
  242|      0|   if(req.algo_name() == "SHA-3") {
  ------------------
  |  Branch (242:7): [True: 0, False: 0]
  ------------------
  243|      0|      return std::make_unique<SHA_3>(req.arg_as_integer(0, 512));
  244|      0|   }
  245|      0|#endif
  246|       |
  247|      0|#if defined(BOTAN_HAS_SHAKE)
  248|      0|   if(req.algo_name() == "SHAKE-128" && req.arg_count() == 1) {
  ------------------
  |  Branch (248:7): [True: 0, False: 0]
  |  Branch (248:41): [True: 0, False: 0]
  ------------------
  249|      0|      return std::make_unique<SHAKE_128>(req.arg_as_integer(0));
  250|      0|   }
  251|      0|   if(req.algo_name() == "SHAKE-256" && req.arg_count() == 1) {
  ------------------
  |  Branch (251:7): [True: 0, False: 0]
  |  Branch (251:41): [True: 0, False: 0]
  ------------------
  252|      0|      return std::make_unique<SHAKE_256>(req.arg_as_integer(0));
  253|      0|   }
  254|      0|#endif
  255|       |
  256|      0|#if defined(BOTAN_HAS_PARALLEL_HASH)
  257|      0|   if(req.algo_name() == "Parallel") {
  ------------------
  |  Branch (257:7): [True: 0, False: 0]
  ------------------
  258|      0|      std::vector<std::unique_ptr<HashFunction>> hashes;
  259|       |
  260|      0|      for(size_t i = 0; i != req.arg_count(); ++i) {
  ------------------
  |  Branch (260:25): [True: 0, False: 0]
  ------------------
  261|      0|         auto h = HashFunction::create(req.arg(i));
  262|      0|         if(!h) {
  ------------------
  |  Branch (262:13): [True: 0, False: 0]
  ------------------
  263|      0|            return nullptr;
  264|      0|         }
  265|      0|         hashes.push_back(std::move(h));
  266|      0|      }
  267|       |
  268|      0|      return std::make_unique<Parallel>(hashes);
  269|      0|   }
  270|      0|#endif
  271|       |
  272|      0|#if defined(BOTAN_HAS_TRUNCATED_HASH)
  273|      0|   if(req.algo_name() == "Truncated" && req.arg_count() == 2) {
  ------------------
  |  Branch (273:7): [True: 0, False: 0]
  |  Branch (273:41): [True: 0, False: 0]
  ------------------
  274|      0|      auto hash = HashFunction::create(req.arg(0));
  275|      0|      if(!hash) {
  ------------------
  |  Branch (275:10): [True: 0, False: 0]
  ------------------
  276|      0|         return nullptr;
  277|      0|      }
  278|       |
  279|      0|      return std::make_unique<Truncated_Hash>(std::move(hash), req.arg_as_integer(1));
  280|      0|   }
  281|      0|#endif
  282|       |
  283|      0|#if defined(BOTAN_HAS_COMB4P)
  284|      0|   if(req.algo_name() == "Comb4P" && req.arg_count() == 2) {
  ------------------
  |  Branch (284:7): [True: 0, False: 0]
  |  Branch (284:38): [True: 0, False: 0]
  ------------------
  285|      0|      auto h1 = HashFunction::create(req.arg(0));
  286|      0|      auto h2 = HashFunction::create(req.arg(1));
  287|       |
  288|      0|      if(h1 && h2) {
  ------------------
  |  Branch (288:10): [True: 0, False: 0]
  |  Branch (288:16): [True: 0, False: 0]
  ------------------
  289|      0|         return std::make_unique<Comb4P>(std::move(h1), std::move(h2));
  290|      0|      }
  291|      0|   }
  292|      0|#endif
  293|       |
  294|      0|   return nullptr;
  295|      0|}
_ZN5Botan12HashFunction15create_or_throwENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
  298|  26.2k|std::unique_ptr<HashFunction> HashFunction::create_or_throw(std::string_view algo, std::string_view provider) {
  299|  26.2k|   if(auto hash = HashFunction::create(algo, provider)) {
  ------------------
  |  Branch (299:12): [True: 26.2k, False: 0]
  ------------------
  300|  26.2k|      return hash;
  301|  26.2k|   }
  302|      0|   throw Lookup_Error("Hash", algo, provider);
  303|  26.2k|}

_ZN5Botan7SHA_51215compress_digestERNSt3__16vectorImNS_16secure_allocatorImEEEENS1_4spanIKhLm18446744073709551615EEEm:
   52|  1.62M|void SHA_512::compress_digest(digest_type& digest, std::span<const uint8_t> input, size_t blocks) {
   53|  1.62M|#if defined(BOTAN_HAS_SHA2_64_X86)
   54|  1.62M|   if(CPUID::has(CPUID::Feature::SHA512)) {
  ------------------
  |  Branch (54:7): [True: 0, False: 1.62M]
  ------------------
   55|      0|      return compress_digest_x86(digest, input, blocks);
   56|      0|   }
   57|  1.62M|#endif
   58|       |
   59|       |#if defined(BOTAN_HAS_SHA2_64_ARMV8)
   60|       |   if(CPUID::has(CPUID::Feature::SHA2_512)) {
   61|       |      return compress_digest_armv8(digest, input, blocks);
   62|       |   }
   63|       |#endif
   64|       |
   65|  1.62M|#if defined(BOTAN_HAS_SHA2_64_X86_AVX2)
   66|  1.62M|   if(CPUID::has(CPUID::Feature::AVX2) && CPUID::has(CPUID::Feature::BMI)) {
  ------------------
  |  Branch (66:7): [True: 1.62M, False: 0]
  |  Branch (66:43): [True: 1.62M, False: 0]
  ------------------
   67|  1.62M|      return compress_digest_x86_avx2(digest, input, blocks);
   68|  1.62M|   }
   69|      0|#endif
   70|       |
   71|      0|   uint64_t A = digest[0], B = digest[1], C = digest[2], D = digest[3], E = digest[4], F = digest[5], G = digest[6],
   72|      0|            H = digest[7];
   73|       |
   74|      0|   std::array<uint64_t, 16> W;
   75|       |
   76|      0|   BufferSlicer in(input);
   77|       |
   78|      0|   for(size_t i = 0; i != blocks; ++i) {
  ------------------
  |  Branch (78:22): [True: 0, False: 0]
  ------------------
   79|      0|      load_be(W, in.take<block_bytes>());
   80|       |
   81|       |      // clang-format off
   82|       |
   83|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0x428A2F98D728AE22);
   84|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0x7137449123EF65CD);
   85|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0xB5C0FBCFEC4D3B2F);
   86|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0xE9B5DBA58189DBBC);
   87|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x3956C25BF348B538);
   88|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x59F111F1B605D019);
   89|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x923F82A4AF194F9B);
   90|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0xAB1C5ED5DA6D8118);
   91|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0xD807AA98A3030242);
   92|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0x12835B0145706FBE);
   93|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0x243185BE4EE4B28C);
   94|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0x550C7DC3D5FFB4E2);
   95|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0x72BE5D74F27B896F);
   96|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0x80DEB1FE3B1696B1);
   97|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0x9BDC06A725C71235);
   98|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0xC19BF174CF692694);
   99|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0xE49B69C19EF14AD2);
  100|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0xEFBE4786384F25E3);
  101|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0x0FC19DC68B8CD5B5);
  102|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0x240CA1CC77AC9C65);
  103|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x2DE92C6F592B0275);
  104|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x4A7484AA6EA6E483);
  105|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x5CB0A9DCBD41FBD4);
  106|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x76F988DA831153B5);
  107|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0x983E5152EE66DFAB);
  108|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0xA831C66D2DB43210);
  109|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0xB00327C898FB213F);
  110|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0xBF597FC7BEEF0EE4);
  111|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0xC6E00BF33DA88FC2);
  112|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0xD5A79147930AA725);
  113|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0x06CA6351E003826F);
  114|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0x142929670A0E6E70);
  115|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0x27B70A8546D22FFC);
  116|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0x2E1B21385C26C926);
  117|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0x4D2C6DFC5AC42AED);
  118|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0x53380D139D95B3DF);
  119|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x650A73548BAF63DE);
  120|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x766A0ABB3C77B2A8);
  121|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x81C2C92E47EDAEE6);
  122|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x92722C851482353B);
  123|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0xA2BFE8A14CF10364);
  124|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0xA81A664BBC423001);
  125|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0xC24B8B70D0F89791);
  126|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0xC76C51A30654BE30);
  127|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0xD192E819D6EF5218);
  128|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0xD69906245565A910);
  129|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0xF40E35855771202A);
  130|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0x106AA07032BBD1B8);
  131|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0x19A4C116B8D2D0C8);
  132|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0x1E376C085141AB53);
  133|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0x2748774CDF8EEB99);
  134|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0x34B0BCB5E19B48A8);
  135|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x391C0CB3C5C95A63);
  136|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x4ED8AA4AE3418ACB);
  137|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x5B9CCA4F7763E373);
  138|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x682E6FF3D6B2B8A3);
  139|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0x748F82EE5DEFB2FC);
  140|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0x78A5636F43172F60);
  141|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0x84C87814A1F0AB72);
  142|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0x8CC702081A6439EC);
  143|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0x90BEFFFA23631E28);
  144|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0xA4506CEBDE82BDE9);
  145|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0xBEF9A3F7B2C67915);
  146|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0xC67178F2E372532B);
  147|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 0], W[14], W[ 9], W[ 1], 0xCA273ECEEA26619C);
  148|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 1], W[15], W[10], W[ 2], 0xD186B8C721C0C207);
  149|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[ 2], W[ 0], W[11], W[ 3], 0xEADA7DD6CDE0EB1E);
  150|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[ 3], W[ 1], W[12], W[ 4], 0xF57D4F7FEE6ED178);
  151|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[ 4], W[ 2], W[13], W[ 5], 0x06F067AA72176FBA);
  152|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[ 5], W[ 3], W[14], W[ 6], 0x0A637DC5A2C898A6);
  153|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[ 6], W[ 4], W[15], W[ 7], 0x113F9804BEF90DAE);
  154|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[ 7], W[ 5], W[ 0], W[ 8], 0x1B710B35131C471B);
  155|      0|      SHA2_64_F(A, B, C, D, E, F, G, H, W[ 8], W[ 6], W[ 1], W[ 9], 0x28DB77F523047D84);
  156|      0|      SHA2_64_F(H, A, B, C, D, E, F, G, W[ 9], W[ 7], W[ 2], W[10], 0x32CAAB7B40C72493);
  157|      0|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10], W[ 8], W[ 3], W[11], 0x3C9EBE0A15C9BEBC);
  158|      0|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11], W[ 9], W[ 4], W[12], 0x431D67C49C100D4C);
  159|      0|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12], W[10], W[ 5], W[13], 0x4CC5D4BECB3E42B6);
  160|      0|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13], W[11], W[ 6], W[14], 0x597F299CFC657E2A);
  161|      0|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14], W[12], W[ 7], W[15], 0x5FCB6FAB3AD6FAEC);
  162|      0|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15], W[13], W[ 8], W[ 0], 0x6C44198C4A475817);
  163|       |
  164|       |      // clang-format on
  165|       |
  166|      0|      A = (digest[0] += A);
  167|      0|      B = (digest[1] += B);
  168|      0|      C = (digest[2] += C);
  169|      0|      D = (digest[3] += D);
  170|      0|      E = (digest[4] += E);
  171|      0|      F = (digest[5] += F);
  172|      0|      G = (digest[6] += G);
  173|      0|      H = (digest[7] += H);
  174|      0|   }
  175|      0|}
_ZN5Botan7SHA_51210compress_nERNSt3__16vectorImNS_16secure_allocatorImEEEENS1_4spanIKhLm18446744073709551615EEEm:
  197|  1.62M|void SHA_512::compress_n(digest_type& digest, std::span<const uint8_t> input, size_t blocks) {
  198|  1.62M|   SHA_512::compress_digest(digest, input, blocks);
  199|  1.62M|}
_ZN5Botan7SHA_5124initERNSt3__16vectorImNS_16secure_allocatorImEEEE:
  223|   984k|void SHA_512::init(digest_type& digest) {
  224|   984k|   digest.assign({0x6A09E667F3BCC908,
  225|   984k|                  0xBB67AE8584CAA73B,
  226|   984k|                  0x3C6EF372FE94F82B,
  227|   984k|                  0xA54FF53A5F1D36F1,
  228|   984k|                  0x510E527FADE682D1,
  229|   984k|                  0x9B05688C2B3E6C1F,
  230|   984k|                  0x1F83D9ABFB41BD6B,
  231|   984k|                  0x5BE0CD19137E2179});
  232|   984k|}
_ZN5Botan7SHA_5128add_dataENSt3__14spanIKhLm18446744073709551615EEE:
  262|  1.94M|void SHA_512::add_data(std::span<const uint8_t> input) {
  263|  1.94M|   m_md.update(input);
  264|  1.94M|}
_ZN5Botan7SHA_51212final_resultENSt3__14spanIhLm18446744073709551615EEE:
  274|   748k|void SHA_512::final_result(std::span<uint8_t> output) {
  275|   748k|   m_md.final(output);
  276|   748k|}

_ZN5Botan7SHA_51224compress_digest_x86_avx2ERNSt3__16vectorImNS_16secure_allocatorImEEEENS1_4spanIKhLm18446744073709551615EEEm:
   46|  1.62M|                                                              size_t blocks) {
   47|       |   // clang-format off
   48|  1.62M|   alignas(64) const uint64_t K[80] = {
   49|  1.62M|      0x428A2F98D728AE22, 0x7137449123EF65CD, 0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC,
   50|  1.62M|      0x3956C25BF348B538, 0x59F111F1B605D019, 0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118,
   51|  1.62M|      0xD807AA98A3030242, 0x12835B0145706FBE, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
   52|  1.62M|      0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x9BDC06A725C71235, 0xC19BF174CF692694,
   53|  1.62M|      0xE49B69C19EF14AD2, 0xEFBE4786384F25E3, 0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65,
   54|  1.62M|      0x2DE92C6F592B0275, 0x4A7484AA6EA6E483, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
   55|  1.62M|      0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0xB00327C898FB213F, 0xBF597FC7BEEF0EE4,
   56|  1.62M|      0xC6E00BF33DA88FC2, 0xD5A79147930AA725, 0x06CA6351E003826F, 0x142929670A0E6E70,
   57|  1.62M|      0x27B70A8546D22FFC, 0x2E1B21385C26C926, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
   58|  1.62M|      0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x81C2C92E47EDAEE6, 0x92722C851482353B,
   59|  1.62M|      0xA2BFE8A14CF10364, 0xA81A664BBC423001, 0xC24B8B70D0F89791, 0xC76C51A30654BE30,
   60|  1.62M|      0xD192E819D6EF5218, 0xD69906245565A910, 0xF40E35855771202A, 0x106AA07032BBD1B8,
   61|  1.62M|      0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8,
   62|  1.62M|      0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB, 0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3,
   63|  1.62M|      0x748F82EE5DEFB2FC, 0x78A5636F43172F60, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
   64|  1.62M|      0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0xBEF9A3F7B2C67915, 0xC67178F2E372532B,
   65|  1.62M|      0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178,
   66|  1.62M|      0x06F067AA72176FBA, 0x0A637DC5A2C898A6, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
   67|  1.62M|      0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C,
   68|  1.62M|      0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A, 0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817,
   69|  1.62M|   };
   70|       |
   71|       |   // K2 is each pair of elements in K repeated since we are performing 2 parallel
   72|       |   // message expansions
   73|  1.62M|   alignas(64) const uint64_t K2[2 * 80] = {
   74|  1.62M|      0x428A2F98D728AE22, 0x7137449123EF65CD, 0x428A2F98D728AE22, 0x7137449123EF65CD,
   75|  1.62M|      0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC, 0xB5C0FBCFEC4D3B2F, 0xE9B5DBA58189DBBC,
   76|  1.62M|      0x3956C25BF348B538, 0x59F111F1B605D019, 0x3956C25BF348B538, 0x59F111F1B605D019,
   77|  1.62M|      0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118, 0x923F82A4AF194F9B, 0xAB1C5ED5DA6D8118,
   78|  1.62M|      0xD807AA98A3030242, 0x12835B0145706FBE, 0xD807AA98A3030242, 0x12835B0145706FBE,
   79|  1.62M|      0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2, 0x243185BE4EE4B28C, 0x550C7DC3D5FFB4E2,
   80|  1.62M|      0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1, 0x72BE5D74F27B896F, 0x80DEB1FE3B1696B1,
   81|  1.62M|      0x9BDC06A725C71235, 0xC19BF174CF692694, 0x9BDC06A725C71235, 0xC19BF174CF692694,
   82|  1.62M|      0xE49B69C19EF14AD2, 0xEFBE4786384F25E3, 0xE49B69C19EF14AD2, 0xEFBE4786384F25E3,
   83|  1.62M|      0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65, 0x0FC19DC68B8CD5B5, 0x240CA1CC77AC9C65,
   84|  1.62M|      0x2DE92C6F592B0275, 0x4A7484AA6EA6E483, 0x2DE92C6F592B0275, 0x4A7484AA6EA6E483,
   85|  1.62M|      0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5, 0x5CB0A9DCBD41FBD4, 0x76F988DA831153B5,
   86|  1.62M|      0x983E5152EE66DFAB, 0xA831C66D2DB43210, 0x983E5152EE66DFAB, 0xA831C66D2DB43210,
   87|  1.62M|      0xB00327C898FB213F, 0xBF597FC7BEEF0EE4, 0xB00327C898FB213F, 0xBF597FC7BEEF0EE4,
   88|  1.62M|      0xC6E00BF33DA88FC2, 0xD5A79147930AA725, 0xC6E00BF33DA88FC2, 0xD5A79147930AA725,
   89|  1.62M|      0x06CA6351E003826F, 0x142929670A0E6E70, 0x06CA6351E003826F, 0x142929670A0E6E70,
   90|  1.62M|      0x27B70A8546D22FFC, 0x2E1B21385C26C926, 0x27B70A8546D22FFC, 0x2E1B21385C26C926,
   91|  1.62M|      0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF, 0x4D2C6DFC5AC42AED, 0x53380D139D95B3DF,
   92|  1.62M|      0x650A73548BAF63DE, 0x766A0ABB3C77B2A8, 0x650A73548BAF63DE, 0x766A0ABB3C77B2A8,
   93|  1.62M|      0x81C2C92E47EDAEE6, 0x92722C851482353B, 0x81C2C92E47EDAEE6, 0x92722C851482353B,
   94|  1.62M|      0xA2BFE8A14CF10364, 0xA81A664BBC423001, 0xA2BFE8A14CF10364, 0xA81A664BBC423001,
   95|  1.62M|      0xC24B8B70D0F89791, 0xC76C51A30654BE30, 0xC24B8B70D0F89791, 0xC76C51A30654BE30,
   96|  1.62M|      0xD192E819D6EF5218, 0xD69906245565A910, 0xD192E819D6EF5218, 0xD69906245565A910,
   97|  1.62M|      0xF40E35855771202A, 0x106AA07032BBD1B8, 0xF40E35855771202A, 0x106AA07032BBD1B8,
   98|  1.62M|      0x19A4C116B8D2D0C8, 0x1E376C085141AB53, 0x19A4C116B8D2D0C8, 0x1E376C085141AB53,
   99|  1.62M|      0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8, 0x2748774CDF8EEB99, 0x34B0BCB5E19B48A8,
  100|  1.62M|      0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB, 0x391C0CB3C5C95A63, 0x4ED8AA4AE3418ACB,
  101|  1.62M|      0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3, 0x5B9CCA4F7763E373, 0x682E6FF3D6B2B8A3,
  102|  1.62M|      0x748F82EE5DEFB2FC, 0x78A5636F43172F60, 0x748F82EE5DEFB2FC, 0x78A5636F43172F60,
  103|  1.62M|      0x84C87814A1F0AB72, 0x8CC702081A6439EC, 0x84C87814A1F0AB72, 0x8CC702081A6439EC,
  104|  1.62M|      0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9, 0x90BEFFFA23631E28, 0xA4506CEBDE82BDE9,
  105|  1.62M|      0xBEF9A3F7B2C67915, 0xC67178F2E372532B, 0xBEF9A3F7B2C67915, 0xC67178F2E372532B,
  106|  1.62M|      0xCA273ECEEA26619C, 0xD186B8C721C0C207, 0xCA273ECEEA26619C, 0xD186B8C721C0C207,
  107|  1.62M|      0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178, 0xEADA7DD6CDE0EB1E, 0xF57D4F7FEE6ED178,
  108|  1.62M|      0x06F067AA72176FBA, 0x0A637DC5A2C898A6, 0x06F067AA72176FBA, 0x0A637DC5A2C898A6,
  109|  1.62M|      0x113F9804BEF90DAE, 0x1B710B35131C471B, 0x113F9804BEF90DAE, 0x1B710B35131C471B,
  110|  1.62M|      0x28DB77F523047D84, 0x32CAAB7B40C72493, 0x28DB77F523047D84, 0x32CAAB7B40C72493,
  111|  1.62M|      0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C, 0x3C9EBE0A15C9BEBC, 0x431D67C49C100D4C,
  112|  1.62M|      0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A, 0x4CC5D4BECB3E42B6, 0x597F299CFC657E2A,
  113|  1.62M|      0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817, 0x5FCB6FAB3AD6FAEC, 0x6C44198C4A475817,
  114|  1.62M|   };
  115|       |   // clang-format on
  116|       |
  117|  1.62M|   alignas(64) uint64_t W[16] = {0};
  118|  1.62M|   alignas(64) uint64_t W2[80];
  119|       |
  120|  1.62M|   uint64_t A = digest[0];
  121|  1.62M|   uint64_t B = digest[1];
  122|  1.62M|   uint64_t C = digest[2];
  123|  1.62M|   uint64_t D = digest[3];
  124|  1.62M|   uint64_t E = digest[4];
  125|  1.62M|   uint64_t F = digest[5];
  126|  1.62M|   uint64_t G = digest[6];
  127|  1.62M|   uint64_t H = digest[7];
  128|       |
  129|  1.62M|   const uint8_t* data = input.data();
  130|       |
  131|  1.81M|   while(blocks >= 2) {
  ------------------
  |  Branch (131:10): [True: 190k, False: 1.62M]
  ------------------
  132|   190k|      SIMD_4x64 WS[8];
  133|       |
  134|  1.71M|      for(size_t i = 0; i < 8; i++) {
  ------------------
  |  Branch (134:25): [True: 1.52M, False: 190k]
  ------------------
  135|  1.52M|         WS[i] = SIMD_4x64::load_be2(&data[16 * i], &data[128 + 16 * i]);
  136|  1.52M|         auto WK = WS[i] + SIMD_4x64::load_le(&K2[4 * i]);
  137|  1.52M|         WK.store_le2(&W[2 * i], &W2[2 * i]);
  138|  1.52M|      }
  139|       |
  140|   190k|      data += 2 * 128;
  141|   190k|      blocks -= 2;
  142|       |
  143|       |      // First 64 rounds of SHA-512
  144|   952k|      for(size_t r = 0; r != 64; r += 16) {
  ------------------
  |  Branch (144:25): [True: 761k, False: 190k]
  ------------------
  145|   761k|         auto w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 16)]);
  146|   761k|         SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  147|   761k|         SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  148|   761k|         w.store_le2(&W[0], &W2[r + 16]);
  149|       |
  150|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 18)]);
  151|   761k|         SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  152|   761k|         SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  153|   761k|         w.store_le2(&W[2], &W2[r + 18]);
  154|       |
  155|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 20)]);
  156|   761k|         SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  157|   761k|         SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  158|   761k|         w.store_le2(&W[4], &W2[r + 20]);
  159|       |
  160|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 22)]);
  161|   761k|         SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  162|   761k|         SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  163|   761k|         w.store_le2(&W[6], &W2[r + 22]);
  164|       |
  165|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 24)]);
  166|   761k|         SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  167|   761k|         SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  168|   761k|         w.store_le2(&W[8], &W2[r + 24]);
  169|       |
  170|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 26)]);
  171|   761k|         SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  172|   761k|         SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  173|   761k|         w.store_le2(&W[10], &W2[r + 26]);
  174|       |
  175|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 28)]);
  176|   761k|         SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  177|   761k|         SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  178|   761k|         w.store_le2(&W[12], &W2[r + 28]);
  179|       |
  180|   761k|         w = sha512_next_w(WS) + SIMD_4x64::load_le(&K2[2 * (r + 30)]);
  181|   761k|         SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  182|   761k|         SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  183|   761k|         w.store_le2(&W[14], &W2[r + 30]);
  184|   761k|      }
  185|       |
  186|       |      // Final 16 rounds of SHA-512
  187|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  188|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  189|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  190|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  191|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  192|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  193|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  194|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  195|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  196|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  197|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  198|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  199|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  200|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  201|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  202|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  203|       |
  204|   190k|      A = (digest[0] += A);
  205|   190k|      B = (digest[1] += B);
  206|   190k|      C = (digest[2] += C);
  207|   190k|      D = (digest[3] += D);
  208|   190k|      E = (digest[4] += E);
  209|   190k|      F = (digest[5] += F);
  210|   190k|      G = (digest[6] += G);
  211|   190k|      H = (digest[7] += H);
  212|       |
  213|       |      // Second block of SHA-512 compression, with pre-expanded message
  214|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[0]);
  215|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[1]);
  216|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[2]);
  217|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[3]);
  218|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[4]);
  219|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[5]);
  220|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[6]);
  221|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[7]);
  222|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[8]);
  223|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[9]);
  224|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[10]);
  225|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[11]);
  226|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[12]);
  227|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[13]);
  228|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[14]);
  229|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[15]);
  230|       |
  231|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[16]);
  232|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[17]);
  233|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[18]);
  234|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[19]);
  235|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[20]);
  236|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[21]);
  237|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[22]);
  238|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[23]);
  239|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[24]);
  240|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[25]);
  241|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[26]);
  242|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[27]);
  243|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[28]);
  244|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[29]);
  245|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[30]);
  246|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[31]);
  247|       |
  248|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[32]);
  249|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[33]);
  250|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[34]);
  251|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[35]);
  252|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[36]);
  253|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[37]);
  254|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[38]);
  255|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[39]);
  256|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[40]);
  257|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[41]);
  258|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[42]);
  259|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[43]);
  260|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[44]);
  261|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[45]);
  262|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[46]);
  263|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[47]);
  264|       |
  265|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[48]);
  266|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[49]);
  267|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[50]);
  268|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[51]);
  269|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[52]);
  270|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[53]);
  271|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[54]);
  272|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[55]);
  273|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[56]);
  274|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[57]);
  275|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[58]);
  276|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[59]);
  277|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[60]);
  278|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[61]);
  279|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[62]);
  280|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[63]);
  281|       |
  282|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[64]);
  283|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[65]);
  284|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[66]);
  285|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[67]);
  286|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[68]);
  287|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[69]);
  288|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[70]);
  289|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[71]);
  290|   190k|      SHA2_64_F(A, B, C, D, E, F, G, H, W2[72]);
  291|   190k|      SHA2_64_F(H, A, B, C, D, E, F, G, W2[73]);
  292|   190k|      SHA2_64_F(G, H, A, B, C, D, E, F, W2[74]);
  293|   190k|      SHA2_64_F(F, G, H, A, B, C, D, E, W2[75]);
  294|   190k|      SHA2_64_F(E, F, G, H, A, B, C, D, W2[76]);
  295|   190k|      SHA2_64_F(D, E, F, G, H, A, B, C, W2[77]);
  296|   190k|      SHA2_64_F(C, D, E, F, G, H, A, B, W2[78]);
  297|   190k|      SHA2_64_F(B, C, D, E, F, G, H, A, W2[79]);
  298|       |
  299|   190k|      A = (digest[0] += A);
  300|   190k|      B = (digest[1] += B);
  301|   190k|      C = (digest[2] += C);
  302|   190k|      D = (digest[3] += D);
  303|   190k|      E = (digest[4] += E);
  304|   190k|      F = (digest[5] += F);
  305|   190k|      G = (digest[6] += G);
  306|   190k|      H = (digest[7] += H);
  307|   190k|   }
  308|       |
  309|  3.22M|   while(blocks > 0) {
  ------------------
  |  Branch (309:10): [True: 1.60M, False: 1.62M]
  ------------------
  310|  1.60M|      SIMD_2x64 WS[8];
  311|       |
  312|  14.4M|      for(size_t i = 0; i < 8; i++) {
  ------------------
  |  Branch (312:25): [True: 12.8M, False: 1.60M]
  ------------------
  313|  12.8M|         WS[i] = SIMD_2x64::load_be(&data[16 * i]);
  314|  12.8M|         auto WK = WS[i] + SIMD_2x64::load_le(&K[2 * i]);
  315|  12.8M|         WK.store_le(&W[2 * i]);
  316|  12.8M|      }
  317|       |
  318|  1.60M|      data += 128;
  319|  1.60M|      blocks -= 1;
  320|       |
  321|       |      // First 64 rounds of SHA-512
  322|  8.03M|      for(size_t r = 0; r != 64; r += 16) {
  ------------------
  |  Branch (322:25): [True: 6.42M, False: 1.60M]
  ------------------
  323|  6.42M|         auto w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 16]);
  324|  6.42M|         SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  325|  6.42M|         SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  326|  6.42M|         w.store_le(&W[0]);
  327|       |
  328|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 18]);
  329|  6.42M|         SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  330|  6.42M|         SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  331|  6.42M|         w.store_le(&W[2]);
  332|       |
  333|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 20]);
  334|  6.42M|         SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  335|  6.42M|         SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  336|  6.42M|         w.store_le(&W[4]);
  337|       |
  338|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 22]);
  339|  6.42M|         SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  340|  6.42M|         SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  341|  6.42M|         w.store_le(&W[6]);
  342|       |
  343|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 24]);
  344|  6.42M|         SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  345|  6.42M|         SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  346|  6.42M|         w.store_le(&W[8]);
  347|       |
  348|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 26]);
  349|  6.42M|         SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  350|  6.42M|         SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  351|  6.42M|         w.store_le(&W[10]);
  352|       |
  353|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 28]);
  354|  6.42M|         SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  355|  6.42M|         SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  356|  6.42M|         w.store_le(&W[12]);
  357|       |
  358|  6.42M|         w = sha512_next_w(WS) + SIMD_2x64::load_le(&K[r + 30]);
  359|  6.42M|         SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  360|  6.42M|         SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  361|  6.42M|         w.store_le(&W[14]);
  362|  6.42M|      }
  363|       |
  364|       |      // Final 16 rounds of SHA-512
  365|  1.60M|      SHA2_64_F(A, B, C, D, E, F, G, H, W[0]);
  366|  1.60M|      SHA2_64_F(H, A, B, C, D, E, F, G, W[1]);
  367|  1.60M|      SHA2_64_F(G, H, A, B, C, D, E, F, W[2]);
  368|  1.60M|      SHA2_64_F(F, G, H, A, B, C, D, E, W[3]);
  369|  1.60M|      SHA2_64_F(E, F, G, H, A, B, C, D, W[4]);
  370|  1.60M|      SHA2_64_F(D, E, F, G, H, A, B, C, W[5]);
  371|  1.60M|      SHA2_64_F(C, D, E, F, G, H, A, B, W[6]);
  372|  1.60M|      SHA2_64_F(B, C, D, E, F, G, H, A, W[7]);
  373|  1.60M|      SHA2_64_F(A, B, C, D, E, F, G, H, W[8]);
  374|  1.60M|      SHA2_64_F(H, A, B, C, D, E, F, G, W[9]);
  375|  1.60M|      SHA2_64_F(G, H, A, B, C, D, E, F, W[10]);
  376|  1.60M|      SHA2_64_F(F, G, H, A, B, C, D, E, W[11]);
  377|  1.60M|      SHA2_64_F(E, F, G, H, A, B, C, D, W[12]);
  378|  1.60M|      SHA2_64_F(D, E, F, G, H, A, B, C, W[13]);
  379|  1.60M|      SHA2_64_F(C, D, E, F, G, H, A, B, W[14]);
  380|  1.60M|      SHA2_64_F(B, C, D, E, F, G, H, A, W[15]);
  381|       |
  382|  1.60M|      A = (digest[0] += A);
  383|  1.60M|      B = (digest[1] += B);
  384|  1.60M|      C = (digest[2] += C);
  385|  1.60M|      D = (digest[3] += D);
  386|  1.60M|      E = (digest[4] += E);
  387|  1.60M|      F = (digest[5] += F);
  388|  1.60M|      G = (digest[6] += G);
  389|  1.60M|      H = (digest[7] += H);
  390|  1.60M|   }
  391|  1.62M|}
sha2_64_avx2.cpp:_ZN5Botan12_GLOBAL__N_113sha512_next_wINS_9SIMD_4x64EEET_PS3_:
   21|  6.09M|BOTAN_FORCE_INLINE BOTAN_FN_ISA_AVX2_BMI2 SIMD_T sha512_next_w(SIMD_T x[8]) {
   22|  6.09M|   auto t0 = SIMD_T::alignr8(x[1], x[0]);
   23|  6.09M|   auto t1 = SIMD_T::alignr8(x[5], x[4]);
   24|       |
   25|  6.09M|   auto s0 = t0.template rotr<1>() ^ t0.template rotr<8>() ^ t0.template shr<7>();
   26|  6.09M|   auto s1 = x[7].template rotr<19>() ^ x[7].template rotr<61>() ^ x[7].template shr<6>();
   27|       |
   28|  6.09M|   auto nx = x[0] + s0 + s1 + t1;
   29|       |
   30|  6.09M|   x[0] = x[1];
   31|  6.09M|   x[1] = x[2];
   32|  6.09M|   x[2] = x[3];
   33|  6.09M|   x[3] = x[4];
   34|  6.09M|   x[4] = x[5];
   35|  6.09M|   x[5] = x[6];
   36|  6.09M|   x[6] = x[7];
   37|  6.09M|   x[7] = nx;
   38|       |
   39|  6.09M|   return x[7];
   40|  6.09M|}
sha2_64_avx2.cpp:_ZN5Botan12_GLOBAL__N_113sha512_next_wINS_9SIMD_2x64EEET_PS3_:
   21|  51.4M|BOTAN_FORCE_INLINE BOTAN_FN_ISA_AVX2_BMI2 SIMD_T sha512_next_w(SIMD_T x[8]) {
   22|  51.4M|   auto t0 = SIMD_T::alignr8(x[1], x[0]);
   23|  51.4M|   auto t1 = SIMD_T::alignr8(x[5], x[4]);
   24|       |
   25|  51.4M|   auto s0 = t0.template rotr<1>() ^ t0.template rotr<8>() ^ t0.template shr<7>();
   26|  51.4M|   auto s1 = x[7].template rotr<19>() ^ x[7].template rotr<61>() ^ x[7].template shr<6>();
   27|       |
   28|  51.4M|   auto nx = x[0] + s0 + s1 + t1;
   29|       |
   30|  51.4M|   x[0] = x[1];
   31|  51.4M|   x[1] = x[2];
   32|  51.4M|   x[2] = x[3];
   33|  51.4M|   x[3] = x[4];
   34|  51.4M|   x[4] = x[5];
   35|  51.4M|   x[5] = x[6];
   36|  51.4M|   x[6] = x[7];
   37|  51.4M|   x[7] = nx;
   38|       |
   39|  51.4M|   return x[7];
   40|  51.4M|}

_ZN5Botan4HMAC8add_dataENSt3__14spanIKhLm18446744073709551615EEE:
   20|   603k|void HMAC::add_data(std::span<const uint8_t> input) {
   21|   603k|   assert_key_material_set();
   22|   603k|   m_hash->update(input);
   23|   603k|}
_ZN5Botan4HMAC12final_resultENSt3__14spanIhLm18446744073709551615EEE:
   28|   328k|void HMAC::final_result(std::span<uint8_t> mac) {
   29|   328k|   assert_key_material_set();
   30|   328k|   m_hash->final(mac);
   31|   328k|   m_hash->update(m_okey);
   32|   328k|   m_hash->update(mac.first(m_hash_output_length));
   33|   328k|   m_hash->final(mac);
   34|   328k|   m_hash->update(m_ikey);
   35|   328k|}
_ZNK5Botan4HMAC8key_specEv:
   37|   157k|Key_Length_Specification HMAC::key_spec() const {
   38|       |   // Support very long lengths for things like PBKDF2 and the TLS PRF
   39|   157k|   return Key_Length_Specification(0, 4096);
   40|   157k|}
_ZNK5Botan4HMAC13output_lengthEv:
   42|   354k|size_t HMAC::output_length() const {
   43|   354k|   return m_hash_output_length;
   44|   354k|}
_ZNK5Botan4HMAC19has_keying_materialEv:
   46|   931k|bool HMAC::has_keying_material() const {
   47|   931k|   return !m_okey.empty();
   48|   931k|}
_ZN5Botan4HMAC12key_scheduleENSt3__14spanIKhLm18446744073709551615EEE:
   53|   157k|void HMAC::key_schedule(std::span<const uint8_t> key) {
   54|   157k|   const uint8_t ipad = 0x36;
   55|   157k|   const uint8_t opad = 0x5C;
   56|       |
   57|   157k|   m_hash->clear();
   58|       |
   59|   157k|   m_ikey.resize(m_hash_block_size);
   60|   157k|   m_okey.resize(m_hash_block_size);
   61|       |
   62|   157k|   clear_mem(m_ikey.data(), m_ikey.size());
   63|   157k|   clear_mem(m_okey.data(), m_okey.size());
   64|       |
   65|       |   /*
   66|       |   * Sometimes the HMAC key length itself is sensitive, as with PBKDF2 where it
   67|       |   * reveals the length of the passphrase. Make some attempt to hide this to
   68|       |   * side channels. Clearly if the secret is longer than the block size then the
   69|       |   * branch to hash first reveals that. In addition, counting the number of
   70|       |   * compression functions executed reveals the size at the granularity of the
   71|       |   * hash function's block size.
   72|       |   *
   73|       |   * The greater concern is for smaller keys; being able to detect when a
   74|       |   * passphrase is say 4 bytes may assist choosing weaker targets. Even though
   75|       |   * the loop bounds are constant, we can only actually read key[0..length] so
   76|       |   * it doesn't seem possible to make this computation truly constant time.
   77|       |   *
   78|       |   * We don't mind leaking if the length is exactly zero since that's
   79|       |   * trivial to simply check.
   80|       |   */
   81|       |
   82|   157k|   if(key.size() > m_hash_block_size) {
  ------------------
  |  Branch (82:7): [True: 0, False: 157k]
  ------------------
   83|      0|      m_hash->update(key);
   84|      0|      m_hash->final(m_ikey.data());
   85|   157k|   } else if(key.size() >= 20) {
  ------------------
  |  Branch (85:14): [True: 157k, False: 0]
  ------------------
   86|       |      // For long keys we just leak the length either it is a cryptovariable
   87|       |      // or a long enough password that just the length is not a useful signal
   88|   157k|      copy_mem(std::span{m_ikey}.first(key.size()), key);
   89|   157k|   } else if(!key.empty()) {
  ------------------
  |  Branch (89:14): [True: 0, False: 0]
  ------------------
   90|      0|      for(size_t i = 0, i_mod_length = 0; i != m_hash_block_size; ++i) {
  ------------------
  |  Branch (90:43): [True: 0, False: 0]
  ------------------
   91|       |         /*
   92|       |         access key[i % length] but avoiding division due to variable
   93|       |         time computation on some processors.
   94|       |         */
   95|      0|         auto needs_reduction = CT::Mask<size_t>::is_lte(key.size(), i_mod_length);
   96|      0|         i_mod_length = needs_reduction.select(0, i_mod_length);
   97|      0|         const uint8_t kb = key[i_mod_length];
   98|       |
   99|      0|         auto in_range = CT::Mask<size_t>::is_lt(i, key.size());
  100|      0|         m_ikey[i] = static_cast<uint8_t>(in_range.if_set_return(kb));
  101|      0|         i_mod_length += 1;
  102|      0|      }
  103|      0|   }
  104|       |
  105|  20.3M|   for(size_t i = 0; i != m_hash_block_size; ++i) {
  ------------------
  |  Branch (105:22): [True: 20.1M, False: 157k]
  ------------------
  106|  20.1M|      m_ikey[i] ^= ipad;
  107|  20.1M|      m_okey[i] = m_ikey[i] ^ ipad ^ opad;
  108|  20.1M|   }
  109|       |
  110|   157k|   m_hash->update(m_ikey);
  111|   157k|}
_ZN5Botan4HMACC2ENSt3__110unique_ptrINS_12HashFunctionENS1_14default_deleteIS3_EEEE:
  140|  13.1k|      m_hash(std::move(hash)),
  141|  13.1k|      m_hash_output_length(m_hash->output_length()),
  142|  13.1k|      m_hash_block_size(m_hash->hash_block_size()) {
  143|  13.1k|   BOTAN_ARG_CHECK(m_hash_block_size >= m_hash_output_length, "HMAC is not compatible with this hash function");
  ------------------
  |  |   32|  13.1k|   do {                                                          \
  |  |   33|  13.1k|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (33:10): [True: 0, False: 13.1k]
  |  |  ------------------
  |  |   34|  13.1k|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   35|  13.1k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (35:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  144|  13.1k|}

_ZN5Botan25MessageAuthenticationCode6createENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
   52|  13.1k|                                                                             std::string_view provider) {
   53|  13.1k|   const SCAN_Name req(algo_spec);
   54|       |
   55|  13.1k|#if defined(BOTAN_HAS_BLAKE2BMAC)
   56|  13.1k|   if(req.algo_name() == "Blake2b" || req.algo_name() == "BLAKE2b") {
  ------------------
  |  Branch (56:7): [True: 0, False: 13.1k]
  |  Branch (56:39): [True: 0, False: 13.1k]
  ------------------
   57|      0|      return std::make_unique<BLAKE2bMAC>(req.arg_as_integer(0, 512));
   58|      0|   }
   59|  13.1k|#endif
   60|       |
   61|  13.1k|#if defined(BOTAN_HAS_GMAC)
   62|  13.1k|   if(req.algo_name() == "GMAC" && req.arg_count() == 1) {
  ------------------
  |  Branch (62:7): [True: 0, False: 13.1k]
  |  Branch (62:36): [True: 0, False: 0]
  ------------------
   63|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (63:10): [True: 0, False: 0]
  |  Branch (63:30): [True: 0, False: 0]
  ------------------
   64|      0|         if(auto bc = BlockCipher::create(req.arg(0))) {
  ------------------
  |  Branch (64:18): [True: 0, False: 0]
  ------------------
   65|      0|            return std::make_unique<GMAC>(std::move(bc));
   66|      0|         }
   67|      0|      }
   68|      0|   }
   69|  13.1k|#endif
   70|       |
   71|  13.1k|#if defined(BOTAN_HAS_HMAC)
   72|  13.1k|   if(req.algo_name() == "HMAC" && req.arg_count() == 1) {
  ------------------
  |  Branch (72:7): [True: 13.1k, False: 0]
  |  Branch (72:36): [True: 13.1k, False: 0]
  ------------------
   73|  13.1k|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (73:10): [True: 13.1k, False: 0]
  |  Branch (73:30): [True: 0, False: 0]
  ------------------
   74|  13.1k|         if(auto hash = HashFunction::create(req.arg(0))) {
  ------------------
  |  Branch (74:18): [True: 13.1k, False: 0]
  ------------------
   75|  13.1k|            return std::make_unique<HMAC>(std::move(hash));
   76|  13.1k|         }
   77|  13.1k|      }
   78|  13.1k|   }
   79|      0|#endif
   80|       |
   81|      0|#if defined(BOTAN_HAS_POLY1305)
   82|      0|   if(req.algo_name() == "Poly1305" && req.arg_count() == 0) {
  ------------------
  |  Branch (82:7): [True: 0, False: 0]
  |  Branch (82:40): [True: 0, False: 0]
  ------------------
   83|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (83:10): [True: 0, False: 0]
  |  Branch (83:30): [True: 0, False: 0]
  ------------------
   84|      0|         return std::make_unique<Poly1305>();
   85|      0|      }
   86|      0|   }
   87|      0|#endif
   88|       |
   89|      0|#if defined(BOTAN_HAS_SIPHASH)
   90|      0|   if(req.algo_name() == "SipHash") {
  ------------------
  |  Branch (90:7): [True: 0, False: 0]
  ------------------
   91|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (91:10): [True: 0, False: 0]
  |  Branch (91:30): [True: 0, False: 0]
  ------------------
   92|      0|         return std::make_unique<SipHash>(req.arg_as_integer(0, 2), req.arg_as_integer(1, 4));
   93|      0|      }
   94|      0|   }
   95|      0|#endif
   96|       |
   97|      0|#if defined(BOTAN_HAS_CMAC)
   98|      0|   if((req.algo_name() == "CMAC" || req.algo_name() == "OMAC") && req.arg_count() == 1) {
  ------------------
  |  Branch (98:8): [True: 0, False: 0]
  |  Branch (98:37): [True: 0, False: 0]
  |  Branch (98:67): [True: 0, False: 0]
  ------------------
   99|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (99:10): [True: 0, False: 0]
  |  Branch (99:30): [True: 0, False: 0]
  ------------------
  100|      0|         if(auto bc = BlockCipher::create(req.arg(0))) {
  ------------------
  |  Branch (100:18): [True: 0, False: 0]
  ------------------
  101|      0|            return std::make_unique<CMAC>(std::move(bc));
  102|      0|         }
  103|      0|      }
  104|      0|   }
  105|      0|#endif
  106|       |
  107|      0|#if defined(BOTAN_HAS_ANSI_X919_MAC)
  108|      0|   if(req.algo_name() == "X9.19-MAC") {
  ------------------
  |  Branch (108:7): [True: 0, False: 0]
  ------------------
  109|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (109:10): [True: 0, False: 0]
  |  Branch (109:30): [True: 0, False: 0]
  ------------------
  110|      0|         return std::make_unique<ANSI_X919_MAC>();
  111|      0|      }
  112|      0|   }
  113|      0|#endif
  114|       |
  115|      0|#if defined(BOTAN_HAS_KMAC)
  116|      0|   if(req.algo_name() == "KMAC-128") {
  ------------------
  |  Branch (116:7): [True: 0, False: 0]
  ------------------
  117|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (117:10): [True: 0, False: 0]
  |  Branch (117:30): [True: 0, False: 0]
  ------------------
  118|      0|         if(req.arg_count() != 1) {
  ------------------
  |  Branch (118:13): [True: 0, False: 0]
  ------------------
  119|      0|            throw Invalid_Argument(
  120|      0|               "invalid algorithm specification for KMAC-128: need exactly one argument for output bit length");
  121|      0|         }
  122|      0|         return std::make_unique<KMAC128>(req.arg_as_integer(0));
  123|      0|      }
  124|      0|   }
  125|       |
  126|      0|   if(req.algo_name() == "KMAC-256") {
  ------------------
  |  Branch (126:7): [True: 0, False: 0]
  ------------------
  127|      0|      if(provider.empty() || provider == "base") {
  ------------------
  |  Branch (127:10): [True: 0, False: 0]
  |  Branch (127:30): [True: 0, False: 0]
  ------------------
  128|      0|         if(req.arg_count() != 1) {
  ------------------
  |  Branch (128:13): [True: 0, False: 0]
  ------------------
  129|      0|            throw Invalid_Argument(
  130|      0|               "invalid algorithm specification for KMAC-256: need exactly one argument for output bit length");
  131|      0|         }
  132|      0|         return std::make_unique<KMAC256>(req.arg_as_integer(0));
  133|      0|      }
  134|      0|   }
  135|      0|#endif
  136|       |
  137|      0|   BOTAN_UNUSED(req);
  ------------------
  |  |  120|      0|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
  138|      0|   BOTAN_UNUSED(provider);
  ------------------
  |  |  120|      0|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
  139|       |
  140|      0|   return nullptr;
  141|      0|}

_ZN5Botan19ed25519_gen_keypairEPhS0_PKh:
   20|  13.1k|void ed25519_gen_keypair(uint8_t* pk, uint8_t* sk, const uint8_t seed[32]) {
   21|  13.1k|   uint8_t az[64];
   22|       |
   23|  13.1k|   SHA_512 sha;
   24|  13.1k|   sha.update(seed, 32);
   25|  13.1k|   sha.final(az);
   26|  13.1k|   az[0] &= 248;
   27|  13.1k|   az[31] &= 63;
   28|  13.1k|   az[31] |= 64;
   29|       |
   30|  13.1k|   ge_scalarmult_base(pk, az);
   31|       |
   32|       |   // todo copy_mem
   33|  13.1k|   copy_mem(sk, seed, 32);
   34|  13.1k|   copy_mem(sk + 32, pk, 32);
   35|  13.1k|}
_ZN5Botan12ed25519_signEPhPKhmS2_S2_m:
   42|  13.1k|                  size_t domain_sep_len) {
   43|  13.1k|   uint8_t az[64];
   44|  13.1k|   uint8_t nonce[64];
   45|  13.1k|   uint8_t hram[64];
   46|       |
   47|  13.1k|   SHA_512 sha;
   48|       |
   49|  13.1k|   sha.update(sk, 32);
   50|  13.1k|   sha.final(az);
   51|  13.1k|   az[0] &= 248;
   52|  13.1k|   az[31] &= 63;
   53|  13.1k|   az[31] |= 64;
   54|       |
   55|  13.1k|   sha.update(domain_sep, domain_sep_len);
   56|  13.1k|   sha.update(az + 32, 32);
   57|  13.1k|   sha.update(m, mlen);
   58|  13.1k|   sha.final(nonce);
   59|       |
   60|  13.1k|   sc_reduce(nonce);
   61|  13.1k|   ge_scalarmult_base(sig, nonce);
   62|       |
   63|  13.1k|   sha.update(domain_sep, domain_sep_len);
   64|  13.1k|   sha.update(sig, 32);
   65|  13.1k|   sha.update(sk + 32, 32);
   66|  13.1k|   sha.update(m, mlen);
   67|  13.1k|   sha.final(hram);
   68|       |
   69|  13.1k|   sc_reduce(hram);
   70|  13.1k|   sc_muladd(sig + 32, hram, az, nonce);
   71|  13.1k|}
_ZN5Botan14ed25519_verifyEPKhmS1_S1_S1_m:
   78|  13.1k|                    size_t domain_sep_len) {
   79|  13.1k|   uint8_t h[64];
   80|  13.1k|   uint8_t rcheck[32];
   81|  13.1k|   ge_p3 A;
   82|  13.1k|   SHA_512 sha;
   83|       |
   84|  13.1k|   if(sig[63] & 224) {
  ------------------
  |  Branch (84:7): [True: 0, False: 13.1k]
  ------------------
   85|      0|      return false;
   86|      0|   }
   87|  13.1k|   if(ge_frombytes_negate_vartime(&A, pk) != 0) {
  ------------------
  |  Branch (87:7): [True: 0, False: 13.1k]
  ------------------
   88|      0|      return false;
   89|      0|   }
   90|       |
   91|  13.1k|   const uint64_t CURVE25519_ORDER[4] = {
   92|  13.1k|      0x1000000000000000,
   93|  13.1k|      0x0000000000000000,
   94|  13.1k|      0x14def9dea2f79cd6,
   95|  13.1k|      0x5812631a5cf5d3ed,
   96|  13.1k|   };
   97|       |
   98|  13.1k|   const uint64_t s[4] = {load_le<uint64_t>(sig + 32, 3),
   99|  13.1k|                          load_le<uint64_t>(sig + 32, 2),
  100|  13.1k|                          load_le<uint64_t>(sig + 32, 1),
  101|  13.1k|                          load_le<uint64_t>(sig + 32, 0)};
  102|       |
  103|       |   // RFC 8032 adds the requirement that we verify that s < order in
  104|       |   // the signature; this did not exist in the original Ed25519 spec.
  105|  13.1k|   for(size_t i = 0; i != 4; ++i) {
  ------------------
  |  Branch (105:22): [True: 13.1k, False: 0]
  ------------------
  106|  13.1k|      if(s[i] > CURVE25519_ORDER[i]) {
  ------------------
  |  Branch (106:10): [True: 0, False: 13.1k]
  ------------------
  107|      0|         return false;
  108|      0|      }
  109|  13.1k|      if(s[i] < CURVE25519_ORDER[i]) {
  ------------------
  |  Branch (109:10): [True: 13.1k, False: 0]
  ------------------
  110|  13.1k|         break;
  111|  13.1k|      }
  112|      0|      if(i == 3) {  // here s == order
  ------------------
  |  Branch (112:10): [True: 0, False: 0]
  ------------------
  113|      0|         return false;
  114|      0|      }
  115|      0|   }
  116|       |
  117|  13.1k|   sha.update(domain_sep, domain_sep_len);
  118|  13.1k|   sha.update(sig, 32);
  119|  13.1k|   sha.update(pk, 32);
  120|  13.1k|   sha.update(m, mlen);
  121|  13.1k|   sha.final(h);
  122|  13.1k|   sc_reduce(h);
  123|       |
  124|  13.1k|   ge_double_scalarmult_vartime(rcheck, h, &A, sig + 32);
  125|       |
  126|  13.1k|   return CT::is_equal(rcheck, sig, 32).as_bool();
  127|  13.1k|}

_ZN5Botan8FE_255196invertERKS0_:
   18|  52.4k|FE_25519 FE_25519::invert(const FE_25519& z) {
   19|  52.4k|   FE_25519 t0;
   20|  52.4k|   FE_25519 t1;
   21|  52.4k|   FE_25519 t2;
   22|  52.4k|   FE_25519 t3;
   23|       |
   24|  52.4k|   fe_sq(t0, z);
   25|  52.4k|   fe_sq_iter(t1, t0, 2);
   26|  52.4k|   fe_mul(t1, z, t1);
   27|  52.4k|   fe_mul(t0, t0, t1);
   28|  52.4k|   fe_sq(t2, t0);
   29|  52.4k|   fe_mul(t1, t1, t2);
   30|  52.4k|   fe_sq_iter(t2, t1, 5);
   31|  52.4k|   fe_mul(t1, t2, t1);
   32|  52.4k|   fe_sq_iter(t2, t1, 10);
   33|  52.4k|   fe_mul(t2, t2, t1);
   34|  52.4k|   fe_sq_iter(t3, t2, 20);
   35|  52.4k|   fe_mul(t2, t3, t2);
   36|  52.4k|   fe_sq_iter(t2, t2, 10);
   37|  52.4k|   fe_mul(t1, t2, t1);
   38|  52.4k|   fe_sq_iter(t2, t1, 50);
   39|  52.4k|   fe_mul(t2, t2, t1);
   40|  52.4k|   fe_sq_iter(t3, t2, 100);
   41|  52.4k|   fe_mul(t2, t3, t2);
   42|  52.4k|   fe_sq_iter(t2, t2, 50);
   43|  52.4k|   fe_mul(t1, t2, t1);
   44|  52.4k|   fe_sq_iter(t1, t1, 5);
   45|       |
   46|  52.4k|   fe_mul(t0, t1, t0);
   47|  52.4k|   return t0;
   48|  52.4k|}
_ZN5Botan8FE_255199pow_22523ERKS0_:
   50|  26.2k|FE_25519 FE_25519::pow_22523(const FE_25519& z) {
   51|  26.2k|   FE_25519 t0;
   52|  26.2k|   FE_25519 t1;
   53|  26.2k|   FE_25519 t2;
   54|       |
   55|  26.2k|   fe_sq(t0, z);
   56|  26.2k|   fe_sq_iter(t1, t0, 2);
   57|  26.2k|   fe_mul(t1, z, t1);
   58|  26.2k|   fe_mul(t0, t0, t1);
   59|  26.2k|   fe_sq(t0, t0);
   60|  26.2k|   fe_mul(t0, t1, t0);
   61|  26.2k|   fe_sq_iter(t1, t0, 5);
   62|  26.2k|   fe_mul(t0, t1, t0);
   63|  26.2k|   fe_sq_iter(t1, t0, 10);
   64|  26.2k|   fe_mul(t1, t1, t0);
   65|  26.2k|   fe_sq_iter(t2, t1, 20);
   66|  26.2k|   fe_mul(t1, t2, t1);
   67|  26.2k|   fe_sq_iter(t1, t1, 10);
   68|  26.2k|   fe_mul(t0, t1, t0);
   69|  26.2k|   fe_sq_iter(t1, t0, 50);
   70|  26.2k|   fe_mul(t1, t1, t0);
   71|  26.2k|   fe_sq_iter(t2, t1, 100);
   72|  26.2k|   fe_mul(t1, t2, t1);
   73|  26.2k|   fe_sq_iter(t1, t1, 50);
   74|  26.2k|   fe_mul(t0, t1, t0);
   75|  26.2k|   fe_sq_iter(t0, t0, 2);
   76|       |
   77|  26.2k|   fe_mul(t0, t0, z);
   78|  26.2k|   return t0;
   79|  26.2k|}
_ZN5Botan8FE_255193mulERKS0_S2_:
  114|  45.7M|FE_25519 FE_25519::mul(const FE_25519& f, const FE_25519& g) {
  115|  45.7M|   const int32_t f0 = f[0];
  116|  45.7M|   const int32_t f1 = f[1];
  117|  45.7M|   const int32_t f2 = f[2];
  118|  45.7M|   const int32_t f3 = f[3];
  119|  45.7M|   const int32_t f4 = f[4];
  120|  45.7M|   const int32_t f5 = f[5];
  121|  45.7M|   const int32_t f6 = f[6];
  122|  45.7M|   const int32_t f7 = f[7];
  123|  45.7M|   const int32_t f8 = f[8];
  124|  45.7M|   const int32_t f9 = f[9];
  125|       |
  126|  45.7M|   const int32_t g0 = g[0];
  127|  45.7M|   const int32_t g1 = g[1];
  128|  45.7M|   const int32_t g2 = g[2];
  129|  45.7M|   const int32_t g3 = g[3];
  130|  45.7M|   const int32_t g4 = g[4];
  131|  45.7M|   const int32_t g5 = g[5];
  132|  45.7M|   const int32_t g6 = g[6];
  133|  45.7M|   const int32_t g7 = g[7];
  134|  45.7M|   const int32_t g8 = g[8];
  135|  45.7M|   const int32_t g9 = g[9];
  136|       |
  137|  45.7M|   const int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */
  138|  45.7M|   const int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  139|  45.7M|   const int32_t g3_19 = 19 * g3;
  140|  45.7M|   const int32_t g4_19 = 19 * g4;
  141|  45.7M|   const int32_t g5_19 = 19 * g5;
  142|  45.7M|   const int32_t g6_19 = 19 * g6;
  143|  45.7M|   const int32_t g7_19 = 19 * g7;
  144|  45.7M|   const int32_t g8_19 = 19 * g8;
  145|  45.7M|   const int32_t g9_19 = 19 * g9;
  146|  45.7M|   const int32_t f1_2 = 2 * f1;
  147|  45.7M|   const int32_t f3_2 = 2 * f3;
  148|  45.7M|   const int32_t f5_2 = 2 * f5;
  149|  45.7M|   const int32_t f7_2 = 2 * f7;
  150|  45.7M|   const int32_t f9_2 = 2 * f9;
  151|       |
  152|  45.7M|   const int64_t f0g0 = f0 * static_cast<int64_t>(g0);
  153|  45.7M|   const int64_t f0g1 = f0 * static_cast<int64_t>(g1);
  154|  45.7M|   const int64_t f0g2 = f0 * static_cast<int64_t>(g2);
  155|  45.7M|   const int64_t f0g3 = f0 * static_cast<int64_t>(g3);
  156|  45.7M|   const int64_t f0g4 = f0 * static_cast<int64_t>(g4);
  157|  45.7M|   const int64_t f0g5 = f0 * static_cast<int64_t>(g5);
  158|  45.7M|   const int64_t f0g6 = f0 * static_cast<int64_t>(g6);
  159|  45.7M|   const int64_t f0g7 = f0 * static_cast<int64_t>(g7);
  160|  45.7M|   const int64_t f0g8 = f0 * static_cast<int64_t>(g8);
  161|  45.7M|   const int64_t f0g9 = f0 * static_cast<int64_t>(g9);
  162|  45.7M|   const int64_t f1g0 = f1 * static_cast<int64_t>(g0);
  163|  45.7M|   const int64_t f1g1_2 = f1_2 * static_cast<int64_t>(g1);
  164|  45.7M|   const int64_t f1g2 = f1 * static_cast<int64_t>(g2);
  165|  45.7M|   const int64_t f1g3_2 = f1_2 * static_cast<int64_t>(g3);
  166|  45.7M|   const int64_t f1g4 = f1 * static_cast<int64_t>(g4);
  167|  45.7M|   const int64_t f1g5_2 = f1_2 * static_cast<int64_t>(g5);
  168|  45.7M|   const int64_t f1g6 = f1 * static_cast<int64_t>(g6);
  169|  45.7M|   const int64_t f1g7_2 = f1_2 * static_cast<int64_t>(g7);
  170|  45.7M|   const int64_t f1g8 = f1 * static_cast<int64_t>(g8);
  171|  45.7M|   const int64_t f1g9_38 = f1_2 * static_cast<int64_t>(g9_19);
  172|  45.7M|   const int64_t f2g0 = f2 * static_cast<int64_t>(g0);
  173|  45.7M|   const int64_t f2g1 = f2 * static_cast<int64_t>(g1);
  174|  45.7M|   const int64_t f2g2 = f2 * static_cast<int64_t>(g2);
  175|  45.7M|   const int64_t f2g3 = f2 * static_cast<int64_t>(g3);
  176|  45.7M|   const int64_t f2g4 = f2 * static_cast<int64_t>(g4);
  177|  45.7M|   const int64_t f2g5 = f2 * static_cast<int64_t>(g5);
  178|  45.7M|   const int64_t f2g6 = f2 * static_cast<int64_t>(g6);
  179|  45.7M|   const int64_t f2g7 = f2 * static_cast<int64_t>(g7);
  180|  45.7M|   const int64_t f2g8_19 = f2 * static_cast<int64_t>(g8_19);
  181|  45.7M|   const int64_t f2g9_19 = f2 * static_cast<int64_t>(g9_19);
  182|  45.7M|   const int64_t f3g0 = f3 * static_cast<int64_t>(g0);
  183|  45.7M|   const int64_t f3g1_2 = f3_2 * static_cast<int64_t>(g1);
  184|  45.7M|   const int64_t f3g2 = f3 * static_cast<int64_t>(g2);
  185|  45.7M|   const int64_t f3g3_2 = f3_2 * static_cast<int64_t>(g3);
  186|  45.7M|   const int64_t f3g4 = f3 * static_cast<int64_t>(g4);
  187|  45.7M|   const int64_t f3g5_2 = f3_2 * static_cast<int64_t>(g5);
  188|  45.7M|   const int64_t f3g6 = f3 * static_cast<int64_t>(g6);
  189|  45.7M|   const int64_t f3g7_38 = f3_2 * static_cast<int64_t>(g7_19);
  190|  45.7M|   const int64_t f3g8_19 = f3 * static_cast<int64_t>(g8_19);
  191|  45.7M|   const int64_t f3g9_38 = f3_2 * static_cast<int64_t>(g9_19);
  192|  45.7M|   const int64_t f4g0 = f4 * static_cast<int64_t>(g0);
  193|  45.7M|   const int64_t f4g1 = f4 * static_cast<int64_t>(g1);
  194|  45.7M|   const int64_t f4g2 = f4 * static_cast<int64_t>(g2);
  195|  45.7M|   const int64_t f4g3 = f4 * static_cast<int64_t>(g3);
  196|  45.7M|   const int64_t f4g4 = f4 * static_cast<int64_t>(g4);
  197|  45.7M|   const int64_t f4g5 = f4 * static_cast<int64_t>(g5);
  198|  45.7M|   const int64_t f4g6_19 = f4 * static_cast<int64_t>(g6_19);
  199|  45.7M|   const int64_t f4g7_19 = f4 * static_cast<int64_t>(g7_19);
  200|  45.7M|   const int64_t f4g8_19 = f4 * static_cast<int64_t>(g8_19);
  201|  45.7M|   const int64_t f4g9_19 = f4 * static_cast<int64_t>(g9_19);
  202|  45.7M|   const int64_t f5g0 = f5 * static_cast<int64_t>(g0);
  203|  45.7M|   const int64_t f5g1_2 = f5_2 * static_cast<int64_t>(g1);
  204|  45.7M|   const int64_t f5g2 = f5 * static_cast<int64_t>(g2);
  205|  45.7M|   const int64_t f5g3_2 = f5_2 * static_cast<int64_t>(g3);
  206|  45.7M|   const int64_t f5g4 = f5 * static_cast<int64_t>(g4);
  207|  45.7M|   const int64_t f5g5_38 = f5_2 * static_cast<int64_t>(g5_19);
  208|  45.7M|   const int64_t f5g6_19 = f5 * static_cast<int64_t>(g6_19);
  209|  45.7M|   const int64_t f5g7_38 = f5_2 * static_cast<int64_t>(g7_19);
  210|  45.7M|   const int64_t f5g8_19 = f5 * static_cast<int64_t>(g8_19);
  211|  45.7M|   const int64_t f5g9_38 = f5_2 * static_cast<int64_t>(g9_19);
  212|  45.7M|   const int64_t f6g0 = f6 * static_cast<int64_t>(g0);
  213|  45.7M|   const int64_t f6g1 = f6 * static_cast<int64_t>(g1);
  214|  45.7M|   const int64_t f6g2 = f6 * static_cast<int64_t>(g2);
  215|  45.7M|   const int64_t f6g3 = f6 * static_cast<int64_t>(g3);
  216|  45.7M|   const int64_t f6g4_19 = f6 * static_cast<int64_t>(g4_19);
  217|  45.7M|   const int64_t f6g5_19 = f6 * static_cast<int64_t>(g5_19);
  218|  45.7M|   const int64_t f6g6_19 = f6 * static_cast<int64_t>(g6_19);
  219|  45.7M|   const int64_t f6g7_19 = f6 * static_cast<int64_t>(g7_19);
  220|  45.7M|   const int64_t f6g8_19 = f6 * static_cast<int64_t>(g8_19);
  221|  45.7M|   const int64_t f6g9_19 = f6 * static_cast<int64_t>(g9_19);
  222|  45.7M|   const int64_t f7g0 = f7 * static_cast<int64_t>(g0);
  223|  45.7M|   const int64_t f7g1_2 = f7_2 * static_cast<int64_t>(g1);
  224|  45.7M|   const int64_t f7g2 = f7 * static_cast<int64_t>(g2);
  225|  45.7M|   const int64_t f7g3_38 = f7_2 * static_cast<int64_t>(g3_19);
  226|  45.7M|   const int64_t f7g4_19 = f7 * static_cast<int64_t>(g4_19);
  227|  45.7M|   const int64_t f7g5_38 = f7_2 * static_cast<int64_t>(g5_19);
  228|  45.7M|   const int64_t f7g6_19 = f7 * static_cast<int64_t>(g6_19);
  229|  45.7M|   const int64_t f7g7_38 = f7_2 * static_cast<int64_t>(g7_19);
  230|  45.7M|   const int64_t f7g8_19 = f7 * static_cast<int64_t>(g8_19);
  231|  45.7M|   const int64_t f7g9_38 = f7_2 * static_cast<int64_t>(g9_19);
  232|  45.7M|   const int64_t f8g0 = f8 * static_cast<int64_t>(g0);
  233|  45.7M|   const int64_t f8g1 = f8 * static_cast<int64_t>(g1);
  234|  45.7M|   const int64_t f8g2_19 = f8 * static_cast<int64_t>(g2_19);
  235|  45.7M|   const int64_t f8g3_19 = f8 * static_cast<int64_t>(g3_19);
  236|  45.7M|   const int64_t f8g4_19 = f8 * static_cast<int64_t>(g4_19);
  237|  45.7M|   const int64_t f8g5_19 = f8 * static_cast<int64_t>(g5_19);
  238|  45.7M|   const int64_t f8g6_19 = f8 * static_cast<int64_t>(g6_19);
  239|  45.7M|   const int64_t f8g7_19 = f8 * static_cast<int64_t>(g7_19);
  240|  45.7M|   const int64_t f8g8_19 = f8 * static_cast<int64_t>(g8_19);
  241|  45.7M|   const int64_t f8g9_19 = f8 * static_cast<int64_t>(g9_19);
  242|  45.7M|   const int64_t f9g0 = f9 * static_cast<int64_t>(g0);
  243|  45.7M|   const int64_t f9g1_38 = f9_2 * static_cast<int64_t>(g1_19);
  244|  45.7M|   const int64_t f9g2_19 = f9 * static_cast<int64_t>(g2_19);
  245|  45.7M|   const int64_t f9g3_38 = f9_2 * static_cast<int64_t>(g3_19);
  246|  45.7M|   const int64_t f9g4_19 = f9 * static_cast<int64_t>(g4_19);
  247|  45.7M|   const int64_t f9g5_38 = f9_2 * static_cast<int64_t>(g5_19);
  248|  45.7M|   const int64_t f9g6_19 = f9 * static_cast<int64_t>(g6_19);
  249|  45.7M|   const int64_t f9g7_38 = f9_2 * static_cast<int64_t>(g7_19);
  250|  45.7M|   const int64_t f9g8_19 = f9 * static_cast<int64_t>(g8_19);
  251|  45.7M|   const int64_t f9g9_38 = f9_2 * static_cast<int64_t>(g9_19);
  252|       |
  253|  45.7M|   int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 + f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;
  254|  45.7M|   int64_t h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 + f7g4_19 + f8g3_19 + f9g2_19;
  255|  45.7M|   int64_t h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 + f7g5_38 + f8g4_19 + f9g3_38;
  256|  45.7M|   int64_t h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 + f7g6_19 + f8g5_19 + f9g4_19;
  257|  45.7M|   int64_t h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 + f7g7_38 + f8g6_19 + f9g5_38;
  258|  45.7M|   int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 + f8g7_19 + f9g6_19;
  259|  45.7M|   int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 + f7g9_38 + f8g8_19 + f9g7_38;
  260|  45.7M|   int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 + f8g9_19 + f9g8_19;
  261|  45.7M|   int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 + f8g0 + f9g9_38;
  262|  45.7M|   int64_t h9 = f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;
  263|       |
  264|       |   /*
  265|       |   |h0| <= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))
  266|       |   i.e. |h0| <= 1.4*2^60; narrower ranges for h2, h4, h6, h8
  267|       |   |h1| <= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))
  268|       |   i.e. |h1| <= 1.7*2^59; narrower ranges for h3, h5, h7, h9
  269|       |   */
  270|  45.7M|   carry<26>(h0, h1);
  271|  45.7M|   carry<26>(h4, h5);
  272|       |
  273|       |   /* |h0| <= 2^25 */
  274|       |   /* |h4| <= 2^25 */
  275|       |   /* |h1| <= 1.71*2^59 */
  276|       |   /* |h5| <= 1.71*2^59 */
  277|       |
  278|  45.7M|   carry<25>(h1, h2);
  279|  45.7M|   carry<25>(h5, h6);
  280|       |
  281|       |   /* |h1| <= 2^24; from now on fits into int32 */
  282|       |   /* |h5| <= 2^24; from now on fits into int32 */
  283|       |   /* |h2| <= 1.41*2^60 */
  284|       |   /* |h6| <= 1.41*2^60 */
  285|       |
  286|  45.7M|   carry<26>(h2, h3);
  287|  45.7M|   carry<26>(h6, h7);
  288|       |   /* |h2| <= 2^25; from now on fits into int32 unchanged */
  289|       |   /* |h6| <= 2^25; from now on fits into int32 unchanged */
  290|       |   /* |h3| <= 1.71*2^59 */
  291|       |   /* |h7| <= 1.71*2^59 */
  292|       |
  293|  45.7M|   carry<25>(h3, h4);
  294|  45.7M|   carry<25>(h7, h8);
  295|       |   /* |h3| <= 2^24; from now on fits into int32 unchanged */
  296|       |   /* |h7| <= 2^24; from now on fits into int32 unchanged */
  297|       |   /* |h4| <= 1.72*2^34 */
  298|       |   /* |h8| <= 1.41*2^60 */
  299|       |
  300|  45.7M|   carry<26>(h4, h5);
  301|  45.7M|   carry<26>(h8, h9);
  302|       |   /* |h4| <= 2^25; from now on fits into int32 unchanged */
  303|       |   /* |h8| <= 2^25; from now on fits into int32 unchanged */
  304|       |   /* |h5| <= 1.01*2^24 */
  305|       |   /* |h9| <= 1.71*2^59 */
  306|       |
  307|  45.7M|   carry<25, 19>(h9, h0);
  308|       |
  309|       |   /* |h9| <= 2^24; from now on fits into int32 unchanged */
  310|       |   /* |h0| <= 1.1*2^39 */
  311|       |
  312|  45.7M|   carry<26>(h0, h1);
  313|       |   /* |h0| <= 2^25; from now on fits into int32 unchanged */
  314|       |   /* |h1| <= 1.01*2^24 */
  315|       |
  316|  45.7M|   return FE_25519(h0, h1, h2, h3, h4, h5, h6, h7, h8, h9);
  317|  45.7M|}
_ZN5Botan8FE_255198sqr_iterERKS0_m:
  335|  21.2M|FE_25519 FE_25519::sqr_iter(const FE_25519& f, size_t iter) {
  336|  21.2M|   int32_t f0 = f[0];
  337|  21.2M|   int32_t f1 = f[1];
  338|  21.2M|   int32_t f2 = f[2];
  339|  21.2M|   int32_t f3 = f[3];
  340|  21.2M|   int32_t f4 = f[4];
  341|  21.2M|   int32_t f5 = f[5];
  342|  21.2M|   int32_t f6 = f[6];
  343|  21.2M|   int32_t f7 = f[7];
  344|  21.2M|   int32_t f8 = f[8];
  345|  21.2M|   int32_t f9 = f[9];
  346|       |
  347|  61.5M|   for(size_t i = 0; i != iter; ++i) {
  ------------------
  |  Branch (347:22): [True: 40.2M, False: 21.2M]
  ------------------
  348|  40.2M|      const int32_t f0_2 = 2 * f0;
  349|  40.2M|      const int32_t f1_2 = 2 * f1;
  350|  40.2M|      const int32_t f2_2 = 2 * f2;
  351|  40.2M|      const int32_t f3_2 = 2 * f3;
  352|  40.2M|      const int32_t f4_2 = 2 * f4;
  353|  40.2M|      const int32_t f5_2 = 2 * f5;
  354|  40.2M|      const int32_t f6_2 = 2 * f6;
  355|  40.2M|      const int32_t f7_2 = 2 * f7;
  356|  40.2M|      const int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */
  357|  40.2M|      const int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */
  358|  40.2M|      const int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */
  359|  40.2M|      const int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */
  360|  40.2M|      const int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */
  361|       |
  362|  40.2M|      const int64_t f0f0 = f0 * static_cast<int64_t>(f0);
  363|  40.2M|      const int64_t f0f1_2 = f0_2 * static_cast<int64_t>(f1);
  364|  40.2M|      const int64_t f0f2_2 = f0_2 * static_cast<int64_t>(f2);
  365|  40.2M|      const int64_t f0f3_2 = f0_2 * static_cast<int64_t>(f3);
  366|  40.2M|      const int64_t f0f4_2 = f0_2 * static_cast<int64_t>(f4);
  367|  40.2M|      const int64_t f0f5_2 = f0_2 * static_cast<int64_t>(f5);
  368|  40.2M|      const int64_t f0f6_2 = f0_2 * static_cast<int64_t>(f6);
  369|  40.2M|      const int64_t f0f7_2 = f0_2 * static_cast<int64_t>(f7);
  370|  40.2M|      const int64_t f0f8_2 = f0_2 * static_cast<int64_t>(f8);
  371|  40.2M|      const int64_t f0f9_2 = f0_2 * static_cast<int64_t>(f9);
  372|  40.2M|      const int64_t f1f1_2 = f1_2 * static_cast<int64_t>(f1);
  373|  40.2M|      const int64_t f1f2_2 = f1_2 * static_cast<int64_t>(f2);
  374|  40.2M|      const int64_t f1f3_4 = f1_2 * static_cast<int64_t>(f3_2);
  375|  40.2M|      const int64_t f1f4_2 = f1_2 * static_cast<int64_t>(f4);
  376|  40.2M|      const int64_t f1f5_4 = f1_2 * static_cast<int64_t>(f5_2);
  377|  40.2M|      const int64_t f1f6_2 = f1_2 * static_cast<int64_t>(f6);
  378|  40.2M|      const int64_t f1f7_4 = f1_2 * static_cast<int64_t>(f7_2);
  379|  40.2M|      const int64_t f1f8_2 = f1_2 * static_cast<int64_t>(f8);
  380|  40.2M|      const int64_t f1f9_76 = f1_2 * static_cast<int64_t>(f9_38);
  381|  40.2M|      const int64_t f2f2 = f2 * static_cast<int64_t>(f2);
  382|  40.2M|      const int64_t f2f3_2 = f2_2 * static_cast<int64_t>(f3);
  383|  40.2M|      const int64_t f2f4_2 = f2_2 * static_cast<int64_t>(f4);
  384|  40.2M|      const int64_t f2f5_2 = f2_2 * static_cast<int64_t>(f5);
  385|  40.2M|      const int64_t f2f6_2 = f2_2 * static_cast<int64_t>(f6);
  386|  40.2M|      const int64_t f2f7_2 = f2_2 * static_cast<int64_t>(f7);
  387|  40.2M|      const int64_t f2f8_38 = f2_2 * static_cast<int64_t>(f8_19);
  388|  40.2M|      const int64_t f2f9_38 = f2 * static_cast<int64_t>(f9_38);
  389|  40.2M|      const int64_t f3f3_2 = f3_2 * static_cast<int64_t>(f3);
  390|  40.2M|      const int64_t f3f4_2 = f3_2 * static_cast<int64_t>(f4);
  391|  40.2M|      const int64_t f3f5_4 = f3_2 * static_cast<int64_t>(f5_2);
  392|  40.2M|      const int64_t f3f6_2 = f3_2 * static_cast<int64_t>(f6);
  393|  40.2M|      const int64_t f3f7_76 = f3_2 * static_cast<int64_t>(f7_38);
  394|  40.2M|      const int64_t f3f8_38 = f3_2 * static_cast<int64_t>(f8_19);
  395|  40.2M|      const int64_t f3f9_76 = f3_2 * static_cast<int64_t>(f9_38);
  396|  40.2M|      const int64_t f4f4 = f4 * static_cast<int64_t>(f4);
  397|  40.2M|      const int64_t f4f5_2 = f4_2 * static_cast<int64_t>(f5);
  398|  40.2M|      const int64_t f4f6_38 = f4_2 * static_cast<int64_t>(f6_19);
  399|  40.2M|      const int64_t f4f7_38 = f4 * static_cast<int64_t>(f7_38);
  400|  40.2M|      const int64_t f4f8_38 = f4_2 * static_cast<int64_t>(f8_19);
  401|  40.2M|      const int64_t f4f9_38 = f4 * static_cast<int64_t>(f9_38);
  402|  40.2M|      const int64_t f5f5_38 = f5 * static_cast<int64_t>(f5_38);
  403|  40.2M|      const int64_t f5f6_38 = f5_2 * static_cast<int64_t>(f6_19);
  404|  40.2M|      const int64_t f5f7_76 = f5_2 * static_cast<int64_t>(f7_38);
  405|  40.2M|      const int64_t f5f8_38 = f5_2 * static_cast<int64_t>(f8_19);
  406|  40.2M|      const int64_t f5f9_76 = f5_2 * static_cast<int64_t>(f9_38);
  407|  40.2M|      const int64_t f6f6_19 = f6 * static_cast<int64_t>(f6_19);
  408|  40.2M|      const int64_t f6f7_38 = f6 * static_cast<int64_t>(f7_38);
  409|  40.2M|      const int64_t f6f8_38 = f6_2 * static_cast<int64_t>(f8_19);
  410|  40.2M|      const int64_t f6f9_38 = f6 * static_cast<int64_t>(f9_38);
  411|  40.2M|      const int64_t f7f7_38 = f7 * static_cast<int64_t>(f7_38);
  412|  40.2M|      const int64_t f7f8_38 = f7_2 * static_cast<int64_t>(f8_19);
  413|  40.2M|      const int64_t f7f9_76 = f7_2 * static_cast<int64_t>(f9_38);
  414|  40.2M|      const int64_t f8f8_19 = f8 * static_cast<int64_t>(f8_19);
  415|  40.2M|      const int64_t f8f9_38 = f8 * static_cast<int64_t>(f9_38);
  416|  40.2M|      const int64_t f9f9_38 = f9 * static_cast<int64_t>(f9_38);
  417|       |
  418|  40.2M|      int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
  419|  40.2M|      int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
  420|  40.2M|      int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
  421|  40.2M|      int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
  422|  40.2M|      int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
  423|  40.2M|      int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
  424|  40.2M|      int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
  425|  40.2M|      int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
  426|  40.2M|      int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
  427|  40.2M|      int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;
  428|       |
  429|  40.2M|      carry<26>(h0, h1);
  430|  40.2M|      carry<26>(h4, h5);
  431|  40.2M|      carry<25>(h1, h2);
  432|  40.2M|      carry<25>(h5, h6);
  433|  40.2M|      carry<26>(h2, h3);
  434|  40.2M|      carry<26>(h6, h7);
  435|       |
  436|  40.2M|      carry<25>(h3, h4);
  437|  40.2M|      carry<25>(h7, h8);
  438|       |
  439|  40.2M|      carry<26>(h4, h5);
  440|  40.2M|      carry<26>(h8, h9);
  441|  40.2M|      carry<25, 19>(h9, h0);
  442|  40.2M|      carry<26>(h0, h1);
  443|       |
  444|  40.2M|      f0 = static_cast<int32_t>(h0);
  445|  40.2M|      f1 = static_cast<int32_t>(h1);
  446|  40.2M|      f2 = static_cast<int32_t>(h2);
  447|  40.2M|      f3 = static_cast<int32_t>(h3);
  448|  40.2M|      f4 = static_cast<int32_t>(h4);
  449|  40.2M|      f5 = static_cast<int32_t>(h5);
  450|  40.2M|      f6 = static_cast<int32_t>(h6);
  451|  40.2M|      f7 = static_cast<int32_t>(h7);
  452|  40.2M|      f8 = static_cast<int32_t>(h8);
  453|  40.2M|      f9 = static_cast<int32_t>(h9);
  454|  40.2M|   }
  455|       |
  456|  21.2M|   return FE_25519(f0, f1, f2, f3, f4, f5, f6, f7, f8, f9);
  457|  21.2M|}
_ZN5Botan8FE_255194sqr2ERKS0_:
  475|  6.75M|FE_25519 FE_25519::sqr2(const FE_25519& f) {
  476|  6.75M|   const int32_t f0 = f[0];
  477|  6.75M|   const int32_t f1 = f[1];
  478|  6.75M|   const int32_t f2 = f[2];
  479|  6.75M|   const int32_t f3 = f[3];
  480|  6.75M|   const int32_t f4 = f[4];
  481|  6.75M|   const int32_t f5 = f[5];
  482|  6.75M|   const int32_t f6 = f[6];
  483|  6.75M|   const int32_t f7 = f[7];
  484|  6.75M|   const int32_t f8 = f[8];
  485|  6.75M|   const int32_t f9 = f[9];
  486|  6.75M|   const int32_t f0_2 = 2 * f0;
  487|  6.75M|   const int32_t f1_2 = 2 * f1;
  488|  6.75M|   const int32_t f2_2 = 2 * f2;
  489|  6.75M|   const int32_t f3_2 = 2 * f3;
  490|  6.75M|   const int32_t f4_2 = 2 * f4;
  491|  6.75M|   const int32_t f5_2 = 2 * f5;
  492|  6.75M|   const int32_t f6_2 = 2 * f6;
  493|  6.75M|   const int32_t f7_2 = 2 * f7;
  494|  6.75M|   const int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */
  495|  6.75M|   const int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */
  496|  6.75M|   const int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */
  497|  6.75M|   const int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */
  498|  6.75M|   const int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */
  499|  6.75M|   const int64_t f0f0 = f0 * static_cast<int64_t>(f0);
  500|  6.75M|   const int64_t f0f1_2 = f0_2 * static_cast<int64_t>(f1);
  501|  6.75M|   const int64_t f0f2_2 = f0_2 * static_cast<int64_t>(f2);
  502|  6.75M|   const int64_t f0f3_2 = f0_2 * static_cast<int64_t>(f3);
  503|  6.75M|   const int64_t f0f4_2 = f0_2 * static_cast<int64_t>(f4);
  504|  6.75M|   const int64_t f0f5_2 = f0_2 * static_cast<int64_t>(f5);
  505|  6.75M|   const int64_t f0f6_2 = f0_2 * static_cast<int64_t>(f6);
  506|  6.75M|   const int64_t f0f7_2 = f0_2 * static_cast<int64_t>(f7);
  507|  6.75M|   const int64_t f0f8_2 = f0_2 * static_cast<int64_t>(f8);
  508|  6.75M|   const int64_t f0f9_2 = f0_2 * static_cast<int64_t>(f9);
  509|  6.75M|   const int64_t f1f1_2 = f1_2 * static_cast<int64_t>(f1);
  510|  6.75M|   const int64_t f1f2_2 = f1_2 * static_cast<int64_t>(f2);
  511|  6.75M|   const int64_t f1f3_4 = f1_2 * static_cast<int64_t>(f3_2);
  512|  6.75M|   const int64_t f1f4_2 = f1_2 * static_cast<int64_t>(f4);
  513|  6.75M|   const int64_t f1f5_4 = f1_2 * static_cast<int64_t>(f5_2);
  514|  6.75M|   const int64_t f1f6_2 = f1_2 * static_cast<int64_t>(f6);
  515|  6.75M|   const int64_t f1f7_4 = f1_2 * static_cast<int64_t>(f7_2);
  516|  6.75M|   const int64_t f1f8_2 = f1_2 * static_cast<int64_t>(f8);
  517|  6.75M|   const int64_t f1f9_76 = f1_2 * static_cast<int64_t>(f9_38);
  518|  6.75M|   const int64_t f2f2 = f2 * static_cast<int64_t>(f2);
  519|  6.75M|   const int64_t f2f3_2 = f2_2 * static_cast<int64_t>(f3);
  520|  6.75M|   const int64_t f2f4_2 = f2_2 * static_cast<int64_t>(f4);
  521|  6.75M|   const int64_t f2f5_2 = f2_2 * static_cast<int64_t>(f5);
  522|  6.75M|   const int64_t f2f6_2 = f2_2 * static_cast<int64_t>(f6);
  523|  6.75M|   const int64_t f2f7_2 = f2_2 * static_cast<int64_t>(f7);
  524|  6.75M|   const int64_t f2f8_38 = f2_2 * static_cast<int64_t>(f8_19);
  525|  6.75M|   const int64_t f2f9_38 = f2 * static_cast<int64_t>(f9_38);
  526|  6.75M|   const int64_t f3f3_2 = f3_2 * static_cast<int64_t>(f3);
  527|  6.75M|   const int64_t f3f4_2 = f3_2 * static_cast<int64_t>(f4);
  528|  6.75M|   const int64_t f3f5_4 = f3_2 * static_cast<int64_t>(f5_2);
  529|  6.75M|   const int64_t f3f6_2 = f3_2 * static_cast<int64_t>(f6);
  530|  6.75M|   const int64_t f3f7_76 = f3_2 * static_cast<int64_t>(f7_38);
  531|  6.75M|   const int64_t f3f8_38 = f3_2 * static_cast<int64_t>(f8_19);
  532|  6.75M|   const int64_t f3f9_76 = f3_2 * static_cast<int64_t>(f9_38);
  533|  6.75M|   const int64_t f4f4 = f4 * static_cast<int64_t>(f4);
  534|  6.75M|   const int64_t f4f5_2 = f4_2 * static_cast<int64_t>(f5);
  535|  6.75M|   const int64_t f4f6_38 = f4_2 * static_cast<int64_t>(f6_19);
  536|  6.75M|   const int64_t f4f7_38 = f4 * static_cast<int64_t>(f7_38);
  537|  6.75M|   const int64_t f4f8_38 = f4_2 * static_cast<int64_t>(f8_19);
  538|  6.75M|   const int64_t f4f9_38 = f4 * static_cast<int64_t>(f9_38);
  539|  6.75M|   const int64_t f5f5_38 = f5 * static_cast<int64_t>(f5_38);
  540|  6.75M|   const int64_t f5f6_38 = f5_2 * static_cast<int64_t>(f6_19);
  541|  6.75M|   const int64_t f5f7_76 = f5_2 * static_cast<int64_t>(f7_38);
  542|  6.75M|   const int64_t f5f8_38 = f5_2 * static_cast<int64_t>(f8_19);
  543|  6.75M|   const int64_t f5f9_76 = f5_2 * static_cast<int64_t>(f9_38);
  544|  6.75M|   const int64_t f6f6_19 = f6 * static_cast<int64_t>(f6_19);
  545|  6.75M|   const int64_t f6f7_38 = f6 * static_cast<int64_t>(f7_38);
  546|  6.75M|   const int64_t f6f8_38 = f6_2 * static_cast<int64_t>(f8_19);
  547|  6.75M|   const int64_t f6f9_38 = f6 * static_cast<int64_t>(f9_38);
  548|  6.75M|   const int64_t f7f7_38 = f7 * static_cast<int64_t>(f7_38);
  549|  6.75M|   const int64_t f7f8_38 = f7_2 * static_cast<int64_t>(f8_19);
  550|  6.75M|   const int64_t f7f9_76 = f7_2 * static_cast<int64_t>(f9_38);
  551|  6.75M|   const int64_t f8f8_19 = f8 * static_cast<int64_t>(f8_19);
  552|  6.75M|   const int64_t f8f9_38 = f8 * static_cast<int64_t>(f9_38);
  553|  6.75M|   const int64_t f9f9_38 = f9 * static_cast<int64_t>(f9_38);
  554|       |
  555|  6.75M|   int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;
  556|  6.75M|   int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;
  557|  6.75M|   int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;
  558|  6.75M|   int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;
  559|  6.75M|   int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;
  560|  6.75M|   int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;
  561|  6.75M|   int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;
  562|  6.75M|   int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;
  563|  6.75M|   int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;
  564|  6.75M|   int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;
  565|       |
  566|  6.75M|   h0 += h0;
  567|  6.75M|   h1 += h1;
  568|  6.75M|   h2 += h2;
  569|  6.75M|   h3 += h3;
  570|  6.75M|   h4 += h4;
  571|  6.75M|   h5 += h5;
  572|  6.75M|   h6 += h6;
  573|  6.75M|   h7 += h7;
  574|  6.75M|   h8 += h8;
  575|  6.75M|   h9 += h9;
  576|       |
  577|  6.75M|   carry<26>(h0, h1);
  578|  6.75M|   carry<26>(h4, h5);
  579|       |
  580|  6.75M|   carry<25>(h1, h2);
  581|  6.75M|   carry<25>(h5, h6);
  582|       |
  583|  6.75M|   carry<26>(h2, h3);
  584|  6.75M|   carry<26>(h6, h7);
  585|       |
  586|  6.75M|   carry<25>(h3, h4);
  587|  6.75M|   carry<25>(h7, h8);
  588|  6.75M|   carry<26>(h4, h5);
  589|  6.75M|   carry<26>(h8, h9);
  590|  6.75M|   carry<25, 19>(h9, h0);
  591|  6.75M|   carry<26>(h0, h1);
  592|       |
  593|  6.75M|   return FE_25519(h0, h1, h2, h3, h4, h5, h6, h7, h8, h9);
  594|  6.75M|}
_ZN5Botan8FE_2551910from_bytesEPKh:
  600|  26.2k|void FE_25519::from_bytes(const uint8_t s[32]) {
  601|  26.2k|   int64_t h0 = load_4(s);
  602|  26.2k|   int64_t h1 = load_3(s + 4) << 6;
  603|  26.2k|   int64_t h2 = load_3(s + 7) << 5;
  604|  26.2k|   int64_t h3 = load_3(s + 10) << 3;
  605|  26.2k|   int64_t h4 = load_3(s + 13) << 2;
  606|  26.2k|   int64_t h5 = load_4(s + 16);
  607|  26.2k|   int64_t h6 = load_3(s + 20) << 7;
  608|  26.2k|   int64_t h7 = load_3(s + 23) << 5;
  609|  26.2k|   int64_t h8 = load_3(s + 26) << 4;
  610|  26.2k|   int64_t h9 = (load_3(s + 29) & 0x7fffff) << 2;
  611|       |
  612|  26.2k|   carry<25, 19>(h9, h0);
  613|  26.2k|   carry<25>(h1, h2);
  614|  26.2k|   carry<25>(h3, h4);
  615|  26.2k|   carry<25>(h5, h6);
  616|  26.2k|   carry<25>(h7, h8);
  617|       |
  618|  26.2k|   carry<26>(h0, h1);
  619|  26.2k|   carry<26>(h2, h3);
  620|  26.2k|   carry<26>(h4, h5);
  621|  26.2k|   carry<26>(h6, h7);
  622|  26.2k|   carry<26>(h8, h9);
  623|       |
  624|  26.2k|   m_fe[0] = static_cast<int32_t>(h0);
  625|  26.2k|   m_fe[1] = static_cast<int32_t>(h1);
  626|  26.2k|   m_fe[2] = static_cast<int32_t>(h2);
  627|  26.2k|   m_fe[3] = static_cast<int32_t>(h3);
  628|  26.2k|   m_fe[4] = static_cast<int32_t>(h4);
  629|  26.2k|   m_fe[5] = static_cast<int32_t>(h5);
  630|  26.2k|   m_fe[6] = static_cast<int32_t>(h6);
  631|  26.2k|   m_fe[7] = static_cast<int32_t>(h7);
  632|  26.2k|   m_fe[8] = static_cast<int32_t>(h8);
  633|  26.2k|   m_fe[9] = static_cast<int32_t>(h9);
  634|  26.2k|}
_ZNK5Botan8FE_255198to_bytesEPh:
  661|   170k|void FE_25519::to_bytes(uint8_t s[32]) const {
  662|   170k|   const int64_t X25 = (1 << 25);
  663|       |
  664|   170k|   int32_t h0 = m_fe[0];
  665|   170k|   int32_t h1 = m_fe[1];
  666|   170k|   int32_t h2 = m_fe[2];
  667|   170k|   int32_t h3 = m_fe[3];
  668|   170k|   int32_t h4 = m_fe[4];
  669|   170k|   int32_t h5 = m_fe[5];
  670|   170k|   int32_t h6 = m_fe[6];
  671|   170k|   int32_t h7 = m_fe[7];
  672|   170k|   int32_t h8 = m_fe[8];
  673|   170k|   int32_t h9 = m_fe[9];
  674|   170k|   int32_t q;
  675|       |
  676|   170k|   q = (19 * h9 + ((static_cast<int32_t>(1) << 24))) >> 25;
  677|   170k|   q = (h0 + q) >> 26;
  678|   170k|   q = (h1 + q) >> 25;
  679|   170k|   q = (h2 + q) >> 26;
  680|   170k|   q = (h3 + q) >> 25;
  681|   170k|   q = (h4 + q) >> 26;
  682|   170k|   q = (h5 + q) >> 25;
  683|   170k|   q = (h6 + q) >> 26;
  684|   170k|   q = (h7 + q) >> 25;
  685|   170k|   q = (h8 + q) >> 26;
  686|   170k|   q = (h9 + q) >> 25;
  687|       |
  688|       |   /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */
  689|   170k|   h0 += 19 * q;
  690|       |   /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */
  691|       |
  692|   170k|   carry0<26>(h0, h1);
  693|   170k|   carry0<25>(h1, h2);
  694|   170k|   carry0<26>(h2, h3);
  695|   170k|   carry0<25>(h3, h4);
  696|   170k|   carry0<26>(h4, h5);
  697|   170k|   carry0<25>(h5, h6);
  698|   170k|   carry0<26>(h6, h7);
  699|   170k|   carry0<25>(h7, h8);
  700|   170k|   carry0<26>(h8, h9);
  701|       |
  702|   170k|   int32_t carry9 = h9 >> 25;
  703|   170k|   h9 -= carry9 * X25;
  704|       |   /* h10 = carry9 */
  705|       |
  706|       |   /*
  707|       |   Goal: Output h0+...+2^255 h10-2^255 q, which is between 0 and 2^255-20.
  708|       |   Have h0+...+2^230 h9 between 0 and 2^255-1;
  709|       |   evidently 2^255 h10-2^255 q = 0.
  710|       |   Goal: Output h0+...+2^230 h9.
  711|       |   */
  712|       |
  713|   170k|   s[0] = static_cast<uint8_t>(h0 >> 0);
  714|   170k|   s[1] = static_cast<uint8_t>(h0 >> 8);
  715|   170k|   s[2] = static_cast<uint8_t>(h0 >> 16);
  716|   170k|   s[3] = static_cast<uint8_t>((h0 >> 24) | (h1 << 2));
  717|   170k|   s[4] = static_cast<uint8_t>(h1 >> 6);
  718|   170k|   s[5] = static_cast<uint8_t>(h1 >> 14);
  719|   170k|   s[6] = static_cast<uint8_t>((h1 >> 22) | (h2 << 3));
  720|   170k|   s[7] = static_cast<uint8_t>(h2 >> 5);
  721|   170k|   s[8] = static_cast<uint8_t>(h2 >> 13);
  722|   170k|   s[9] = static_cast<uint8_t>((h2 >> 21) | (h3 << 5));
  723|   170k|   s[10] = static_cast<uint8_t>(h3 >> 3);
  724|   170k|   s[11] = static_cast<uint8_t>(h3 >> 11);
  725|   170k|   s[12] = static_cast<uint8_t>((h3 >> 19) | (h4 << 6));
  726|   170k|   s[13] = static_cast<uint8_t>(h4 >> 2);
  727|   170k|   s[14] = static_cast<uint8_t>(h4 >> 10);
  728|   170k|   s[15] = static_cast<uint8_t>(h4 >> 18);
  729|   170k|   s[16] = static_cast<uint8_t>(h5 >> 0);
  730|   170k|   s[17] = static_cast<uint8_t>(h5 >> 8);
  731|   170k|   s[18] = static_cast<uint8_t>(h5 >> 16);
  732|   170k|   s[19] = static_cast<uint8_t>((h5 >> 24) | (h6 << 1));
  733|   170k|   s[20] = static_cast<uint8_t>(h6 >> 7);
  734|   170k|   s[21] = static_cast<uint8_t>(h6 >> 15);
  735|   170k|   s[22] = static_cast<uint8_t>((h6 >> 23) | (h7 << 3));
  736|   170k|   s[23] = static_cast<uint8_t>(h7 >> 5);
  737|   170k|   s[24] = static_cast<uint8_t>(h7 >> 13);
  738|   170k|   s[25] = static_cast<uint8_t>((h7 >> 21) | (h8 << 4));
  739|   170k|   s[26] = static_cast<uint8_t>(h8 >> 4);
  740|   170k|   s[27] = static_cast<uint8_t>(h8 >> 12);
  741|   170k|   s[28] = static_cast<uint8_t>((h8 >> 20) | (h9 << 6));
  742|   170k|   s[29] = static_cast<uint8_t>(h9 >> 2);
  743|   170k|   s[30] = static_cast<uint8_t>(h9 >> 10);
  744|   170k|   s[31] = static_cast<uint8_t>(h9 >> 18);
  745|   170k|}

_ZNK5Botan17Ed25519_PublicKey9check_keyERNS_21RandomNumberGeneratorEb:
   25|  13.1k|bool Ed25519_PublicKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
   26|  13.1k|   if(m_public.size() != 32) {
  ------------------
  |  Branch (26:7): [True: 0, False: 13.1k]
  ------------------
   27|      0|      return false;
   28|      0|   }
   29|       |
   30|       |   /*
   31|       |   This function was derived from public domain code in Tor's blinding.c
   32|       |   */
   33|       |
   34|  13.1k|   const uint8_t identity_element[32] = {1};
   35|  13.1k|   if(CT::is_equal(m_public.data(), identity_element, 32).as_bool()) {
  ------------------
  |  Branch (35:7): [True: 0, False: 13.1k]
  ------------------
   36|      0|      return false;
   37|      0|   }
   38|       |
   39|       |   // The order of the Ed25519 group encoded
   40|  13.1k|   const uint8_t modm_m[32] = {0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7,
   41|  13.1k|                               0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   42|  13.1k|                               0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
   43|       |
   44|  13.1k|   const unsigned char zero[32] = {0};
   45|       |
   46|  13.1k|   unsigned char pkcopy[32];
   47|       |
   48|  13.1k|   copy_mem(pkcopy, m_public.data(), 32);
   49|  13.1k|   pkcopy[31] ^= (1 << 7);  // flip sign
   50|  13.1k|   ge_p3 point;
   51|  13.1k|   if(ge_frombytes_negate_vartime(&point, pkcopy) != 0) {
  ------------------
  |  Branch (51:7): [True: 0, False: 13.1k]
  ------------------
   52|      0|      return false;
   53|      0|   }
   54|       |
   55|  13.1k|   uint8_t result[32];
   56|  13.1k|   ge_double_scalarmult_vartime(result, modm_m, &point, zero);
   57|       |
   58|  13.1k|   if(!CT::is_equal(result, identity_element, 32).as_bool()) {
  ------------------
  |  Branch (58:7): [True: 0, False: 13.1k]
  ------------------
   59|      0|      return false;
   60|      0|   }
   61|       |
   62|  13.1k|   return true;
   63|  13.1k|}
_ZN5Botan17Ed25519_PublicKeyC1EPKhm:
   65|  13.1k|Ed25519_PublicKey::Ed25519_PublicKey(const uint8_t pub_key[], size_t pub_len) {
   66|  13.1k|   if(pub_len != 32) {
  ------------------
  |  Branch (66:7): [True: 0, False: 13.1k]
  ------------------
   67|      0|      throw Decoding_Error("Invalid length for Ed25519 key");
   68|      0|   }
   69|  13.1k|   m_public.assign(pub_key, pub_key + pub_len);
   70|  13.1k|}
_ZN5Botan18Ed25519_PrivateKeyC1ERNS_21RandomNumberGeneratorE:
  117|  13.1k|Ed25519_PrivateKey::Ed25519_PrivateKey(RandomNumberGenerator& rng) {
  118|  13.1k|   const secure_vector<uint8_t> seed = rng.random_vec(32);
  119|  13.1k|   m_public.resize(32);
  120|  13.1k|   m_private.resize(64);
  121|  13.1k|   ed25519_gen_keypair(m_public.data(), m_private.data(), seed.data());
  122|  13.1k|}
_ZNK5Botan18Ed25519_PrivateKey10public_keyEv:
  136|  13.1k|std::unique_ptr<Public_Key> Ed25519_PrivateKey::public_key() const {
  137|  13.1k|   return std::make_unique<Ed25519_PublicKey>(get_public_key());
  138|  13.1k|}
_ZNK5Botan18Ed25519_PrivateKey9check_keyERNS_21RandomNumberGeneratorEb:
  145|  13.1k|bool Ed25519_PrivateKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
  146|  13.1k|   return true;  // ???
  147|  13.1k|}
_ZNK5Botan17Ed25519_PublicKey22create_verification_opENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEES5_:
  287|  13.1k|                                                                                std::string_view provider) const {
  288|  13.1k|   if(provider == "base" || provider.empty()) {
  ------------------
  |  Branch (288:7): [True: 0, False: 13.1k]
  |  Branch (288:29): [True: 13.1k, False: 0]
  ------------------
  289|  13.1k|      if(params.empty() || params == "Identity" || params == "Pure") {
  ------------------
  |  Branch (289:10): [True: 0, False: 13.1k]
  |  Branch (289:28): [True: 0, False: 13.1k]
  |  Branch (289:52): [True: 0, False: 13.1k]
  ------------------
  290|      0|         return std::make_unique<Ed25519_Pure_Verify_Operation>(*this);
  291|  13.1k|      } else if(params == "Ed25519ph") {
  ------------------
  |  Branch (291:17): [True: 13.1k, False: 0]
  ------------------
  292|  13.1k|         return std::make_unique<Ed25519_Hashed_Verify_Operation>(*this, "SHA-512", true);
  293|  13.1k|      } else {
  294|      0|         return std::make_unique<Ed25519_Hashed_Verify_Operation>(*this, params, false);
  295|      0|      }
  296|  13.1k|   }
  297|      0|   throw Provider_Not_Found(algo_name(), provider);
  298|  13.1k|}
_ZNK5Botan18Ed25519_PrivateKey19create_signature_opERNS_21RandomNumberGeneratorENSt3__117basic_string_viewIcNS3_11char_traitsIcEEEES7_:
  314|  13.1k|                                                                           std::string_view provider) const {
  315|  13.1k|   if(provider == "base" || provider.empty()) {
  ------------------
  |  Branch (315:7): [True: 0, False: 13.1k]
  |  Branch (315:29): [True: 13.1k, False: 0]
  ------------------
  316|  13.1k|      if(params.empty() || params == "Identity" || params == "Pure") {
  ------------------
  |  Branch (316:10): [True: 0, False: 13.1k]
  |  Branch (316:28): [True: 0, False: 13.1k]
  |  Branch (316:52): [True: 0, False: 13.1k]
  ------------------
  317|      0|         return std::make_unique<Ed25519_Pure_Sign_Operation>(*this);
  318|  13.1k|      } else if(params == "Ed25519ph") {
  ------------------
  |  Branch (318:17): [True: 13.1k, False: 0]
  ------------------
  319|  13.1k|         return std::make_unique<Ed25519_Hashed_Sign_Operation>(*this, "SHA-512", true);
  320|  13.1k|      } else {
  321|      0|         return std::make_unique<Ed25519_Hashed_Sign_Operation>(*this, params, false);
  322|      0|      }
  323|  13.1k|   }
  324|      0|   throw Provider_Not_Found(algo_name(), provider);
  325|  13.1k|}
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_131Ed25519_Hashed_Verify_OperationC2ERKNS_17Ed25519_PublicKeyENSt3__117basic_string_viewIcNS5_11char_traitsIcEEEEb:
  184|  13.1k|            m_key(key.get_public_key()) {
  185|  13.1k|         m_hash = HashFunction::create_or_throw(hash);
  186|       |
  187|  13.1k|         if(rfc8032) {
  ------------------
  |  Branch (187:13): [True: 13.1k, False: 0]
  ------------------
  188|  13.1k|            m_domain_sep = {0x53, 0x69, 0x67, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x6E,
  189|  13.1k|                            0x6F, 0x20, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x63, 0x6F,
  190|  13.1k|                            0x6C, 0x6C, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x01, 0x00};
  191|  13.1k|         }
  192|  13.1k|      }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_131Ed25519_Hashed_Verify_Operation6updateENSt3__14spanIKhLm18446744073709551615EEE:
  194|  13.1k|      void update(std::span<const uint8_t> msg) override { m_hash->update(msg); }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_131Ed25519_Hashed_Verify_Operation18is_valid_signatureENSt3__14spanIKhLm18446744073709551615EEE:
  196|  13.1k|      bool is_valid_signature(std::span<const uint8_t> sig) override {
  197|  13.1k|         if(sig.size() != 64) {
  ------------------
  |  Branch (197:13): [True: 0, False: 13.1k]
  ------------------
  198|      0|            return false;
  199|      0|         }
  200|  13.1k|         std::vector<uint8_t> msg_hash(m_hash->output_length());
  201|  13.1k|         m_hash->final(msg_hash.data());
  202|       |
  203|  13.1k|         BOTAN_ASSERT_EQUAL(m_key.size(), 32, "Expected size");
  ------------------
  |  |   71|  13.1k|   do {                                                                                                \
  |  |   72|  13.1k|      if((expr1) != (expr2))                                                                           \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 13.1k]
  |  |  ------------------
  |  |   73|  13.1k|         Botan::assertion_failure(#expr1 " == " #expr2, assertion_made, __func__, __FILE__, __LINE__); \
  |  |   74|  13.1k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (74:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  204|  13.1k|         return ed25519_verify(
  205|  13.1k|            msg_hash.data(), msg_hash.size(), sig.data(), m_key.data(), m_domain_sep.data(), m_domain_sep.size());
  206|  13.1k|      }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_129Ed25519_Hashed_Sign_OperationC2ERKNS_18Ed25519_PrivateKeyENSt3__117basic_string_viewIcNS5_11char_traitsIcEEEEb:
  253|  13.1k|            m_key(key.raw_private_key_bits()) {
  254|  13.1k|         m_hash = HashFunction::create_or_throw(hash);
  255|       |
  256|  13.1k|         if(rfc8032) {
  ------------------
  |  Branch (256:13): [True: 13.1k, False: 0]
  ------------------
  257|  13.1k|            m_domain_sep = std::vector<uint8_t>{0x53, 0x69, 0x67, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x6E,
  258|  13.1k|                                                0x6F, 0x20, 0x45, 0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x20, 0x63, 0x6F,
  259|  13.1k|                                                0x6C, 0x6C, 0x69, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x01, 0x00};
  260|  13.1k|         }
  261|  13.1k|      }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_129Ed25519_Hashed_Sign_Operation6updateENSt3__14spanIKhLm18446744073709551615EEE:
  265|  13.1k|      void update(std::span<const uint8_t> msg) override { m_hash->update(msg); }
ed25519_key.cpp:_ZN5Botan12_GLOBAL__N_129Ed25519_Hashed_Sign_Operation4signERNS_21RandomNumberGeneratorE:
  267|  13.1k|      std::vector<uint8_t> sign(RandomNumberGenerator& /*rng*/) override {
  268|  13.1k|         std::vector<uint8_t> sig(64);
  269|  13.1k|         std::vector<uint8_t> msg_hash(m_hash->output_length());
  270|  13.1k|         m_hash->final(msg_hash.data());
  271|  13.1k|         ed25519_sign(
  272|  13.1k|            sig.data(), msg_hash.data(), msg_hash.size(), m_key.data(), m_domain_sep.data(), m_domain_sep.size());
  273|  13.1k|         return sig;
  274|  13.1k|      }

_ZN5Botan27ge_frombytes_negate_vartimeEPNS_5ge_p3EPKh:
  425|  26.2k|int ge_frombytes_negate_vartime(ge_p3* h, const uint8_t* s) {
  426|  26.2k|   static const FE_25519 d = {
  427|  26.2k|      -10913610, 13857413, -15372611, 6949391, 114729, -8787816, -6275908, -3247719, -18696448, -12055116};
  428|  26.2k|   static const FE_25519 sqrtm1 = {
  429|  26.2k|      -32595792, -7943725, 9377950, 3500415, 12389472, -272473, -25146209, -2005654, 326686, 11406482};
  430|       |
  431|  26.2k|   FE_25519 u;
  432|  26.2k|   FE_25519 v;
  433|  26.2k|   FE_25519 v3;
  434|  26.2k|   FE_25519 vxx;
  435|  26.2k|   FE_25519 check;
  436|       |
  437|  26.2k|   fe_frombytes(h->Y, s);
  438|  26.2k|   fe_1(h->Z);
  439|  26.2k|   fe_sq(u, h->Y);
  440|  26.2k|   fe_mul(v, u, d);
  441|  26.2k|   fe_sub(u, u, h->Z); /* u = y^2-1 */
  442|  26.2k|   fe_add(v, v, h->Z); /* v = dy^2+1 */
  443|       |
  444|  26.2k|   fe_sq(v3, v);
  445|  26.2k|   fe_mul(v3, v3, v); /* v3 = v^3 */
  446|  26.2k|   fe_sq(h->X, v3);
  447|  26.2k|   fe_mul(h->X, h->X, v);
  448|  26.2k|   fe_mul(h->X, h->X, u); /* x = uv^7 */
  449|       |
  450|  26.2k|   fe_pow22523(h->X, h->X); /* x = (uv^7)^((q-5)/8) */
  451|  26.2k|   fe_mul(h->X, h->X, v3);
  452|  26.2k|   fe_mul(h->X, h->X, u); /* x = uv^3(uv^7)^((q-5)/8) */
  453|       |
  454|  26.2k|   fe_sq(vxx, h->X);
  455|  26.2k|   fe_mul(vxx, vxx, v);
  456|  26.2k|   fe_sub(check, vxx, u); /* vx^2-u */
  457|  26.2k|   if(fe_isnonzero(check)) {
  ------------------
  |  Branch (457:7): [True: 13.0k, False: 13.1k]
  ------------------
  458|  13.0k|      fe_add(check, vxx, u); /* vx^2+u */
  459|  13.0k|      if(fe_isnonzero(check)) {
  ------------------
  |  Branch (459:10): [True: 0, False: 13.0k]
  ------------------
  460|      0|         return -1;
  461|      0|      }
  462|  13.0k|      fe_mul(h->X, h->X, sqrtm1);
  463|  13.0k|   }
  464|       |
  465|  26.2k|   if(fe_isnegative(h->X) == (s[31] >> 7)) {
  ------------------
  |  Branch (465:7): [True: 13.1k, False: 13.1k]
  ------------------
  466|  13.1k|      fe_neg(h->X, h->X);
  467|  13.1k|   }
  468|       |
  469|  26.2k|   fe_mul(h->T, h->X, h->Y);
  470|  26.2k|   return 0;
  471|  26.2k|}
_ZN5Botan28ge_double_scalarmult_vartimeEPhPKhPKNS_5ge_p3ES2_:
  480|  26.2k|void ge_double_scalarmult_vartime(uint8_t out[32], const uint8_t* a, const ge_p3* A, const uint8_t* b) {
  481|  26.2k|   static const ge_precomp Bi[8] = {
  482|  26.2k|      {
  483|  26.2k|         {25967493, -14356035, 29566456, 3660896, -12694345, 4014787, 27544626, -11754271, -6079156, 2047605},
  484|  26.2k|         {-12545711, 934262, -2722910, 3049990, -727428, 9406986, 12720692, 5043384, 19500929, -15469378},
  485|  26.2k|         {-8738181, 4489570, 9688441, -14785194, 10184609, -12363380, 29287919, 11864899, -24514362, -4438546},
  486|  26.2k|      },
  487|  26.2k|      {
  488|  26.2k|         {15636291, -9688557, 24204773, -7912398, 616977, -16685262, 27787600, -14772189, 28944400, -1550024},
  489|  26.2k|         {16568933, 4717097, -11556148, -1102322, 15682896, -11807043, 16354577, -11775962, 7689662, 11199574},
  490|  26.2k|         {30464156, -5976125, -11779434, -15670865, 23220365, 15915852, 7512774, 10017326, -17749093, -9920357},
  491|  26.2k|      },
  492|  26.2k|      {
  493|  26.2k|         {10861363, 11473154, 27284546, 1981175, -30064349, 12577861, 32867885, 14515107, -15438304, 10819380},
  494|  26.2k|         {4708026, 6336745, 20377586, 9066809, -11272109, 6594696, -25653668, 12483688, -12668491, 5581306},
  495|  26.2k|         {19563160, 16186464, -29386857, 4097519, 10237984, -4348115, 28542350, 13850243, -23678021, -15815942},
  496|  26.2k|      },
  497|  26.2k|      {
  498|  26.2k|         {5153746, 9909285, 1723747, -2777874, 30523605, 5516873, 19480852, 5230134, -23952439, -15175766},
  499|  26.2k|         {-30269007, -3463509, 7665486, 10083793, 28475525, 1649722, 20654025, 16520125, 30598449, 7715701},
  500|  26.2k|         {28881845, 14381568, 9657904, 3680757, -20181635, 7843316, -31400660, 1370708, 29794553, -1409300},
  501|  26.2k|      },
  502|  26.2k|      {
  503|  26.2k|         {-22518993, -6692182, 14201702, -8745502, -23510406, 8844726, 18474211, -1361450, -13062696, 13821877},
  504|  26.2k|         {-6455177, -7839871, 3374702, -4740862, -27098617, -10571707, 31655028, -7212327, 18853322, -14220951},
  505|  26.2k|         {4566830, -12963868, -28974889, -12240689, -7602672, -2830569, -8514358, -10431137, 2207753, -3209784},
  506|  26.2k|      },
  507|  26.2k|      {
  508|  26.2k|         {-25154831, -4185821, 29681144, 7868801, -6854661, -9423865, -12437364, -663000, -31111463, -16132436},
  509|  26.2k|         {25576264, -2703214, 7349804, -11814844, 16472782, 9300885, 3844789, 15725684, 171356, 6466918},
  510|  26.2k|         {23103977, 13316479, 9739013, -16149481, 817875, -15038942, 8965339, -14088058, -30714912, 16193877},
  511|  26.2k|      },
  512|  26.2k|      {
  513|  26.2k|         {-33521811, 3180713, -2394130, 14003687, -16903474, -16270840, 17238398, 4729455, -18074513, 9256800},
  514|  26.2k|         {-25182317, -4174131, 32336398, 5036987, -21236817, 11360617, 22616405, 9761698, -19827198, 630305},
  515|  26.2k|         {-13720693, 2639453, -24237460, -7406481, 9494427, -5774029, -6554551, -15960994, -2449256, -14291300},
  516|  26.2k|      },
  517|  26.2k|      {
  518|  26.2k|         {-3151181, -5046075, 9282714, 6866145, -31907062, -863023, -18940575, 15033784, 25105118, -7894876},
  519|  26.2k|         {-24326370, 15950226, -31801215, -14592823, -11662737, -5090925, 1573892, -2625887, 2198790, -15804619},
  520|  26.2k|         {-3099351, 10324967, -2241613, 7453183, -5446979, -2735503, -13812022, -16236442, -32461234, -12290683},
  521|  26.2k|      },
  522|  26.2k|   };
  523|       |
  524|  26.2k|   int8_t aslide[256];
  525|  26.2k|   int8_t bslide[256];
  526|  26.2k|   ge_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */
  527|  26.2k|   ge_p1p1 t;
  528|  26.2k|   ge_p3 u;
  529|  26.2k|   ge_p3 A2;
  530|  26.2k|   ge_p2 r;
  531|  26.2k|   int i;
  532|       |
  533|  26.2k|   slide(aslide, a);
  534|  26.2k|   slide(bslide, b);
  535|       |
  536|  26.2k|   ge_p3_to_cached(&Ai[0], A);
  537|  26.2k|   ge_p3_dbl(&t, A);
  538|  26.2k|   ge_p1p1_to_p3(&A2, &t);
  539|  26.2k|   ge_add(&t, &A2, &Ai[0]);
  540|  26.2k|   ge_p1p1_to_p3(&u, &t);
  541|  26.2k|   ge_p3_to_cached(&Ai[1], &u);
  542|  26.2k|   ge_add(&t, &A2, &Ai[1]);
  543|  26.2k|   ge_p1p1_to_p3(&u, &t);
  544|  26.2k|   ge_p3_to_cached(&Ai[2], &u);
  545|  26.2k|   ge_add(&t, &A2, &Ai[2]);
  546|  26.2k|   ge_p1p1_to_p3(&u, &t);
  547|  26.2k|   ge_p3_to_cached(&Ai[3], &u);
  548|  26.2k|   ge_add(&t, &A2, &Ai[3]);
  549|  26.2k|   ge_p1p1_to_p3(&u, &t);
  550|  26.2k|   ge_p3_to_cached(&Ai[4], &u);
  551|  26.2k|   ge_add(&t, &A2, &Ai[4]);
  552|  26.2k|   ge_p1p1_to_p3(&u, &t);
  553|  26.2k|   ge_p3_to_cached(&Ai[5], &u);
  554|  26.2k|   ge_add(&t, &A2, &Ai[5]);
  555|  26.2k|   ge_p1p1_to_p3(&u, &t);
  556|  26.2k|   ge_p3_to_cached(&Ai[6], &u);
  557|  26.2k|   ge_add(&t, &A2, &Ai[6]);
  558|  26.2k|   ge_p1p1_to_p3(&u, &t);
  559|  26.2k|   ge_p3_to_cached(&Ai[7], &u);
  560|       |
  561|  26.2k|   ge_p2_0(&r);
  562|       |
  563|   125k|   for(i = 255; i >= 0; --i) {
  ------------------
  |  Branch (563:17): [True: 125k, False: 0]
  ------------------
  564|   125k|      if(aslide[i] || bslide[i]) {
  ------------------
  |  Branch (564:10): [True: 20.8k, False: 104k]
  |  Branch (564:23): [True: 5.43k, False: 98.8k]
  ------------------
  565|  26.2k|         break;
  566|  26.2k|      }
  567|   125k|   }
  568|       |
  569|  6.64M|   for(; i >= 0; --i) {
  ------------------
  |  Branch (569:10): [True: 6.62M, False: 26.2k]
  ------------------
  570|  6.62M|      ge_p2_dbl(&t, &r);
  571|       |
  572|  6.62M|      if(aslide[i] > 0) {
  ------------------
  |  Branch (572:10): [True: 428k, False: 6.19M]
  ------------------
  573|   428k|         ge_p1p1_to_p3(&u, &t);
  574|   428k|         ge_add(&t, &u, &Ai[aslide[i] >> 1]);
  575|  6.19M|      } else if(aslide[i] < 0) {
  ------------------
  |  Branch (575:17): [True: 430k, False: 5.76M]
  ------------------
  576|   430k|         ge_p1p1_to_p3(&u, &t);
  577|   430k|         ge_sub(&t, &u, &Ai[(-aslide[i]) >> 1]);
  578|   430k|      }
  579|       |
  580|  6.62M|      if(bslide[i] > 0) {
  ------------------
  |  Branch (580:10): [True: 284k, False: 6.33M]
  ------------------
  581|   284k|         ge_p1p1_to_p3(&u, &t);
  582|   284k|         ge_madd(&t, &u, &Bi[bslide[i] >> 1]);
  583|  6.33M|      } else if(bslide[i] < 0) {
  ------------------
  |  Branch (583:17): [True: 272k, False: 6.06M]
  ------------------
  584|   272k|         ge_p1p1_to_p3(&u, &t);
  585|   272k|         ge_msub(&t, &u, &Bi[(-bslide[i]) >> 1]);
  586|   272k|      }
  587|       |
  588|  6.62M|      ge_p1p1_to_p2(&r, &t);
  589|  6.62M|   }
  590|       |
  591|  26.2k|   ge_tobytes(out, &r);
  592|  26.2k|}
_ZN5Botan18ge_scalarmult_baseEPhPKh:
 2043|  26.2k|void ge_scalarmult_base(uint8_t out[32], const uint8_t a[32]) {
 2044|  26.2k|   int8_t e[64];
 2045|  26.2k|   int8_t carry;
 2046|  26.2k|   ge_p1p1 r;
 2047|  26.2k|   ge_p2 s;
 2048|  26.2k|   ge_p3 h;
 2049|  26.2k|   ge_precomp t;
 2050|  26.2k|   int i;
 2051|       |
 2052|   866k|   for(i = 0; i < 32; ++i) {
  ------------------
  |  Branch (2052:15): [True: 839k, False: 26.2k]
  ------------------
 2053|   839k|      e[2 * i + 0] = (a[i] >> 0) & 15;
 2054|   839k|      e[2 * i + 1] = (a[i] >> 4) & 15;
 2055|   839k|   }
 2056|       |   /* each e[i] is between 0 and 15 */
 2057|       |   /* e[63] is between 0 and 7 */
 2058|       |
 2059|  26.2k|   carry = 0;
 2060|  1.67M|   for(i = 0; i < 63; ++i) {
  ------------------
  |  Branch (2060:15): [True: 1.65M, False: 26.2k]
  ------------------
 2061|  1.65M|      e[i] += carry;
 2062|  1.65M|      carry = e[i] + 8;
 2063|  1.65M|      carry >>= 4;
 2064|  1.65M|      e[i] -= carry << 4;
 2065|  1.65M|   }
 2066|  26.2k|   e[63] += carry;
 2067|       |   /* each e[i] is between -8 and 8 */
 2068|       |
 2069|  26.2k|   ge_p3_0(&h);
 2070|   866k|   for(i = 1; i < 64; i += 2) {
  ------------------
  |  Branch (2070:15): [True: 839k, False: 26.2k]
  ------------------
 2071|   839k|      select(&t, B_precomp[i / 2], e[i]);
 2072|   839k|      ge_madd(&r, &h, &t);
 2073|   839k|      ge_p1p1_to_p3(&h, &r);
 2074|   839k|   }
 2075|       |
 2076|  26.2k|   ge_p3_dbl(&r, &h);
 2077|  26.2k|   ge_p1p1_to_p2(&s, &r);
 2078|  26.2k|   ge_p2_dbl(&r, &s);
 2079|  26.2k|   ge_p1p1_to_p2(&s, &r);
 2080|  26.2k|   ge_p2_dbl(&r, &s);
 2081|  26.2k|   ge_p1p1_to_p2(&s, &r);
 2082|  26.2k|   ge_p2_dbl(&r, &s);
 2083|  26.2k|   ge_p1p1_to_p3(&h, &r);
 2084|       |
 2085|   866k|   for(i = 0; i < 64; i += 2) {
  ------------------
  |  Branch (2085:15): [True: 839k, False: 26.2k]
  ------------------
 2086|   839k|      select(&t, B_precomp[i / 2], e[i]);
 2087|   839k|      ge_madd(&r, &h, &t);
 2088|   839k|      ge_p1p1_to_p3(&h, &r);
 2089|   839k|   }
 2090|       |
 2091|  26.2k|   ge_p3_tobytes(out, &h);
 2092|  26.2k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_15slideEPaPKh:
  375|  52.4k|void slide(int8_t* r, const uint8_t* a) {
  376|  13.4M|   for(size_t i = 0; i < 256; ++i) {
  ------------------
  |  Branch (376:22): [True: 13.4M, False: 52.4k]
  ------------------
  377|  13.4M|      r[i] = 1 & (a[i >> 3] >> (i & 7));
  378|  13.4M|   }
  379|       |
  380|  13.4M|   for(size_t i = 0; i < 256; ++i) {
  ------------------
  |  Branch (380:22): [True: 13.4M, False: 52.4k]
  ------------------
  381|  13.4M|      if(r[i]) {
  ------------------
  |  Branch (381:10): [True: 1.41M, False: 12.0M]
  ------------------
  382|  8.11M|         for(size_t b = 1; b <= 6 && i + b < 256; ++b) {
  ------------------
  |  Branch (382:28): [True: 7.75M, False: 361k]
  |  Branch (382:38): [True: 7.72M, False: 26.2k]
  ------------------
  383|  7.72M|            if(r[i + b]) {
  ------------------
  |  Branch (383:16): [True: 3.90M, False: 3.81M]
  ------------------
  384|  3.90M|               if(r[i] + (r[i + b] << b) <= 15) {
  ------------------
  |  Branch (384:19): [True: 2.17M, False: 1.73M]
  ------------------
  385|  2.17M|                  r[i] += r[i + b] << b;
  386|  2.17M|                  r[i + b] = 0;
  387|  2.17M|               } else if(r[i] - (r[i + b] << b) >= -15) {
  ------------------
  |  Branch (387:26): [True: 702k, False: 1.02M]
  ------------------
  388|   702k|                  r[i] -= r[i + b] << b;
  389|  2.07M|                  for(size_t k = i + b; k < 256; ++k) {
  ------------------
  |  Branch (389:41): [True: 2.07M, False: 0]
  ------------------
  390|  2.07M|                     if(!r[k]) {
  ------------------
  |  Branch (390:25): [True: 702k, False: 1.37M]
  ------------------
  391|   702k|                        r[k] = 1;
  392|   702k|                        break;
  393|   702k|                     }
  394|  1.37M|                     r[k] = 0;
  395|  1.37M|                  }
  396|  1.02M|               } else {
  397|  1.02M|                  break;
  398|  1.02M|               }
  399|  3.90M|            }
  400|  7.72M|         }
  401|  1.41M|      }
  402|  13.4M|   }
  403|  52.4k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_115ge_p3_to_cachedEPNS0_9ge_cachedEPKNS_5ge_p3E:
  304|   209k|void ge_p3_to_cached(ge_cached* r, const ge_p3* p) {
  305|   209k|   static const FE_25519 d2 = {
  306|   209k|      -21827239, -5839606, -30745221, 13898782, 229458, 15978800, -12551817, -6495438, 29715968, 9444199};
  307|   209k|   fe_add(r->YplusX, p->Y, p->X);
  308|   209k|   fe_sub(r->YminusX, p->Y, p->X);
  309|   209k|   fe_copy(r->Z, p->Z);
  310|   209k|   fe_mul(r->T2d, p->T, d2);
  311|   209k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_19ge_p3_dblEPNS0_7ge_p1p1EPKNS_5ge_p3E:
  291|  52.4k|void ge_p3_dbl(ge_p1p1* r, const ge_p3* p) {
  292|  52.4k|   ge_p2 q;
  293|       |   // Convert to p2 rep
  294|  52.4k|   q.X = p->X;
  295|  52.4k|   q.Y = p->Y;
  296|  52.4k|   q.Z = p->Z;
  297|  52.4k|   ge_p2_dbl(r, &q);
  298|  52.4k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_113ge_p1p1_to_p3EPNS_5ge_p3EPKNS0_7ge_p1p1E:
  221|  3.33M|void ge_p1p1_to_p3(ge_p3* r, const ge_p1p1* p) {
  222|  3.33M|   fe_mul(r->X, p->X, p->T);
  223|  3.33M|   fe_mul(r->Y, p->Y, p->Z);
  224|  3.33M|   fe_mul(r->Z, p->Z, p->T);
  225|  3.33M|   fe_mul(r->T, p->X, p->Y);
  226|  3.33M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_16ge_addEPNS0_7ge_p1p1EPKNS_5ge_p3EPKNS0_9ge_cachedE:
   54|   611k|void ge_add(ge_p1p1* r, const ge_p3* p, const ge_cached* q) {
   55|   611k|   FE_25519 t0;
   56|       |   /* qhasm: YpX1 = Y1+X1 */
   57|       |   /* asm 1: fe_add(>YpX1=fe#1,<Y1=fe#12,<X1=fe#11); */
   58|       |   /* asm 2: fe_add(>YpX1=r->X,<Y1=p->Y,<X1=p->X); */
   59|   611k|   fe_add(r->X, p->Y, p->X);
   60|       |
   61|       |   /* qhasm: YmX1 = Y1-X1 */
   62|       |   /* asm 1: fe_sub(>YmX1=fe#2,<Y1=fe#12,<X1=fe#11); */
   63|       |   /* asm 2: fe_sub(>YmX1=r->Y,<Y1=p->Y,<X1=p->X); */
   64|   611k|   fe_sub(r->Y, p->Y, p->X);
   65|       |
   66|       |   /* qhasm: A = YpX1*YpX2 */
   67|       |   /* asm 1: fe_mul(>A=fe#3,<YpX1=fe#1,<YpX2=fe#15); */
   68|       |   /* asm 2: fe_mul(>A=r->Z,<YpX1=r->X,<YpX2=q->YplusX); */
   69|   611k|   fe_mul(r->Z, r->X, q->YplusX);
   70|       |
   71|       |   /* qhasm: B = YmX1*YmX2 */
   72|       |   /* asm 1: fe_mul(>B=fe#2,<YmX1=fe#2,<YmX2=fe#16); */
   73|       |   /* asm 2: fe_mul(>B=r->Y,<YmX1=r->Y,<YmX2=q->YminusX); */
   74|   611k|   fe_mul(r->Y, r->Y, q->YminusX);
   75|       |
   76|       |   /* qhasm: C = T2d2*T1 */
   77|       |   /* asm 1: fe_mul(>C=fe#4,<T2d2=fe#18,<T1=fe#14); */
   78|       |   /* asm 2: fe_mul(>C=r->T,<T2d2=q->T2d,<T1=p->T); */
   79|   611k|   fe_mul(r->T, q->T2d, p->T);
   80|       |
   81|       |   /* qhasm: ZZ = Z1*Z2 */
   82|       |   /* asm 1: fe_mul(>ZZ=fe#1,<Z1=fe#13,<Z2=fe#17); */
   83|       |   /* asm 2: fe_mul(>ZZ=r->X,<Z1=p->Z,<Z2=q->Z); */
   84|   611k|   fe_mul(r->X, p->Z, q->Z);
   85|       |
   86|       |   /* qhasm: D = 2*ZZ */
   87|       |   /* asm 1: fe_add(>D=fe#5,<ZZ=fe#1,<ZZ=fe#1); */
   88|       |   /* asm 2: fe_add(>D=t0,<ZZ=r->X,<ZZ=r->X); */
   89|   611k|   fe_add(t0, r->X, r->X);
   90|       |
   91|       |   /* qhasm: X3 = A-B */
   92|       |   /* asm 1: fe_sub(>X3=fe#1,<A=fe#3,<B=fe#2); */
   93|       |   /* asm 2: fe_sub(>X3=r->X,<A=r->Z,<B=r->Y); */
   94|   611k|   fe_sub(r->X, r->Z, r->Y);
   95|       |
   96|       |   /* qhasm: Y3 = A+B */
   97|       |   /* asm 1: fe_add(>Y3=fe#2,<A=fe#3,<B=fe#2); */
   98|       |   /* asm 2: fe_add(>Y3=r->Y,<A=r->Z,<B=r->Y); */
   99|   611k|   fe_add(r->Y, r->Z, r->Y);
  100|       |
  101|       |   /* qhasm: Z3 = D+C */
  102|       |   /* asm 1: fe_add(>Z3=fe#3,<D=fe#5,<C=fe#4); */
  103|       |   /* asm 2: fe_add(>Z3=r->Z,<D=t0,<C=r->T); */
  104|   611k|   fe_add(r->Z, t0, r->T);
  105|       |
  106|       |   /* qhasm: T3 = D-C */
  107|       |   /* asm 1: fe_sub(>T3=fe#4,<D=fe#5,<C=fe#4); */
  108|       |   /* asm 2: fe_sub(>T3=r->T,<D=t0,<C=r->T); */
  109|   611k|   fe_sub(r->T, t0, r->T);
  110|   611k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_17ge_p2_0EPNS0_5ge_p2E:
  417|  26.2k|void ge_p2_0(ge_p2* h) {
  418|  26.2k|   fe_0(h->X);
  419|  26.2k|   fe_1(h->Y);
  420|  26.2k|   fe_1(h->Z);
  421|  26.2k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_19ge_p2_dblEPNS0_7ge_p1p1EPKNS0_5ge_p2E:
  232|  6.75M|void ge_p2_dbl(ge_p1p1* r, const ge_p2* p) {
  233|  6.75M|   FE_25519 t0;
  234|       |   /* qhasm: XX=X1^2 */
  235|       |   /* asm 1: fe_sq(>XX=fe#1,<X1=fe#11); */
  236|       |   /* asm 2: fe_sq(>XX=r->X,<X1=p->X); */
  237|  6.75M|   fe_sq(r->X, p->X);
  238|       |
  239|       |   /* qhasm: YY=Y1^2 */
  240|       |   /* asm 1: fe_sq(>YY=fe#3,<Y1=fe#12); */
  241|       |   /* asm 2: fe_sq(>YY=r->Z,<Y1=p->Y); */
  242|  6.75M|   fe_sq(r->Z, p->Y);
  243|       |
  244|       |   /* qhasm: B=2*Z1^2 */
  245|       |   /* asm 1: fe_sq2(>B=fe#4,<Z1=fe#13); */
  246|       |   /* asm 2: fe_sq2(>B=r->T,<Z1=p->Z); */
  247|  6.75M|   fe_sq2(r->T, p->Z);
  248|       |
  249|       |   /* qhasm: A=X1+Y1 */
  250|       |   /* asm 1: fe_add(>A=fe#2,<X1=fe#11,<Y1=fe#12); */
  251|       |   /* asm 2: fe_add(>A=r->Y,<X1=p->X,<Y1=p->Y); */
  252|  6.75M|   fe_add(r->Y, p->X, p->Y);
  253|       |
  254|       |   /* qhasm: AA=A^2 */
  255|       |   /* asm 1: fe_sq(>AA=fe#5,<A=fe#2); */
  256|       |   /* asm 2: fe_sq(>AA=t0,<A=r->Y); */
  257|  6.75M|   fe_sq(t0, r->Y);
  258|       |
  259|       |   /* qhasm: Y3=YY+XX */
  260|       |   /* asm 1: fe_add(>Y3=fe#2,<YY=fe#3,<XX=fe#1); */
  261|       |   /* asm 2: fe_add(>Y3=r->Y,<YY=r->Z,<XX=r->X); */
  262|  6.75M|   fe_add(r->Y, r->Z, r->X);
  263|       |
  264|       |   /* qhasm: Z3=YY-XX */
  265|       |   /* asm 1: fe_sub(>Z3=fe#3,<YY=fe#3,<XX=fe#1); */
  266|       |   /* asm 2: fe_sub(>Z3=r->Z,<YY=r->Z,<XX=r->X); */
  267|  6.75M|   fe_sub(r->Z, r->Z, r->X);
  268|       |
  269|       |   /* qhasm: X3=AA-Y3 */
  270|       |   /* asm 1: fe_sub(>X3=fe#1,<AA=fe#5,<Y3=fe#2); */
  271|       |   /* asm 2: fe_sub(>X3=r->X,<AA=t0,<Y3=r->Y); */
  272|  6.75M|   fe_sub(r->X, t0, r->Y);
  273|       |
  274|       |   /* qhasm: T3=B-Z3 */
  275|       |   /* asm 1: fe_sub(>T3=fe#4,<B=fe#4,<Z3=fe#3); */
  276|       |   /* asm 2: fe_sub(>T3=r->T,<B=r->T,<Z3=r->Z); */
  277|  6.75M|   fe_sub(r->T, r->T, r->Z);
  278|  6.75M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_16ge_subEPNS0_7ge_p1p1EPKNS_5ge_p3EPKNS0_9ge_cachedE:
  317|   430k|void ge_sub(ge_p1p1* r, const ge_p3* p, const ge_cached* q) {
  318|   430k|   FE_25519 t0;
  319|       |   /* qhasm: YpX1 = Y1+X1 */
  320|       |   /* asm 1: fe_add(>YpX1=fe#1,<Y1=fe#12,<X1=fe#11); */
  321|       |   /* asm 2: fe_add(>YpX1=r->X,<Y1=p->Y,<X1=p->X); */
  322|   430k|   fe_add(r->X, p->Y, p->X);
  323|       |
  324|       |   /* qhasm: YmX1 = Y1-X1 */
  325|       |   /* asm 1: fe_sub(>YmX1=fe#2,<Y1=fe#12,<X1=fe#11); */
  326|       |   /* asm 2: fe_sub(>YmX1=r->Y,<Y1=p->Y,<X1=p->X); */
  327|   430k|   fe_sub(r->Y, p->Y, p->X);
  328|       |
  329|       |   /* qhasm: A = YpX1*YmX2 */
  330|       |   /* asm 1: fe_mul(>A=fe#3,<YpX1=fe#1,<YmX2=fe#16); */
  331|       |   /* asm 2: fe_mul(>A=r->Z,<YpX1=r->X,<YmX2=q->YminusX); */
  332|   430k|   fe_mul(r->Z, r->X, q->YminusX);
  333|       |
  334|       |   /* qhasm: B = YmX1*YpX2 */
  335|       |   /* asm 1: fe_mul(>B=fe#2,<YmX1=fe#2,<YpX2=fe#15); */
  336|       |   /* asm 2: fe_mul(>B=r->Y,<YmX1=r->Y,<YpX2=q->YplusX); */
  337|   430k|   fe_mul(r->Y, r->Y, q->YplusX);
  338|       |
  339|       |   /* qhasm: C = T2d2*T1 */
  340|       |   /* asm 1: fe_mul(>C=fe#4,<T2d2=fe#18,<T1=fe#14); */
  341|       |   /* asm 2: fe_mul(>C=r->T,<T2d2=q->T2d,<T1=p->T); */
  342|   430k|   fe_mul(r->T, q->T2d, p->T);
  343|       |
  344|       |   /* qhasm: ZZ = Z1*Z2 */
  345|       |   /* asm 1: fe_mul(>ZZ=fe#1,<Z1=fe#13,<Z2=fe#17); */
  346|       |   /* asm 2: fe_mul(>ZZ=r->X,<Z1=p->Z,<Z2=q->Z); */
  347|   430k|   fe_mul(r->X, p->Z, q->Z);
  348|       |
  349|       |   /* qhasm: D = 2*ZZ */
  350|       |   /* asm 1: fe_add(>D=fe#5,<ZZ=fe#1,<ZZ=fe#1); */
  351|       |   /* asm 2: fe_add(>D=t0,<ZZ=r->X,<ZZ=r->X); */
  352|   430k|   fe_add(t0, r->X, r->X);
  353|       |
  354|       |   /* qhasm: X3 = A-B */
  355|       |   /* asm 1: fe_sub(>X3=fe#1,<A=fe#3,<B=fe#2); */
  356|       |   /* asm 2: fe_sub(>X3=r->X,<A=r->Z,<B=r->Y); */
  357|   430k|   fe_sub(r->X, r->Z, r->Y);
  358|       |
  359|       |   /* qhasm: Y3 = A+B */
  360|       |   /* asm 1: fe_add(>Y3=fe#2,<A=fe#3,<B=fe#2); */
  361|       |   /* asm 2: fe_add(>Y3=r->Y,<A=r->Z,<B=r->Y); */
  362|   430k|   fe_add(r->Y, r->Z, r->Y);
  363|       |
  364|       |   /* qhasm: Z3 = D-C */
  365|       |   /* asm 1: fe_sub(>Z3=fe#3,<D=fe#5,<C=fe#4); */
  366|       |   /* asm 2: fe_sub(>Z3=r->Z,<D=t0,<C=r->T); */
  367|   430k|   fe_sub(r->Z, t0, r->T);
  368|       |
  369|       |   /* qhasm: T3 = D+C */
  370|       |   /* asm 1: fe_add(>T3=fe#4,<D=fe#5,<C=fe#4); */
  371|       |   /* asm 2: fe_add(>T3=r->T,<D=t0,<C=r->T); */
  372|   430k|   fe_add(r->T, t0, r->T);
  373|   430k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_17ge_maddEPNS0_7ge_p1p1EPKNS_5ge_p3EPKNS0_10ge_precompE:
  116|  1.96M|void ge_madd(ge_p1p1* r, const ge_p3* p, const ge_precomp* q) {
  117|  1.96M|   FE_25519 t0;
  118|       |   /* qhasm: YpX1 = Y1+X1 */
  119|  1.96M|   fe_add(r->X, p->Y, p->X);
  120|       |
  121|       |   /* qhasm: YmX1 = Y1-X1 */
  122|  1.96M|   fe_sub(r->Y, p->Y, p->X);
  123|       |
  124|       |   /* qhasm: A = YpX1*ypx2 */
  125|  1.96M|   fe_mul(r->Z, r->X, q->yplusx);
  126|       |
  127|       |   /* qhasm: B = YmX1*ymx2 */
  128|  1.96M|   fe_mul(r->Y, r->Y, q->yminusx);
  129|       |
  130|       |   /* qhasm: C = xy2d2*T1 */
  131|  1.96M|   fe_mul(r->T, q->xy2d, p->T);
  132|       |
  133|       |   /* qhasm: D = 2*Z1 */
  134|  1.96M|   fe_add(t0, p->Z, p->Z);
  135|       |
  136|       |   /* qhasm: X3 = A-B */
  137|  1.96M|   fe_sub(r->X, r->Z, r->Y);
  138|       |
  139|       |   /* qhasm: Y3 = A+B */
  140|  1.96M|   fe_add(r->Y, r->Z, r->Y);
  141|       |
  142|       |   /* qhasm: Z3 = D+C */
  143|  1.96M|   fe_add(r->Z, t0, r->T);
  144|       |
  145|       |   /* qhasm: T3 = D-C */
  146|  1.96M|   fe_sub(r->T, t0, r->T);
  147|  1.96M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_17ge_msubEPNS0_7ge_p1p1EPKNS_5ge_p3EPKNS0_10ge_precompE:
  153|   272k|void ge_msub(ge_p1p1* r, const ge_p3* p, const ge_precomp* q) {
  154|   272k|   FE_25519 t0;
  155|       |
  156|       |   /* qhasm: YpX1 = Y1+X1 */
  157|       |   /* asm 1: fe_add(>YpX1=fe#1,<Y1=fe#12,<X1=fe#11); */
  158|       |   /* asm 2: fe_add(>YpX1=r->X,<Y1=p->Y,<X1=p->X); */
  159|   272k|   fe_add(r->X, p->Y, p->X);
  160|       |
  161|       |   /* qhasm: YmX1 = Y1-X1 */
  162|       |   /* asm 1: fe_sub(>YmX1=fe#2,<Y1=fe#12,<X1=fe#11); */
  163|       |   /* asm 2: fe_sub(>YmX1=r->Y,<Y1=p->Y,<X1=p->X); */
  164|   272k|   fe_sub(r->Y, p->Y, p->X);
  165|       |
  166|       |   /* qhasm: A = YpX1*ymx2 */
  167|       |   /* asm 1: fe_mul(>A=fe#3,<YpX1=fe#1,<ymx2=fe#16); */
  168|       |   /* asm 2: fe_mul(>A=r->Z,<YpX1=r->X,<ymx2=q->yminusx); */
  169|   272k|   fe_mul(r->Z, r->X, q->yminusx);
  170|       |
  171|       |   /* qhasm: B = YmX1*ypx2 */
  172|       |   /* asm 1: fe_mul(>B=fe#2,<YmX1=fe#2,<ypx2=fe#15); */
  173|       |   /* asm 2: fe_mul(>B=r->Y,<YmX1=r->Y,<ypx2=q->yplusx); */
  174|   272k|   fe_mul(r->Y, r->Y, q->yplusx);
  175|       |
  176|       |   /* qhasm: C = xy2d2*T1 */
  177|       |   /* asm 1: fe_mul(>C=fe#4,<xy2d2=fe#17,<T1=fe#14); */
  178|       |   /* asm 2: fe_mul(>C=r->T,<xy2d2=q->xy2d,<T1=p->T); */
  179|   272k|   fe_mul(r->T, q->xy2d, p->T);
  180|       |
  181|       |   /* qhasm: D = 2*Z1 */
  182|       |   /* asm 1: fe_add(>D=fe#5,<Z1=fe#13,<Z1=fe#13); */
  183|       |   /* asm 2: fe_add(>D=t0,<Z1=p->Z,<Z1=p->Z); */
  184|   272k|   fe_add(t0, p->Z, p->Z);
  185|       |
  186|       |   /* qhasm: X3 = A-B */
  187|       |   /* asm 1: fe_sub(>X3=fe#1,<A=fe#3,<B=fe#2); */
  188|       |   /* asm 2: fe_sub(>X3=r->X,<A=r->Z,<B=r->Y); */
  189|   272k|   fe_sub(r->X, r->Z, r->Y);
  190|       |
  191|       |   /* qhasm: Y3 = A+B */
  192|       |   /* asm 1: fe_add(>Y3=fe#2,<A=fe#3,<B=fe#2); */
  193|       |   /* asm 2: fe_add(>Y3=r->Y,<A=r->Z,<B=r->Y); */
  194|   272k|   fe_add(r->Y, r->Z, r->Y);
  195|       |
  196|       |   /* qhasm: Z3 = D-C */
  197|       |   /* asm 1: fe_sub(>Z3=fe#3,<D=fe#5,<C=fe#4); */
  198|       |   /* asm 2: fe_sub(>Z3=r->Z,<D=t0,<C=r->T); */
  199|   272k|   fe_sub(r->Z, t0, r->T);
  200|       |
  201|       |   /* qhasm: T3 = D+C */
  202|       |   /* asm 1: fe_add(>T3=fe#4,<D=fe#5,<C=fe#4); */
  203|       |   /* asm 2: fe_add(>T3=r->T,<D=t0,<C=r->T); */
  204|   272k|   fe_add(r->T, t0, r->T);
  205|   272k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_113ge_p1p1_to_p2EPNS0_5ge_p2EPKNS0_7ge_p1p1E:
  211|  6.69M|void ge_p1p1_to_p2(ge_p2* r, const ge_p1p1* p) {
  212|  6.69M|   fe_mul(r->X, p->X, p->T);
  213|  6.69M|   fe_mul(r->Y, p->Y, p->Z);
  214|  6.69M|   fe_mul(r->Z, p->Z, p->T);
  215|  6.69M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_110ge_tobytesEPhPKNS0_5ge_p2E:
  405|  26.2k|void ge_tobytes(uint8_t* s, const ge_p2* h) {
  406|  26.2k|   FE_25519 recip;
  407|  26.2k|   FE_25519 x;
  408|  26.2k|   FE_25519 y;
  409|       |
  410|  26.2k|   fe_invert(recip, h->Z);
  411|  26.2k|   fe_mul(x, h->X, recip);
  412|  26.2k|   fe_mul(y, h->Y, recip);
  413|  26.2k|   fe_tobytes(s, y);
  414|  26.2k|   s[31] ^= fe_isnegative(x) << 7;
  415|  26.2k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_17ge_p3_0EPNS_5ge_p3E:
  280|  26.2k|void ge_p3_0(ge_p3* h) {
  281|  26.2k|   fe_0(h->X);
  282|  26.2k|   fe_1(h->Y);
  283|  26.2k|   fe_1(h->Z);
  284|  26.2k|   fe_0(h->T);
  285|  26.2k|}
ge.cpp:_ZN5Botan12_GLOBAL__N_16selectEPNS0_10ge_precompEPKS1_a:
 1971|  1.67M|inline void select(ge_precomp* t, const ge_precomp* base, int8_t b) {
 1972|  1.67M|   const uint8_t bnegative = negative(b);
 1973|  1.67M|   const uint8_t babs = b - ((-static_cast<int>(bnegative) & b) * 2);
 1974|  1.67M|   const int32_t neg_mask = equal32(bnegative, 1);
 1975|       |
 1976|  1.67M|   const int32_t mask1 = equal32(babs, 1);
 1977|  1.67M|   const int32_t mask2 = equal32(babs, 2);
 1978|  1.67M|   const int32_t mask3 = equal32(babs, 3);
 1979|  1.67M|   const int32_t mask4 = equal32(babs, 4);
 1980|  1.67M|   const int32_t mask5 = equal32(babs, 5);
 1981|  1.67M|   const int32_t mask6 = equal32(babs, 6);
 1982|  1.67M|   const int32_t mask7 = equal32(babs, 7);
 1983|  1.67M|   const int32_t mask8 = equal32(babs, 8);
 1984|       |
 1985|  1.67M|   ge_precomp_0(t);
 1986|       |
 1987|  18.4M|   for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (1987:22): [True: 16.7M, False: 1.67M]
  ------------------
 1988|  16.7M|      t->yplusx[i] = t->yplusx[i] ^ ((t->yplusx[i] ^ base[0].yplusx[i]) & mask1) ^
 1989|  16.7M|                     ((t->yplusx[i] ^ base[1].yplusx[i]) & mask2) ^ ((t->yplusx[i] ^ base[2].yplusx[i]) & mask3) ^
 1990|  16.7M|                     ((t->yplusx[i] ^ base[3].yplusx[i]) & mask4) ^ ((t->yplusx[i] ^ base[4].yplusx[i]) & mask5) ^
 1991|  16.7M|                     ((t->yplusx[i] ^ base[5].yplusx[i]) & mask6) ^ ((t->yplusx[i] ^ base[6].yplusx[i]) & mask7) ^
 1992|  16.7M|                     ((t->yplusx[i] ^ base[7].yplusx[i]) & mask8);
 1993|       |
 1994|  16.7M|      t->yminusx[i] = t->yminusx[i] ^ ((t->yminusx[i] ^ base[0].yminusx[i]) & mask1) ^
 1995|  16.7M|                      ((t->yminusx[i] ^ base[1].yminusx[i]) & mask2) ^ ((t->yminusx[i] ^ base[2].yminusx[i]) & mask3) ^
 1996|  16.7M|                      ((t->yminusx[i] ^ base[3].yminusx[i]) & mask4) ^ ((t->yminusx[i] ^ base[4].yminusx[i]) & mask5) ^
 1997|  16.7M|                      ((t->yminusx[i] ^ base[5].yminusx[i]) & mask6) ^ ((t->yminusx[i] ^ base[6].yminusx[i]) & mask7) ^
 1998|  16.7M|                      ((t->yminusx[i] ^ base[7].yminusx[i]) & mask8);
 1999|       |
 2000|  16.7M|      t->xy2d[i] = t->xy2d[i] ^ ((t->xy2d[i] ^ base[0].xy2d[i]) & mask1) ^ ((t->xy2d[i] ^ base[1].xy2d[i]) & mask2) ^
 2001|  16.7M|                   ((t->xy2d[i] ^ base[2].xy2d[i]) & mask3) ^ ((t->xy2d[i] ^ base[3].xy2d[i]) & mask4) ^
 2002|  16.7M|                   ((t->xy2d[i] ^ base[4].xy2d[i]) & mask5) ^ ((t->xy2d[i] ^ base[5].xy2d[i]) & mask6) ^
 2003|  16.7M|                   ((t->xy2d[i] ^ base[6].xy2d[i]) & mask7) ^ ((t->xy2d[i] ^ base[7].xy2d[i]) & mask8);
 2004|  16.7M|   }
 2005|       |
 2006|  1.67M|   FE_25519 minus_xy2d;
 2007|  1.67M|   fe_neg(minus_xy2d, t->xy2d);
 2008|       |
 2009|       |   // If negative have to swap yminusx and yplusx
 2010|  18.4M|   for(size_t i = 0; i != 10; ++i) {
  ------------------
  |  Branch (2010:22): [True: 16.7M, False: 1.67M]
  ------------------
 2011|  16.7M|      int32_t t_yplusx = t->yplusx[i] ^ ((t->yplusx[i] ^ t->yminusx[i]) & neg_mask);
 2012|  16.7M|      int32_t t_yminusx = t->yminusx[i] ^ ((t->yminusx[i] ^ t->yplusx[i]) & neg_mask);
 2013|       |
 2014|  16.7M|      t->yplusx[i] = t_yplusx;
 2015|  16.7M|      t->yminusx[i] = t_yminusx;
 2016|  16.7M|      t->xy2d[i] = t->xy2d[i] ^ ((t->xy2d[i] ^ minus_xy2d[i]) & neg_mask);
 2017|  16.7M|   }
 2018|  1.67M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_18negativeEa:
 1958|  1.67M|inline uint8_t negative(int8_t b) {
 1959|       |   /* 18446744073709551361..18446744073709551615: yes; 0..255: no */
 1960|  1.67M|   uint64_t x = b;  // NOLINT(bugprone-signed-char-misuse,cert-str34-c)
 1961|  1.67M|   x >>= 63;        /* 1: yes; 0: no */
 1962|  1.67M|   return static_cast<uint8_t>(x);
 1963|  1.67M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_17equal32Eaa:
 1954|  15.1M|inline int32_t equal32(int8_t b, int8_t c) {
 1955|  15.1M|   return -static_cast<int32_t>(equal(b, c));
 1956|  15.1M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_15equalEaa:
 1944|  15.1M|inline uint8_t equal(int8_t b, int8_t c) {
 1945|  15.1M|   uint8_t ub = b;
 1946|  15.1M|   uint8_t uc = c;
 1947|  15.1M|   uint8_t x = ub ^ uc; /* 0: yes; 1..255: no */
 1948|  15.1M|   uint32_t y = x;      /* 0: yes; 1..255: no */
 1949|  15.1M|   y -= 1;              /* 4294967295: yes; 0..254: no */
 1950|  15.1M|   y >>= 31;            /* 1: yes; 0: no */
 1951|  15.1M|   return static_cast<uint8_t>(y);
 1952|  15.1M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_112ge_precomp_0EPNS0_10ge_precompE:
 1965|  1.67M|inline void ge_precomp_0(ge_precomp* h) {
 1966|  1.67M|   fe_1(h->yplusx);
 1967|  1.67M|   fe_1(h->yminusx);
 1968|  1.67M|   fe_0(h->xy2d);
 1969|  1.67M|}
ge.cpp:_ZN5Botan12_GLOBAL__N_113ge_p3_tobytesEPhPKNS_5ge_p3E:
 2020|  26.2k|void ge_p3_tobytes(uint8_t* s, const ge_p3* h) {
 2021|  26.2k|   FE_25519 recip;
 2022|  26.2k|   FE_25519 x;
 2023|  26.2k|   FE_25519 y;
 2024|       |
 2025|  26.2k|   fe_invert(recip, h->Z);
 2026|  26.2k|   fe_mul(x, h->X, recip);
 2027|  26.2k|   fe_mul(y, h->Y, recip);
 2028|  26.2k|   fe_tobytes(s, y);
 2029|  26.2k|   s[31] ^= fe_isnegative(x) << 7;
 2030|  26.2k|}

_ZN5Botan9sc_muladdEPhPKhS2_S2_:
   26|  13.1k|void sc_muladd(uint8_t* s, const uint8_t* a, const uint8_t* b, const uint8_t* c) {
   27|  13.1k|   const int32_t MASK = 0x1fffff;
   28|       |
   29|  13.1k|   const int64_t a0 = MASK & load_3(a);
   30|  13.1k|   const int64_t a1 = MASK & (load_4(a + 2) >> 5);
   31|  13.1k|   const int64_t a2 = MASK & (load_3(a + 5) >> 2);
   32|  13.1k|   const int64_t a3 = MASK & (load_4(a + 7) >> 7);
   33|  13.1k|   const int64_t a4 = MASK & (load_4(a + 10) >> 4);
   34|  13.1k|   const int64_t a5 = MASK & (load_3(a + 13) >> 1);
   35|  13.1k|   const int64_t a6 = MASK & (load_4(a + 15) >> 6);
   36|  13.1k|   const int64_t a7 = MASK & (load_3(a + 18) >> 3);
   37|  13.1k|   const int64_t a8 = MASK & load_3(a + 21);
   38|  13.1k|   const int64_t a9 = MASK & (load_4(a + 23) >> 5);
   39|  13.1k|   const int64_t a10 = MASK & (load_3(a + 26) >> 2);
   40|  13.1k|   const int64_t a11 = (load_4(a + 28) >> 7);
   41|  13.1k|   const int64_t b0 = MASK & load_3(b);
   42|  13.1k|   const int64_t b1 = MASK & (load_4(b + 2) >> 5);
   43|  13.1k|   const int64_t b2 = MASK & (load_3(b + 5) >> 2);
   44|  13.1k|   const int64_t b3 = MASK & (load_4(b + 7) >> 7);
   45|  13.1k|   const int64_t b4 = MASK & (load_4(b + 10) >> 4);
   46|  13.1k|   const int64_t b5 = MASK & (load_3(b + 13) >> 1);
   47|  13.1k|   const int64_t b6 = MASK & (load_4(b + 15) >> 6);
   48|  13.1k|   const int64_t b7 = MASK & (load_3(b + 18) >> 3);
   49|  13.1k|   const int64_t b8 = MASK & load_3(b + 21);
   50|  13.1k|   const int64_t b9 = MASK & (load_4(b + 23) >> 5);
   51|  13.1k|   const int64_t b10 = MASK & (load_3(b + 26) >> 2);
   52|  13.1k|   const int64_t b11 = (load_4(b + 28) >> 7);
   53|  13.1k|   const int64_t c0 = MASK & load_3(c);
   54|  13.1k|   const int64_t c1 = MASK & (load_4(c + 2) >> 5);
   55|  13.1k|   const int64_t c2 = MASK & (load_3(c + 5) >> 2);
   56|  13.1k|   const int64_t c3 = MASK & (load_4(c + 7) >> 7);
   57|  13.1k|   const int64_t c4 = MASK & (load_4(c + 10) >> 4);
   58|  13.1k|   const int64_t c5 = MASK & (load_3(c + 13) >> 1);
   59|  13.1k|   const int64_t c6 = MASK & (load_4(c + 15) >> 6);
   60|  13.1k|   const int64_t c7 = MASK & (load_3(c + 18) >> 3);
   61|  13.1k|   const int64_t c8 = MASK & load_3(c + 21);
   62|  13.1k|   const int64_t c9 = MASK & (load_4(c + 23) >> 5);
   63|  13.1k|   const int64_t c10 = MASK & (load_3(c + 26) >> 2);
   64|  13.1k|   const int64_t c11 = (load_4(c + 28) >> 7);
   65|       |
   66|  13.1k|   int64_t s0 = c0 + a0 * b0;
   67|  13.1k|   int64_t s1 = c1 + a0 * b1 + a1 * b0;
   68|  13.1k|   int64_t s2 = c2 + a0 * b2 + a1 * b1 + a2 * b0;
   69|  13.1k|   int64_t s3 = c3 + a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;
   70|  13.1k|   int64_t s4 = c4 + a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;
   71|  13.1k|   int64_t s5 = c5 + a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;
   72|  13.1k|   int64_t s6 = c6 + a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;
   73|  13.1k|   int64_t s7 = c7 + a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 + a6 * b1 + a7 * b0;
   74|  13.1k|   int64_t s8 = c8 + a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 + a6 * b2 + a7 * b1 + a8 * b0;
   75|  13.1k|   int64_t s9 = c9 + a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 + a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;
   76|  13.1k|   int64_t s10 = c10 + a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 + a6 * b4 + a7 * b3 + a8 * b2 +
   77|  13.1k|                 a9 * b1 + a10 * b0;
   78|  13.1k|   int64_t s11 = c11 + a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 + a6 * b5 + a7 * b4 + a8 * b3 +
   79|  13.1k|                 a9 * b2 + a10 * b1 + a11 * b0;
   80|  13.1k|   int64_t s12 =
   81|  13.1k|      a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 + a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;
   82|  13.1k|   int64_t s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 + a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;
   83|  13.1k|   int64_t s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 + a9 * b5 + a10 * b4 + a11 * b3;
   84|  13.1k|   int64_t s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 + a10 * b5 + a11 * b4;
   85|  13.1k|   int64_t s16 = a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;
   86|  13.1k|   int64_t s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;
   87|  13.1k|   int64_t s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;
   88|  13.1k|   int64_t s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;
   89|  13.1k|   int64_t s20 = a9 * b11 + a10 * b10 + a11 * b9;
   90|  13.1k|   int64_t s21 = a10 * b11 + a11 * b10;
   91|  13.1k|   int64_t s22 = a11 * b11;
   92|  13.1k|   int64_t s23 = 0;
   93|       |
   94|  13.1k|   carry<21>(s0, s1);
   95|  13.1k|   carry<21>(s2, s3);
   96|  13.1k|   carry<21>(s4, s5);
   97|  13.1k|   carry<21>(s6, s7);
   98|  13.1k|   carry<21>(s8, s9);
   99|  13.1k|   carry<21>(s10, s11);
  100|  13.1k|   carry<21>(s12, s13);
  101|  13.1k|   carry<21>(s14, s15);
  102|  13.1k|   carry<21>(s16, s17);
  103|  13.1k|   carry<21>(s18, s19);
  104|  13.1k|   carry<21>(s20, s21);
  105|  13.1k|   carry<21>(s22, s23);
  106|       |
  107|  13.1k|   carry<21>(s1, s2);
  108|  13.1k|   carry<21>(s3, s4);
  109|  13.1k|   carry<21>(s5, s6);
  110|  13.1k|   carry<21>(s7, s8);
  111|  13.1k|   carry<21>(s9, s10);
  112|  13.1k|   carry<21>(s11, s12);
  113|  13.1k|   carry<21>(s13, s14);
  114|  13.1k|   carry<21>(s15, s16);
  115|  13.1k|   carry<21>(s17, s18);
  116|  13.1k|   carry<21>(s19, s20);
  117|  13.1k|   carry<21>(s21, s22);
  118|       |
  119|  13.1k|   redc_mul(s11, s12, s13, s14, s15, s16, s23);
  120|  13.1k|   redc_mul(s10, s11, s12, s13, s14, s15, s22);
  121|  13.1k|   redc_mul(s9, s10, s11, s12, s13, s14, s21);
  122|  13.1k|   redc_mul(s8, s9, s10, s11, s12, s13, s20);
  123|  13.1k|   redc_mul(s7, s8, s9, s10, s11, s12, s19);
  124|  13.1k|   redc_mul(s6, s7, s8, s9, s10, s11, s18);
  125|       |
  126|  13.1k|   carry<21>(s6, s7);
  127|  13.1k|   carry<21>(s8, s9);
  128|  13.1k|   carry<21>(s10, s11);
  129|  13.1k|   carry<21>(s12, s13);
  130|  13.1k|   carry<21>(s14, s15);
  131|  13.1k|   carry<21>(s16, s17);
  132|       |
  133|  13.1k|   carry<21>(s7, s8);
  134|  13.1k|   carry<21>(s9, s10);
  135|  13.1k|   carry<21>(s11, s12);
  136|  13.1k|   carry<21>(s13, s14);
  137|  13.1k|   carry<21>(s15, s16);
  138|       |
  139|  13.1k|   redc_mul(s5, s6, s7, s8, s9, s10, s17);
  140|  13.1k|   redc_mul(s4, s5, s6, s7, s8, s9, s16);
  141|  13.1k|   redc_mul(s3, s4, s5, s6, s7, s8, s15);
  142|  13.1k|   redc_mul(s2, s3, s4, s5, s6, s7, s14);
  143|  13.1k|   redc_mul(s1, s2, s3, s4, s5, s6, s13);
  144|  13.1k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  145|       |
  146|  13.1k|   carry<21>(s0, s1);
  147|  13.1k|   carry<21>(s2, s3);
  148|  13.1k|   carry<21>(s4, s5);
  149|  13.1k|   carry<21>(s6, s7);
  150|  13.1k|   carry<21>(s8, s9);
  151|  13.1k|   carry<21>(s10, s11);
  152|       |
  153|  13.1k|   carry<21>(s1, s2);
  154|  13.1k|   carry<21>(s3, s4);
  155|  13.1k|   carry<21>(s5, s6);
  156|  13.1k|   carry<21>(s7, s8);
  157|  13.1k|   carry<21>(s9, s10);
  158|  13.1k|   carry<21>(s11, s12);
  159|       |
  160|  13.1k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  161|       |
  162|  13.1k|   carry0<21>(s0, s1);
  163|  13.1k|   carry0<21>(s1, s2);
  164|  13.1k|   carry0<21>(s2, s3);
  165|  13.1k|   carry0<21>(s3, s4);
  166|  13.1k|   carry0<21>(s4, s5);
  167|  13.1k|   carry0<21>(s5, s6);
  168|  13.1k|   carry0<21>(s6, s7);
  169|  13.1k|   carry0<21>(s7, s8);
  170|  13.1k|   carry0<21>(s8, s9);
  171|  13.1k|   carry0<21>(s9, s10);
  172|  13.1k|   carry0<21>(s10, s11);
  173|  13.1k|   carry0<21>(s11, s12);
  174|       |
  175|  13.1k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  176|       |
  177|  13.1k|   carry0<21>(s0, s1);
  178|  13.1k|   carry0<21>(s1, s2);
  179|  13.1k|   carry0<21>(s2, s3);
  180|  13.1k|   carry0<21>(s3, s4);
  181|  13.1k|   carry0<21>(s4, s5);
  182|  13.1k|   carry0<21>(s5, s6);
  183|  13.1k|   carry0<21>(s6, s7);
  184|  13.1k|   carry0<21>(s7, s8);
  185|  13.1k|   carry0<21>(s8, s9);
  186|  13.1k|   carry0<21>(s9, s10);
  187|  13.1k|   carry0<21>(s10, s11);
  188|       |
  189|  13.1k|   s[0] = static_cast<uint8_t>(s0 >> 0);
  190|  13.1k|   s[1] = static_cast<uint8_t>(s0 >> 8);
  191|  13.1k|   s[2] = static_cast<uint8_t>((s0 >> 16) | (s1 << 5));
  192|  13.1k|   s[3] = static_cast<uint8_t>(s1 >> 3);
  193|  13.1k|   s[4] = static_cast<uint8_t>(s1 >> 11);
  194|  13.1k|   s[5] = static_cast<uint8_t>((s1 >> 19) | (s2 << 2));
  195|  13.1k|   s[6] = static_cast<uint8_t>(s2 >> 6);
  196|  13.1k|   s[7] = static_cast<uint8_t>((s2 >> 14) | (s3 << 7));
  197|  13.1k|   s[8] = static_cast<uint8_t>(s3 >> 1);
  198|  13.1k|   s[9] = static_cast<uint8_t>(s3 >> 9);
  199|  13.1k|   s[10] = static_cast<uint8_t>((s3 >> 17) | (s4 << 4));
  200|  13.1k|   s[11] = static_cast<uint8_t>(s4 >> 4);
  201|  13.1k|   s[12] = static_cast<uint8_t>(s4 >> 12);
  202|  13.1k|   s[13] = static_cast<uint8_t>((s4 >> 20) | (s5 << 1));
  203|  13.1k|   s[14] = static_cast<uint8_t>(s5 >> 7);
  204|  13.1k|   s[15] = static_cast<uint8_t>((s5 >> 15) | (s6 << 6));
  205|  13.1k|   s[16] = static_cast<uint8_t>(s6 >> 2);
  206|  13.1k|   s[17] = static_cast<uint8_t>(s6 >> 10);
  207|  13.1k|   s[18] = static_cast<uint8_t>((s6 >> 18) | (s7 << 3));
  208|  13.1k|   s[19] = static_cast<uint8_t>(s7 >> 5);
  209|  13.1k|   s[20] = static_cast<uint8_t>(s7 >> 13);
  210|  13.1k|   s[21] = static_cast<uint8_t>(s8 >> 0);
  211|  13.1k|   s[22] = static_cast<uint8_t>(s8 >> 8);
  212|  13.1k|   s[23] = static_cast<uint8_t>((s8 >> 16) | (s9 << 5));
  213|  13.1k|   s[24] = static_cast<uint8_t>(s9 >> 3);
  214|  13.1k|   s[25] = static_cast<uint8_t>(s9 >> 11);
  215|  13.1k|   s[26] = static_cast<uint8_t>((s9 >> 19) | (s10 << 2));
  216|  13.1k|   s[27] = static_cast<uint8_t>(s10 >> 6);
  217|  13.1k|   s[28] = static_cast<uint8_t>((s10 >> 14) | (s11 << 7));
  218|  13.1k|   s[29] = static_cast<uint8_t>(s11 >> 1);
  219|  13.1k|   s[30] = static_cast<uint8_t>(s11 >> 9);
  220|  13.1k|   s[31] = static_cast<uint8_t>(s11 >> 17);
  221|  13.1k|}

_ZN5Botan9sc_reduceEPh:
   25|  39.3k|void sc_reduce(uint8_t* s) {
   26|  39.3k|   const uint32_t MASK = 0x1fffff;
   27|       |
   28|  39.3k|   int64_t s0 = MASK & load_3(s);
   29|  39.3k|   int64_t s1 = MASK & (load_4(s + 2) >> 5);
   30|  39.3k|   int64_t s2 = MASK & (load_3(s + 5) >> 2);
   31|  39.3k|   int64_t s3 = MASK & (load_4(s + 7) >> 7);
   32|  39.3k|   int64_t s4 = MASK & (load_4(s + 10) >> 4);
   33|  39.3k|   int64_t s5 = MASK & (load_3(s + 13) >> 1);
   34|  39.3k|   int64_t s6 = MASK & (load_4(s + 15) >> 6);
   35|  39.3k|   int64_t s7 = MASK & (load_3(s + 18) >> 3);
   36|  39.3k|   int64_t s8 = MASK & load_3(s + 21);
   37|  39.3k|   int64_t s9 = MASK & (load_4(s + 23) >> 5);
   38|  39.3k|   int64_t s10 = MASK & (load_3(s + 26) >> 2);
   39|  39.3k|   int64_t s11 = MASK & (load_4(s + 28) >> 7);
   40|  39.3k|   int64_t s12 = MASK & (load_4(s + 31) >> 4);
   41|  39.3k|   int64_t s13 = MASK & (load_3(s + 34) >> 1);
   42|  39.3k|   int64_t s14 = MASK & (load_4(s + 36) >> 6);
   43|  39.3k|   int64_t s15 = MASK & (load_3(s + 39) >> 3);
   44|  39.3k|   int64_t s16 = MASK & load_3(s + 42);
   45|  39.3k|   int64_t s17 = MASK & (load_4(s + 44) >> 5);
   46|  39.3k|   int64_t s18 = MASK & (load_3(s + 47) >> 2);
   47|  39.3k|   int64_t s19 = MASK & (load_4(s + 49) >> 7);
   48|  39.3k|   int64_t s20 = MASK & (load_4(s + 52) >> 4);
   49|  39.3k|   int64_t s21 = MASK & (load_3(s + 55) >> 1);
   50|  39.3k|   int64_t s22 = MASK & (load_4(s + 57) >> 6);
   51|  39.3k|   int64_t s23 = (load_4(s + 60) >> 3);
   52|       |
   53|  39.3k|   redc_mul(s11, s12, s13, s14, s15, s16, s23);
   54|  39.3k|   redc_mul(s10, s11, s12, s13, s14, s15, s22);
   55|  39.3k|   redc_mul(s9, s10, s11, s12, s13, s14, s21);
   56|  39.3k|   redc_mul(s8, s9, s10, s11, s12, s13, s20);
   57|  39.3k|   redc_mul(s7, s8, s9, s10, s11, s12, s19);
   58|  39.3k|   redc_mul(s6, s7, s8, s9, s10, s11, s18);
   59|       |
   60|  39.3k|   carry<21>(s6, s7);
   61|  39.3k|   carry<21>(s8, s9);
   62|  39.3k|   carry<21>(s10, s11);
   63|  39.3k|   carry<21>(s12, s13);
   64|  39.3k|   carry<21>(s14, s15);
   65|  39.3k|   carry<21>(s16, s17);
   66|       |
   67|  39.3k|   carry<21>(s7, s8);
   68|  39.3k|   carry<21>(s9, s10);
   69|  39.3k|   carry<21>(s11, s12);
   70|  39.3k|   carry<21>(s13, s14);
   71|  39.3k|   carry<21>(s15, s16);
   72|       |
   73|  39.3k|   redc_mul(s5, s6, s7, s8, s9, s10, s17);
   74|  39.3k|   redc_mul(s4, s5, s6, s7, s8, s9, s16);
   75|  39.3k|   redc_mul(s3, s4, s5, s6, s7, s8, s15);
   76|  39.3k|   redc_mul(s2, s3, s4, s5, s6, s7, s14);
   77|  39.3k|   redc_mul(s1, s2, s3, s4, s5, s6, s13);
   78|  39.3k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
   79|       |
   80|  39.3k|   carry<21>(s0, s1);
   81|  39.3k|   carry<21>(s2, s3);
   82|  39.3k|   carry<21>(s4, s5);
   83|  39.3k|   carry<21>(s6, s7);
   84|  39.3k|   carry<21>(s8, s9);
   85|  39.3k|   carry<21>(s10, s11);
   86|       |
   87|  39.3k|   carry<21>(s1, s2);
   88|  39.3k|   carry<21>(s3, s4);
   89|  39.3k|   carry<21>(s5, s6);
   90|  39.3k|   carry<21>(s7, s8);
   91|  39.3k|   carry<21>(s9, s10);
   92|  39.3k|   carry<21>(s11, s12);
   93|       |
   94|  39.3k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
   95|       |
   96|  39.3k|   carry0<21>(s0, s1);
   97|  39.3k|   carry0<21>(s1, s2);
   98|  39.3k|   carry0<21>(s2, s3);
   99|  39.3k|   carry0<21>(s3, s4);
  100|  39.3k|   carry0<21>(s4, s5);
  101|  39.3k|   carry0<21>(s5, s6);
  102|  39.3k|   carry0<21>(s6, s7);
  103|  39.3k|   carry0<21>(s7, s8);
  104|  39.3k|   carry0<21>(s8, s9);
  105|  39.3k|   carry0<21>(s9, s10);
  106|  39.3k|   carry0<21>(s10, s11);
  107|  39.3k|   carry0<21>(s11, s12);
  108|       |
  109|  39.3k|   redc_mul(s0, s1, s2, s3, s4, s5, s12);
  110|       |
  111|  39.3k|   carry0<21>(s0, s1);
  112|  39.3k|   carry0<21>(s1, s2);
  113|  39.3k|   carry0<21>(s2, s3);
  114|  39.3k|   carry0<21>(s3, s4);
  115|  39.3k|   carry0<21>(s4, s5);
  116|  39.3k|   carry0<21>(s5, s6);
  117|  39.3k|   carry0<21>(s6, s7);
  118|  39.3k|   carry0<21>(s7, s8);
  119|  39.3k|   carry0<21>(s8, s9);
  120|  39.3k|   carry0<21>(s9, s10);
  121|  39.3k|   carry0<21>(s10, s11);
  122|  39.3k|   carry0<21>(s11, s12);
  123|       |
  124|  39.3k|   s[0] = static_cast<uint8_t>(s0 >> 0);
  125|  39.3k|   s[1] = static_cast<uint8_t>(s0 >> 8);
  126|  39.3k|   s[2] = static_cast<uint8_t>((s0 >> 16) | (s1 << 5));
  127|  39.3k|   s[3] = static_cast<uint8_t>(s1 >> 3);
  128|  39.3k|   s[4] = static_cast<uint8_t>(s1 >> 11);
  129|  39.3k|   s[5] = static_cast<uint8_t>((s1 >> 19) | (s2 << 2));
  130|  39.3k|   s[6] = static_cast<uint8_t>(s2 >> 6);
  131|  39.3k|   s[7] = static_cast<uint8_t>((s2 >> 14) | (s3 << 7));
  132|  39.3k|   s[8] = static_cast<uint8_t>(s3 >> 1);
  133|  39.3k|   s[9] = static_cast<uint8_t>(s3 >> 9);
  134|  39.3k|   s[10] = static_cast<uint8_t>((s3 >> 17) | (s4 << 4));
  135|  39.3k|   s[11] = static_cast<uint8_t>(s4 >> 4);
  136|  39.3k|   s[12] = static_cast<uint8_t>(s4 >> 12);
  137|  39.3k|   s[13] = static_cast<uint8_t>((s4 >> 20) | (s5 << 1));
  138|  39.3k|   s[14] = static_cast<uint8_t>(s5 >> 7);
  139|  39.3k|   s[15] = static_cast<uint8_t>((s5 >> 15) | (s6 << 6));
  140|  39.3k|   s[16] = static_cast<uint8_t>(s6 >> 2);
  141|  39.3k|   s[17] = static_cast<uint8_t>(s6 >> 10);
  142|  39.3k|   s[18] = static_cast<uint8_t>((s6 >> 18) | (s7 << 3));
  143|  39.3k|   s[19] = static_cast<uint8_t>(s7 >> 5);
  144|  39.3k|   s[20] = static_cast<uint8_t>(s7 >> 13);
  145|  39.3k|   s[21] = static_cast<uint8_t>(s8 >> 0);
  146|  39.3k|   s[22] = static_cast<uint8_t>(s8 >> 8);
  147|  39.3k|   s[23] = static_cast<uint8_t>((s8 >> 16) | (s9 << 5));
  148|  39.3k|   s[24] = static_cast<uint8_t>(s9 >> 3);
  149|  39.3k|   s[25] = static_cast<uint8_t>(s9 >> 11);
  150|  39.3k|   s[26] = static_cast<uint8_t>((s9 >> 19) | (s10 << 2));
  151|  39.3k|   s[27] = static_cast<uint8_t>(s10 >> 6);
  152|  39.3k|   s[28] = static_cast<uint8_t>((s10 >> 14) | (s11 << 7));
  153|  39.3k|   s[29] = static_cast<uint8_t>(s11 >> 1);
  154|  39.3k|   s[30] = static_cast<uint8_t>(s11 >> 9);
  155|  39.3k|   s[31] = static_cast<uint8_t>(s11 >> 17);
  156|  39.3k|}

_ZN5Botan9PK_SignerC2ERKNS_11Private_KeyERNS_21RandomNumberGeneratorENSt3__117basic_string_viewIcNS6_11char_traitsIcEEEENS_16Signature_FormatESA_:
  258|  13.1k|      m_sig_format(format), m_sig_element_size(key._signature_element_size_for_DER_encoding()) {
  259|  13.1k|   if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (259:7): [True: 0, False: 13.1k]
  ------------------
  260|      0|      BOTAN_ARG_CHECK(m_sig_element_size.has_value(), "This key does not support DER signatures");
  ------------------
  |  |   32|      0|   do {                                                          \
  |  |   33|      0|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (33:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   35|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (35:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  261|      0|   }
  262|       |
  263|  13.1k|   m_op = key.create_signature_op(rng, emsa, provider);
  264|  13.1k|   if(!m_op) {
  ------------------
  |  Branch (264:7): [True: 0, False: 13.1k]
  ------------------
  265|      0|      throw Invalid_Argument(fmt("Key type {} does not support signature generation", key.algo_name()));
  266|      0|   }
  267|  13.1k|}
_ZN5Botan9PK_SignerD2Ev:
  277|  13.1k|PK_Signer::~PK_Signer() = default;
_ZN5Botan9PK_Signer6updateENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
  282|  13.1k|void PK_Signer::update(std::string_view in) {
  283|  13.1k|   this->update(cast_char_ptr_to_uint8(in.data()), in.size());
  284|  13.1k|}
_ZN5Botan9PK_Signer6updateEPKhm:
  286|  13.1k|void PK_Signer::update(const uint8_t in[], size_t length) {
  287|  13.1k|   m_op->update({in, length});
  288|  13.1k|}
_ZN5Botan9PK_Signer9signatureERNS_21RandomNumberGeneratorE:
  355|  13.1k|std::vector<uint8_t> PK_Signer::signature(RandomNumberGenerator& rng) {
  356|  13.1k|   std::vector<uint8_t> sig = m_op->sign(rng);
  357|       |
  358|  13.1k|   if(m_sig_format == Signature_Format::Standard) {
  ------------------
  |  Branch (358:7): [True: 13.1k, False: 0]
  ------------------
  359|  13.1k|      return sig;
  360|  13.1k|   } else if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (360:14): [True: 0, False: 0]
  ------------------
  361|      0|      BOTAN_ASSERT_NOMSG(m_sig_element_size.has_value());
  ------------------
  |  |   62|      0|   do {                                                                     \
  |  |   63|      0|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   64|      0|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  362|      0|      return der_encode_signature(sig, 2, m_sig_element_size.value());
  363|      0|   } else {
  364|      0|      throw Internal_Error("PK_Signer: Invalid signature format enum");
  365|      0|   }
  366|  13.1k|}
_ZN5Botan11PK_VerifierC2ERKNS_10Public_KeyENSt3__117basic_string_viewIcNS4_11char_traitsIcEEEENS_16Signature_FormatES8_:
  371|  13.1k|                         std::string_view provider) {
  372|  13.1k|   m_op = key.create_verification_op(emsa, provider);
  373|  13.1k|   if(!m_op) {
  ------------------
  |  Branch (373:7): [True: 0, False: 13.1k]
  ------------------
  374|      0|      throw Invalid_Argument(fmt("Key type {} does not support signature verification", key.algo_name()));
  375|      0|   }
  376|       |
  377|  13.1k|   m_sig_format = format;
  378|  13.1k|   m_sig_element_size = key._signature_element_size_for_DER_encoding();
  379|       |
  380|  13.1k|   if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (380:7): [True: 0, False: 13.1k]
  ------------------
  381|      0|      BOTAN_ARG_CHECK(m_sig_element_size.has_value(), "This key does not support DER signatures");
  ------------------
  |  |   32|      0|   do {                                                          \
  |  |   33|      0|      if(!(expr))                                                \
  |  |  ------------------
  |  |  |  Branch (33:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   34|      0|         Botan::throw_invalid_argument(msg, __func__, __FILE__); \
  |  |   35|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (35:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  382|      0|   }
  383|  13.1k|}
_ZN5Botan11PK_VerifierD2Ev:
  397|  13.1k|PK_Verifier::~PK_Verifier() = default;
_ZN5Botan11PK_Verifier6updateENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
  418|  13.1k|void PK_Verifier::update(std::string_view in) {
  419|  13.1k|   this->update(cast_char_ptr_to_uint8(in.data()), in.size());
  420|  13.1k|}
_ZN5Botan11PK_Verifier6updateEPKhm:
  422|  13.1k|void PK_Verifier::update(const uint8_t in[], size_t length) {
  423|  13.1k|   m_op->update({in, length});
  424|  13.1k|}
_ZN5Botan11PK_Verifier15check_signatureEPKhm:
  458|  13.1k|bool PK_Verifier::check_signature(const uint8_t sig[], size_t length) {
  459|  13.1k|   try {
  460|  13.1k|      if(m_sig_format == Signature_Format::Standard) {
  ------------------
  |  Branch (460:10): [True: 13.1k, False: 0]
  ------------------
  461|  13.1k|         return m_op->is_valid_signature({sig, length});
  462|  13.1k|      } else if(m_sig_format == Signature_Format::DerSequence) {
  ------------------
  |  Branch (462:17): [True: 0, False: 0]
  ------------------
  463|      0|         bool decoding_success = false;
  464|      0|         std::vector<uint8_t> real_sig;
  465|       |
  466|      0|         BOTAN_ASSERT_NOMSG(m_sig_element_size.has_value());
  ------------------
  |  |   62|      0|   do {                                                                     \
  |  |   63|      0|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   64|      0|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|      0|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  467|       |
  468|      0|         try {
  469|      0|            real_sig = decode_der_signature(sig, length, 2, m_sig_element_size.value());
  470|      0|            decoding_success = true;
  471|      0|         } catch(Decoding_Error&) {}
  472|       |
  473|      0|         bool accept = m_op->is_valid_signature(real_sig);
  474|       |
  475|      0|         return accept && decoding_success;
  ------------------
  |  Branch (475:17): [True: 0, False: 0]
  |  Branch (475:27): [True: 0, False: 0]
  ------------------
  476|      0|      } else {
  477|      0|         throw Internal_Error("PK_Verifier: Invalid signature format enum");
  478|      0|      }
  479|  13.1k|   } catch(Invalid_Argument&) {
  480|      0|      return false;
  481|      0|   } catch(Decoding_Error&) {
  482|      0|      return false;
  483|      0|   } catch(Encoding_Error&) {
  484|      0|      return false;
  485|      0|   }
  486|  13.1k|}

_ZN5Botan16curve25519_donnaEPhPKhS2_:
  454|  26.2k|void curve25519_donna(uint8_t mypublic[32], const uint8_t secret[32], const uint8_t basepoint[32]) {
  455|  26.2k|   CT::poison(secret, 32);
  456|  26.2k|   CT::poison(basepoint, 32);
  457|       |
  458|  26.2k|   uint64_t bp[5], x[5], z[5], zmone[5];
  459|  26.2k|   uint8_t e[32];
  460|       |
  461|  26.2k|   copy_mem(e, secret, 32);
  462|  26.2k|   e[0] &= 248;
  463|  26.2k|   e[31] &= 127;
  464|  26.2k|   e[31] |= 64;
  465|       |
  466|  26.2k|   fexpand(bp, basepoint);
  467|  26.2k|   cmult(x, z, e, bp);
  468|  26.2k|   crecip(zmone, z);
  469|  26.2k|   fmul(z, x, zmone);
  470|  26.2k|   fcontract(mypublic, z);
  471|       |
  472|  26.2k|   CT::unpoison(secret, 32);
  473|  26.2k|   CT::unpoison(basepoint, 32);
  474|  26.2k|   CT::unpoison(mypublic, 32);
  475|  26.2k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_17fexpandEPmPKh:
  218|  26.2k|inline void fexpand(uint64_t* out, const uint8_t* in) {
  219|  26.2k|   out[0] = load_le<uint64_t>(in, 0) & MASK_63;
  220|  26.2k|   out[1] = (load_le<uint64_t>(in + 6, 0) >> 3) & MASK_63;
  221|  26.2k|   out[2] = (load_le<uint64_t>(in + 12, 0) >> 6) & MASK_63;
  222|  26.2k|   out[3] = (load_le<uint64_t>(in + 19, 0) >> 1) & MASK_63;
  223|  26.2k|   out[4] = (load_le<uint64_t>(in + 24, 0) >> 12) & MASK_63;
  224|  26.2k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_15cmultEPmS1_PKhPKm:
  365|  26.2k|void cmult(uint64_t resultx[5], uint64_t resultz[5], const uint8_t n[32], const uint64_t q[5]) {
  366|  26.2k|   uint64_t a[5] = {0};  // nqpqx
  367|  26.2k|   uint64_t b[5] = {1};  // npqpz
  368|  26.2k|   uint64_t c[5] = {1};  // nqx
  369|  26.2k|   uint64_t d[5] = {0};  // nqz
  370|  26.2k|   uint64_t e[5] = {0};  // npqqx2
  371|  26.2k|   uint64_t f[5] = {1};  // npqqz2
  372|  26.2k|   uint64_t g[5] = {0};  // nqx2
  373|  26.2k|   uint64_t h[5] = {1};  // nqz2
  374|       |
  375|  26.2k|   copy_mem(a, q, 5);
  376|       |
  377|   866k|   for(size_t i = 0; i < 32; ++i) {
  ------------------
  |  Branch (377:22): [True: 839k, False: 26.2k]
  ------------------
  378|   839k|      const uint64_t si = n[31 - i];
  379|   839k|      const auto bit0 = CT::Mask<uint64_t>::expand_bit(si, 7);
  380|   839k|      const auto bit1 = CT::Mask<uint64_t>::expand_bit(si, 6);
  381|   839k|      const auto bit2 = CT::Mask<uint64_t>::expand_bit(si, 5);
  382|   839k|      const auto bit3 = CT::Mask<uint64_t>::expand_bit(si, 4);
  383|   839k|      const auto bit4 = CT::Mask<uint64_t>::expand_bit(si, 3);
  384|   839k|      const auto bit5 = CT::Mask<uint64_t>::expand_bit(si, 2);
  385|   839k|      const auto bit6 = CT::Mask<uint64_t>::expand_bit(si, 1);
  386|   839k|      const auto bit7 = CT::Mask<uint64_t>::expand_bit(si, 0);
  387|       |
  388|   839k|      swap_conditional(c, a, d, b, bit0);
  389|   839k|      fmonty(g, h, e, f, c, d, a, b, q);
  390|       |
  391|   839k|      swap_conditional(g, e, h, f, bit0 ^ bit1);
  392|   839k|      fmonty(c, d, a, b, g, h, e, f, q);
  393|       |
  394|   839k|      swap_conditional(c, a, d, b, bit1 ^ bit2);
  395|   839k|      fmonty(g, h, e, f, c, d, a, b, q);
  396|       |
  397|   839k|      swap_conditional(g, e, h, f, bit2 ^ bit3);
  398|   839k|      fmonty(c, d, a, b, g, h, e, f, q);
  399|       |
  400|   839k|      swap_conditional(c, a, d, b, bit3 ^ bit4);
  401|   839k|      fmonty(g, h, e, f, c, d, a, b, q);
  402|       |
  403|   839k|      swap_conditional(g, e, h, f, bit4 ^ bit5);
  404|   839k|      fmonty(c, d, a, b, g, h, e, f, q);
  405|       |
  406|   839k|      swap_conditional(c, a, d, b, bit5 ^ bit6);
  407|   839k|      fmonty(g, h, e, f, c, d, a, b, q);
  408|       |
  409|   839k|      swap_conditional(g, e, h, f, bit6 ^ bit7);
  410|   839k|      fmonty(c, d, a, b, g, h, e, f, q);
  411|       |
  412|   839k|      swap_conditional(c, a, d, b, bit7);
  413|   839k|   }
  414|       |
  415|  26.2k|   copy_mem(resultx, c, 5);
  416|  26.2k|   copy_mem(resultz, d, 5);
  417|  26.2k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_116swap_conditionalEPmS1_S1_S1_NS_2CT4MaskImEE:
  347|  7.55M|inline void swap_conditional(uint64_t a[5], uint64_t b[5], uint64_t c[5], uint64_t d[5], CT::Mask<uint64_t> swap) {
  348|  45.3M|   for(size_t i = 0; i < 5; ++i) {
  ------------------
  |  Branch (348:22): [True: 37.7M, False: 7.55M]
  ------------------
  349|  37.7M|      const uint64_t x0 = swap.if_set_return(a[i] ^ b[i]);
  350|  37.7M|      a[i] ^= x0;
  351|  37.7M|      b[i] ^= x0;
  352|       |
  353|  37.7M|      const uint64_t x1 = swap.if_set_return(c[i] ^ d[i]);
  354|  37.7M|      c[i] ^= x1;
  355|  37.7M|      d[i] ^= x1;
  356|  37.7M|   }
  357|  7.55M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_16fmontyEPmS1_S1_S1_S1_S1_S1_S1_PKm:
  309|  6.71M|            const uint64_t q_minus_q_dash[5]) {
  310|  6.71M|   uint64_t zzz[5];
  311|  6.71M|   uint64_t xx[5];
  312|  6.71M|   uint64_t zz[5];
  313|  6.71M|   uint64_t xxprime[5];
  314|  6.71M|   uint64_t zzprime[5];
  315|  6.71M|   uint64_t zzzprime[5];
  316|       |
  317|  6.71M|   fadd_sub(in_q_z, in_q_x);
  318|  6.71M|   fadd_sub(in_q_dash_z, in_q_dash_x);
  319|       |
  320|  6.71M|   fmul(xxprime, in_q_dash_x, in_q_z);
  321|  6.71M|   fmul(zzprime, in_q_dash_z, in_q_x);
  322|       |
  323|  6.71M|   fadd_sub(zzprime, xxprime);
  324|       |
  325|  6.71M|   fsquare(result_q_plus_q_dash_x, xxprime);
  326|  6.71M|   fsquare(zzzprime, zzprime);
  327|  6.71M|   fmul(result_q_plus_q_dash_z, zzzprime, q_minus_q_dash);
  328|       |
  329|  6.71M|   fsquare(xx, in_q_x);
  330|  6.71M|   fsquare(zz, in_q_z);
  331|  6.71M|   fmul(result_two_q_x, xx, zz);
  332|       |
  333|  6.71M|   fdifference_backwards(zz, xx);  // does zz = xx - zz
  334|  6.71M|   fscalar_product(zzz, zz, 121665);
  335|  6.71M|   fsum(zzz, xx);
  336|       |
  337|  6.71M|   fmul(result_two_q_z, zz, zzz);
  338|  6.71M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_18fadd_subEPmS1_:
   77|  20.1M|inline void fadd_sub(uint64_t x[5], uint64_t y[5]) {
   78|       |   // TODO merge these and avoid the tmp array
   79|  20.1M|   uint64_t tmp[5];
   80|  20.1M|   copy_mem(tmp, y, 5);
   81|  20.1M|   fsum(y, x);
   82|  20.1M|   fdifference_backwards(x, tmp);  // does x - z
   83|  20.1M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_17fsquareEPmPKmm:
  170|  27.1M|inline void fsquare(uint64_t out[5], const uint64_t in[5], size_t count = 1) {
  171|  27.1M|   uint64_t r0 = in[0];
  172|  27.1M|   uint64_t r1 = in[1];
  173|  27.1M|   uint64_t r2 = in[2];
  174|  27.1M|   uint64_t r3 = in[3];
  175|  27.1M|   uint64_t r4 = in[4];
  176|       |
  177|  60.7M|   for(size_t i = 0; i != count; ++i) {
  ------------------
  |  Branch (177:22): [True: 33.5M, False: 27.1M]
  ------------------
  178|  33.5M|      const uint64_t d0 = r0 * 2;
  179|  33.5M|      const uint64_t d1 = r1 * 2;
  180|  33.5M|      const uint64_t d2 = r2 * 2 * 19;
  181|  33.5M|      const uint64_t d419 = r4 * 19;
  182|  33.5M|      const uint64_t d4 = d419 * 2;
  183|       |
  184|  33.5M|      uint128_t t0 = uint128_t(r0) * r0 + uint128_t(d4) * r1 + uint128_t(d2) * (r3);
  185|  33.5M|      uint128_t t1 = uint128_t(d0) * r1 + uint128_t(d4) * r2 + uint128_t(r3) * (r3 * 19);
  186|  33.5M|      uint128_t t2 = uint128_t(d0) * r2 + uint128_t(r1) * r1 + uint128_t(d4) * (r3);
  187|  33.5M|      uint128_t t3 = uint128_t(d0) * r3 + uint128_t(d1) * r2 + uint128_t(r4) * (d419);
  188|  33.5M|      uint128_t t4 = uint128_t(d0) * r4 + uint128_t(d1) * r3 + uint128_t(r2) * (r2);
  189|       |
  190|  33.5M|      r0 = t0 & MASK_63;
  191|  33.5M|      t1 += carry_shift(t0, 51);
  192|  33.5M|      r1 = t1 & MASK_63;
  193|  33.5M|      t2 += carry_shift(t1, 51);
  194|  33.5M|      r2 = t2 & MASK_63;
  195|  33.5M|      t3 += carry_shift(t2, 51);
  196|  33.5M|      r3 = t3 & MASK_63;
  197|  33.5M|      t4 += carry_shift(t3, 51);
  198|  33.5M|      r4 = t4 & MASK_63;
  199|  33.5M|      uint64_t c = carry_shift(t4, 51);
  200|       |
  201|  33.5M|      r0 += c * 19;
  202|  33.5M|      c = r0 >> 51;
  203|  33.5M|      r0 = r0 & MASK_63;
  204|  33.5M|      r1 += c;
  205|  33.5M|      c = r1 >> 51;
  206|  33.5M|      r1 = r1 & MASK_63;
  207|  33.5M|      r2 += c;
  208|  33.5M|   }
  209|       |
  210|  27.1M|   out[0] = r0;
  211|  27.1M|   out[1] = r1;
  212|  27.1M|   out[2] = r2;
  213|  27.1M|   out[3] = r3;
  214|  27.1M|   out[4] = r4;
  215|  27.1M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_121fdifference_backwardsEPmPKm:
   65|  26.8M|inline void fdifference_backwards(uint64_t out[5], const uint64_t in[5]) {
   66|       |   /* 152 is 19 << 3 */
   67|  26.8M|   const uint64_t two54m152 = (static_cast<uint64_t>(1) << 54) - 152;
   68|  26.8M|   const uint64_t two54m8 = (static_cast<uint64_t>(1) << 54) - 8;
   69|       |
   70|  26.8M|   out[0] = in[0] + two54m152 - out[0];
   71|  26.8M|   out[1] = in[1] + two54m8 - out[1];
   72|  26.8M|   out[2] = in[2] + two54m8 - out[2];
   73|  26.8M|   out[3] = in[3] + two54m8 - out[3];
   74|  26.8M|   out[4] = in[4] + two54m8 - out[4];
   75|  26.8M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_115fscalar_productEPmPKmm:
   88|  6.71M|inline void fscalar_product(uint64_t out[5], const uint64_t in[5], const uint64_t scalar) {
   89|  6.71M|   uint128_t a = uint128_t(in[0]) * scalar;
   90|  6.71M|   out[0] = a & MASK_63;
   91|       |
   92|  6.71M|   a = uint128_t(in[1]) * scalar + carry_shift(a, 51);
   93|  6.71M|   out[1] = a & MASK_63;
   94|       |
   95|  6.71M|   a = uint128_t(in[2]) * scalar + carry_shift(a, 51);
   96|  6.71M|   out[2] = a & MASK_63;
   97|       |
   98|  6.71M|   a = uint128_t(in[3]) * scalar + carry_shift(a, 51);
   99|  6.71M|   out[3] = a & MASK_63;
  100|       |
  101|  6.71M|   a = uint128_t(in[4]) * scalar + carry_shift(a, 51);
  102|  6.71M|   out[4] = a & MASK_63;
  103|       |
  104|  6.71M|   out[0] += carry_shift(a, 51) * 19;
  105|  6.71M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_14fsumEPmPKm:
   51|  26.8M|inline void fsum(uint64_t out[5], const uint64_t in[5]) {
   52|  26.8M|   out[0] += in[0];
   53|  26.8M|   out[1] += in[1];
   54|  26.8M|   out[2] += in[2];
   55|  26.8M|   out[3] += in[3];
   56|  26.8M|   out[4] += in[4];
   57|  26.8M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_16crecipEPmPKm:
  422|  26.2k|void crecip(uint64_t out[5], const uint64_t z[5]) {
  423|  26.2k|   uint64_t a[5];
  424|  26.2k|   uint64_t b[5];
  425|  26.2k|   uint64_t c[5];
  426|  26.2k|   uint64_t t0[5];
  427|       |
  428|  26.2k|   fsquare(a, z);        // 2
  429|  26.2k|   fsquare(t0, a, 2);    // 8
  430|  26.2k|   fmul(b, t0, z);       // 9
  431|  26.2k|   fmul(a, b, a);        // 11
  432|  26.2k|   fsquare(t0, a);       // 22
  433|  26.2k|   fmul(b, t0, b);       // 2^5 - 2^0 = 31
  434|  26.2k|   fsquare(t0, b, 5);    // 2^10 - 2^5
  435|  26.2k|   fmul(b, t0, b);       // 2^10 - 2^0
  436|  26.2k|   fsquare(t0, b, 10);   // 2^20 - 2^10
  437|  26.2k|   fmul(c, t0, b);       // 2^20 - 2^0
  438|  26.2k|   fsquare(t0, c, 20);   // 2^40 - 2^20
  439|  26.2k|   fmul(t0, t0, c);      // 2^40 - 2^0
  440|  26.2k|   fsquare(t0, t0, 10);  // 2^50 - 2^10
  441|  26.2k|   fmul(b, t0, b);       // 2^50 - 2^0
  442|  26.2k|   fsquare(t0, b, 50);   // 2^100 - 2^50
  443|  26.2k|   fmul(c, t0, b);       // 2^100 - 2^0
  444|  26.2k|   fsquare(t0, c, 100);  // 2^200 - 2^100
  445|  26.2k|   fmul(t0, t0, c);      // 2^200 - 2^0
  446|  26.2k|   fsquare(t0, t0, 50);  // 2^250 - 2^50
  447|  26.2k|   fmul(t0, t0, b);      // 2^250 - 2^0
  448|  26.2k|   fsquare(t0, t0, 5);   // 2^255 - 2^5
  449|  26.2k|   fmul(out, t0, a);     // 2^255 - 21
  450|  26.2k|}
donna.cpp:_ZN5Botan12_GLOBAL__N_14fmulEPmPKmS3_:
  115|  33.9M|inline void fmul(uint64_t out[5], const uint64_t in[5], const uint64_t in2[5]) {
  116|  33.9M|   const uint128_t s0 = in2[0];
  117|  33.9M|   const uint128_t s1 = in2[1];
  118|  33.9M|   const uint128_t s2 = in2[2];
  119|  33.9M|   const uint128_t s3 = in2[3];
  120|  33.9M|   const uint128_t s4 = in2[4];
  121|       |
  122|  33.9M|   uint64_t r0 = in[0];
  123|  33.9M|   uint64_t r1 = in[1];
  124|  33.9M|   uint64_t r2 = in[2];
  125|  33.9M|   uint64_t r3 = in[3];
  126|  33.9M|   uint64_t r4 = in[4];
  127|       |
  128|  33.9M|   uint128_t t0 = r0 * s0;
  129|  33.9M|   uint128_t t1 = r0 * s1 + r1 * s0;
  130|  33.9M|   uint128_t t2 = r0 * s2 + r2 * s0 + r1 * s1;
  131|  33.9M|   uint128_t t3 = r0 * s3 + r3 * s0 + r1 * s2 + r2 * s1;
  132|  33.9M|   uint128_t t4 = r0 * s4 + r4 * s0 + r3 * s1 + r1 * s3 + r2 * s2;
  133|       |
  134|  33.9M|   r4 *= 19;
  135|  33.9M|   r1 *= 19;
  136|  33.9M|   r2 *= 19;
  137|  33.9M|   r3 *= 19;
  138|       |
  139|  33.9M|   t0 += r4 * s1 + r1 * s4 + r2 * s3 + r3 * s2;
  140|  33.9M|   t1 += r4 * s2 + r2 * s4 + r3 * s3;
  141|  33.9M|   t2 += r4 * s3 + r3 * s4;
  142|  33.9M|   t3 += r4 * s4;
  143|       |
  144|  33.9M|   r0 = t0 & MASK_63;
  145|  33.9M|   t1 += carry_shift(t0, 51);
  146|  33.9M|   r1 = t1 & MASK_63;
  147|  33.9M|   t2 += carry_shift(t1, 51);
  148|  33.9M|   r2 = t2 & MASK_63;
  149|  33.9M|   t3 += carry_shift(t2, 51);
  150|  33.9M|   r3 = t3 & MASK_63;
  151|  33.9M|   t4 += carry_shift(t3, 51);
  152|  33.9M|   r4 = t4 & MASK_63;
  153|  33.9M|   uint64_t c = carry_shift(t4, 51);
  154|       |
  155|  33.9M|   r0 += c * 19;
  156|  33.9M|   c = r0 >> 51;
  157|  33.9M|   r0 = r0 & MASK_63;
  158|  33.9M|   r1 += c;
  159|  33.9M|   c = r1 >> 51;
  160|  33.9M|   r1 = r1 & MASK_63;
  161|  33.9M|   r2 += c;
  162|       |
  163|  33.9M|   out[0] = r0;
  164|  33.9M|   out[1] = r1;
  165|  33.9M|   out[2] = r2;
  166|  33.9M|   out[3] = r3;
  167|  33.9M|   out[4] = r4;
  168|  33.9M|}
donna.cpp:_ZN5Botan12_GLOBAL__N_19fcontractEPhPKm:
  229|  26.2k|inline void fcontract(uint8_t* out, const uint64_t input[5]) {
  230|  26.2k|   uint128_t t0 = input[0];
  231|  26.2k|   uint128_t t1 = input[1];
  232|  26.2k|   uint128_t t2 = input[2];
  233|  26.2k|   uint128_t t3 = input[3];
  234|  26.2k|   uint128_t t4 = input[4];
  235|       |
  236|  78.7k|   for(size_t i = 0; i != 2; ++i) {
  ------------------
  |  Branch (236:22): [True: 52.4k, False: 26.2k]
  ------------------
  237|  52.4k|      t1 += t0 >> 51;
  238|  52.4k|      t0 &= MASK_63;
  239|  52.4k|      t2 += t1 >> 51;
  240|  52.4k|      t1 &= MASK_63;
  241|  52.4k|      t3 += t2 >> 51;
  242|  52.4k|      t2 &= MASK_63;
  243|  52.4k|      t4 += t3 >> 51;
  244|  52.4k|      t3 &= MASK_63;
  245|  52.4k|      t0 += (t4 >> 51) * 19;
  246|  52.4k|      t4 &= MASK_63;
  247|  52.4k|   }
  248|       |
  249|       |   /* now t is between 0 and 2^255-1, properly carried. */
  250|       |   /* case 1: between 0 and 2^255-20. case 2: between 2^255-19 and 2^255-1. */
  251|       |
  252|  26.2k|   t0 += 19;
  253|       |
  254|  26.2k|   t1 += t0 >> 51;
  255|  26.2k|   t0 &= MASK_63;
  256|  26.2k|   t2 += t1 >> 51;
  257|  26.2k|   t1 &= MASK_63;
  258|  26.2k|   t3 += t2 >> 51;
  259|  26.2k|   t2 &= MASK_63;
  260|  26.2k|   t4 += t3 >> 51;
  261|  26.2k|   t3 &= MASK_63;
  262|  26.2k|   t0 += (t4 >> 51) * 19;
  263|  26.2k|   t4 &= MASK_63;
  264|       |
  265|       |   /* now between 19 and 2^255-1 in both cases, and offset by 19. */
  266|       |
  267|  26.2k|   t0 += 0x8000000000000 - 19;
  268|  26.2k|   t1 += 0x8000000000000 - 1;
  269|  26.2k|   t2 += 0x8000000000000 - 1;
  270|  26.2k|   t3 += 0x8000000000000 - 1;
  271|  26.2k|   t4 += 0x8000000000000 - 1;
  272|       |
  273|       |   /* now between 2^255 and 2^256-20, and offset by 2^255. */
  274|       |
  275|  26.2k|   t1 += t0 >> 51;
  276|  26.2k|   t0 &= MASK_63;
  277|  26.2k|   t2 += t1 >> 51;
  278|  26.2k|   t1 &= MASK_63;
  279|  26.2k|   t3 += t2 >> 51;
  280|  26.2k|   t2 &= MASK_63;
  281|  26.2k|   t4 += t3 >> 51;
  282|  26.2k|   t3 &= MASK_63;
  283|  26.2k|   t4 &= MASK_63;
  284|       |
  285|  26.2k|   store_le(out,
  286|  26.2k|            combine_lower(t0, 0, t1, 51),
  287|  26.2k|            combine_lower(t1, 13, t2, 38),
  288|  26.2k|            combine_lower(t2, 26, t3, 25),
  289|  26.2k|            combine_lower(t3, 39, t4, 12));
  290|  26.2k|}

_ZN5Botan20curve25519_basepointEPhPKh:
   19|  26.2k|void curve25519_basepoint(uint8_t mypublic[32], const uint8_t secret[32]) {
   20|  26.2k|   const uint8_t basepoint[32] = {9};
   21|  26.2k|   curve25519_donna(mypublic, secret, basepoint);
   22|  26.2k|}
_ZNK5Botan16X25519_PublicKey9check_keyERNS_21RandomNumberGeneratorEb:
   44|  13.1k|bool X25519_PublicKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
   45|  13.1k|   return true;  // no tests possible?
   46|  13.1k|}
_ZN5Botan16X25519_PublicKeyC1ENSt3__14spanIKhLm18446744073709551615EEE:
   51|  13.1k|X25519_PublicKey::X25519_PublicKey(std::span<const uint8_t> pub) {
   52|  13.1k|   m_public.assign(pub.begin(), pub.end());
   53|       |
   54|  13.1k|   size_check(m_public.size(), "public key");
   55|  13.1k|}
_ZNK5Botan16X25519_PublicKey19raw_public_key_bitsEv:
   57|  13.1k|std::vector<uint8_t> X25519_PublicKey::raw_public_key_bits() const {
   58|  13.1k|   return m_public;
   59|  13.1k|}
_ZN5Botan17X25519_PrivateKeyC1ERNS_21RandomNumberGeneratorE:
   79|  13.1k|X25519_PrivateKey::X25519_PrivateKey(RandomNumberGenerator& rng) {
   80|  13.1k|   m_private = rng.random_vec(32);
   81|  13.1k|   m_public.resize(32);
   82|  13.1k|   curve25519_basepoint(m_public.data(), m_private.data());
   83|  13.1k|}
_ZNK5Botan17X25519_PrivateKey10public_keyEv:
   93|  13.1k|std::unique_ptr<Public_Key> X25519_PrivateKey::public_key() const {
   94|  13.1k|   return std::make_unique<X25519_PublicKey>(public_value());
   95|  13.1k|}
_ZNK5Botan17X25519_PrivateKey9check_keyERNS_21RandomNumberGeneratorEb:
  101|  13.1k|bool X25519_PrivateKey::check_key(RandomNumberGenerator& /*rng*/, bool /*strong*/) const {
  102|  13.1k|   std::vector<uint8_t> public_point(32);
  103|  13.1k|   curve25519_basepoint(public_point.data(), m_private.data());
  104|  13.1k|   return public_point == m_public;
  105|  13.1k|}
x25519.cpp:_ZN5Botan12_GLOBAL__N_110size_checkEmPKc:
   26|  13.1k|void size_check(size_t size, const char* thing) {
   27|  13.1k|   if(size != 32) {
  ------------------
  |  Branch (27:7): [True: 0, False: 13.1k]
  ------------------
   28|      0|      throw Decoding_Error(fmt("Invalid size {} for X25519 {}", size, thing));
   29|      0|   }
   30|  13.1k|}

_ZN5Botan14AutoSeeded_RNGD2Ev:
   42|  13.1k|AutoSeeded_RNG::~AutoSeeded_RNG() = default;
_ZN5Botan14AutoSeeded_RNGC2Em:
   64|  13.1k|AutoSeeded_RNG::AutoSeeded_RNG(size_t reseed_interval) {
   65|  13.1k|#if defined(BOTAN_HAS_SYSTEM_RNG)
   66|  13.1k|   m_rng = std::make_unique<HMAC_DRBG>(auto_rng_hmac(), system_rng(), reseed_interval);
   67|       |#elif defined(BOTAN_HAS_ENTROPY_SOURCE)
   68|       |   m_rng = std::make_unique<HMAC_DRBG>(auto_rng_hmac(), Entropy_Sources::global_sources(), reseed_interval);
   69|       |#else
   70|       |   BOTAN_UNUSED(reseed_interval);
   71|       |   throw Not_Implemented("AutoSeeded_RNG default constructor not available due to no RNG or entropy sources");
   72|       |#endif
   73|       |
   74|  13.1k|   force_reseed();
   75|  13.1k|}
_ZN5Botan14AutoSeeded_RNG12force_reseedEv:
   77|  13.1k|void AutoSeeded_RNG::force_reseed() {
   78|  13.1k|   m_rng->force_reseed();
   79|  13.1k|   m_rng->next_byte();
   80|       |
   81|  13.1k|   if(!m_rng->is_seeded()) {
  ------------------
  |  Branch (81:7): [True: 0, False: 13.1k]
  ------------------
   82|      0|      throw Internal_Error("AutoSeeded_RNG reseeding failed");
   83|      0|   }
   84|  13.1k|}
_ZN5Botan14AutoSeeded_RNG21fill_bytes_with_inputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
  102|  26.2k|void AutoSeeded_RNG::fill_bytes_with_input(std::span<uint8_t> out, std::span<const uint8_t> in) {
  103|  26.2k|   if(in.empty()) {
  ------------------
  |  Branch (103:7): [True: 26.2k, False: 0]
  ------------------
  104|  26.2k|      m_rng->randomize_with_ts_input(out);
  105|  26.2k|   } else {
  106|      0|      m_rng->randomize_with_input(out, in);
  107|      0|   }
  108|  26.2k|}
auto_rng.cpp:_ZN5Botan12_GLOBAL__N_113auto_rng_hmacEv:
   24|  13.1k|std::unique_ptr<MessageAuthenticationCode> auto_rng_hmac() {
   25|  13.1k|   const std::string possible_auto_rng_hmacs[] = {
   26|  13.1k|      "HMAC(SHA-512)",
   27|  13.1k|      "HMAC(SHA-256)",
   28|  13.1k|   };
   29|       |
   30|  13.1k|   for(const auto& hmac : possible_auto_rng_hmacs) {
  ------------------
  |  Branch (30:25): [True: 13.1k, False: 0]
  ------------------
   31|  13.1k|      if(auto mac = MessageAuthenticationCode::create(hmac)) {
  ------------------
  |  Branch (31:15): [True: 13.1k, False: 0]
  ------------------
   32|  13.1k|         return mac;
   33|  13.1k|      }
   34|  13.1k|   }
   35|       |
   36|       |   // This shouldn't happen since this module has a dependency on sha2_32
   37|      0|   throw Internal_Error("AutoSeeded_RNG: No usable HMAC hash found");
   38|  13.1k|}

_ZN5Botan9HMAC_DRBGC2ENSt3__110unique_ptrINS_25MessageAuthenticationCodeENS1_14default_deleteIS3_EEEERNS_21RandomNumberGeneratorEmm:
   51|  13.1k|      Stateful_RNG(underlying_rng, reseed_interval),
   52|  13.1k|      m_mac(std::move(prf)),
   53|  13.1k|      m_max_number_of_bytes_per_request(max_number_of_bytes_per_request),
   54|  13.1k|      m_security_level(hmac_drbg_security_level(m_mac->output_length())) {
   55|  13.1k|   BOTAN_ASSERT_NONNULL(m_mac);
  ------------------
  |  |   89|  13.1k|   do {                                                                                   \
  |  |   90|  13.1k|      if((ptr) == nullptr)                                                                \
  |  |  ------------------
  |  |  |  Branch (90:10): [True: 0, False: 13.1k]
  |  |  ------------------
  |  |   91|  13.1k|         Botan::assertion_failure(#ptr " is not null", "", __func__, __FILE__, __LINE__); \
  |  |   92|  13.1k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (92:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   56|       |
   57|  13.1k|   check_limits(reseed_interval, max_number_of_bytes_per_request);
   58|       |
   59|  13.1k|   clear();
   60|  13.1k|}
_ZN5Botan9HMAC_DRBG11clear_stateEv:
  110|  13.1k|void HMAC_DRBG::clear_state() {
  111|  13.1k|   if(m_V.empty()) {
  ------------------
  |  Branch (111:7): [True: 13.1k, False: 0]
  ------------------
  112|  13.1k|      const size_t output_length = m_mac->output_length();
  113|  13.1k|      m_V.resize(output_length);
  114|  13.1k|      m_T.resize(output_length);
  115|  13.1k|   }
  116|       |
  117|   852k|   for(size_t i = 0; i != m_V.size(); ++i) {
  ------------------
  |  Branch (117:22): [True: 839k, False: 13.1k]
  ------------------
  118|   839k|      m_V[i] = 0x01;
  119|   839k|   }
  120|  13.1k|   m_mac->set_key(std::vector<uint8_t>(m_V.size(), 0x00));
  121|  13.1k|}
_ZN5Botan9HMAC_DRBG15generate_outputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
  131|  39.3k|void HMAC_DRBG::generate_output(std::span<uint8_t> output, std::span<const uint8_t> input) {
  132|  39.3k|   BOTAN_ASSERT_NOMSG(!output.empty());
  ------------------
  |  |   62|  39.3k|   do {                                                                     \
  |  |   63|  39.3k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 39.3k]
  |  |  ------------------
  |  |   64|  39.3k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|  39.3k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  133|       |
  134|  39.3k|   if(!input.empty()) {
  ------------------
  |  Branch (134:7): [True: 26.2k, False: 13.1k]
  ------------------
  135|  26.2k|      update(input);
  136|  26.2k|   }
  137|       |
  138|  78.7k|   while(!output.empty()) {
  ------------------
  |  Branch (138:10): [True: 39.3k, False: 39.3k]
  ------------------
  139|  39.3k|      const size_t to_copy = std::min(output.size(), m_V.size());
  140|  39.3k|      m_mac->update(m_V);
  141|  39.3k|      m_mac->final(m_V);
  142|  39.3k|      copy_mem(output.data(), m_V.data(), to_copy);
  143|       |
  144|  39.3k|      output = output.subspan(to_copy);
  145|  39.3k|   }
  146|       |
  147|  39.3k|   update(input);
  148|  39.3k|}
_ZN5Botan9HMAC_DRBG6updateENSt3__14spanIKhLm18446744073709551615EEE:
  154|  78.7k|void HMAC_DRBG::update(std::span<const uint8_t> input) {
  155|  78.7k|   m_mac->update(m_V);
  156|  78.7k|   m_mac->update(0x00);
  157|  78.7k|   if(!input.empty()) {
  ------------------
  |  Branch (157:7): [True: 65.6k, False: 13.1k]
  ------------------
  158|  65.6k|      m_mac->update(input);
  159|  65.6k|   }
  160|  78.7k|   m_mac->final(m_T);
  161|  78.7k|   m_mac->set_key(m_T);
  162|       |
  163|  78.7k|   m_mac->update(m_V);
  164|  78.7k|   m_mac->final(m_V);
  165|       |
  166|  78.7k|   if(!input.empty()) {
  ------------------
  |  Branch (166:7): [True: 65.6k, False: 13.1k]
  ------------------
  167|  65.6k|      m_mac->update(m_V);
  168|  65.6k|      m_mac->update(0x01);
  169|  65.6k|      m_mac->update(input);
  170|  65.6k|      m_mac->final(m_T);
  171|  65.6k|      m_mac->set_key(m_T);
  172|       |
  173|  65.6k|      m_mac->update(m_V);
  174|  65.6k|      m_mac->final(m_V);
  175|  65.6k|   }
  176|  78.7k|}
_ZNK5Botan9HMAC_DRBG14security_levelEv:
  178|  39.3k|size_t HMAC_DRBG::security_level() const {
  179|  39.3k|   return m_security_level;
  180|  39.3k|}
hmac_drbg.cpp:_ZN5Botan12_GLOBAL__N_124hmac_drbg_security_levelEm:
   18|  13.1k|size_t hmac_drbg_security_level(size_t mac_output_length) {
   19|       |   // security strength of the hash function
   20|       |   // for pre-image resistance (see NIST SP 800-57)
   21|       |   // SHA-1: 128 bits
   22|       |   // SHA-224, SHA-512/224: 192 bits,
   23|       |   // SHA-256, SHA-512/256, SHA-384, SHA-512: >= 256 bits
   24|       |   // NIST SP 800-90A only supports up to 256 bits though
   25|       |
   26|  13.1k|   if(mac_output_length < 32) {
  ------------------
  |  Branch (26:7): [True: 0, False: 13.1k]
  ------------------
   27|      0|      return (mac_output_length - 4) * 8;
   28|  13.1k|   } else {
   29|  13.1k|      return 32 * 8;
   30|  13.1k|   }
   31|  13.1k|}
hmac_drbg.cpp:_ZN5Botan12_GLOBAL__N_112check_limitsEmm:
   33|  13.1k|void check_limits(size_t reseed_interval, size_t max_number_of_bytes_per_request) {
   34|       |   // SP800-90A permits up to 2^48, but it is not usable on 32 bit
   35|       |   // platforms, so we only allow up to 2^24, which is still reasonably high
   36|  13.1k|   if(reseed_interval == 0 || reseed_interval > static_cast<size_t>(1) << 24) {
  ------------------
  |  Branch (36:7): [True: 0, False: 13.1k]
  |  Branch (36:31): [True: 0, False: 13.1k]
  ------------------
   37|      0|      throw Invalid_Argument("Invalid value for reseed_interval");
   38|      0|   }
   39|       |
   40|  13.1k|   if(max_number_of_bytes_per_request == 0 || max_number_of_bytes_per_request > 64 * 1024) {
  ------------------
  |  Branch (40:7): [True: 0, False: 13.1k]
  |  Branch (40:47): [True: 0, False: 13.1k]
  ------------------
   41|      0|      throw Invalid_Argument("Invalid value for max_number_of_bytes_per_request");
   42|      0|   }
   43|  13.1k|}

_ZN5Botan21RandomNumberGenerator23randomize_with_ts_inputENSt3__14spanIhLm18446744073709551615EEE:
   27|  26.2k|void RandomNumberGenerator::randomize_with_ts_input(std::span<uint8_t> output) {
   28|  26.2k|   if(this->accepts_input()) {
  ------------------
  |  Branch (28:7): [True: 26.2k, False: 0]
  ------------------
   29|  26.2k|      std::array<uint8_t, 32> additional_input = {0};
   30|       |
   31|  26.2k|#if defined(BOTAN_HAS_OS_UTILS)
   32|  26.2k|      store_le(std::span{additional_input}.subspan<0, 8>(), OS::get_high_resolution_clock());
   33|  26.2k|      store_le(std::span{additional_input}.subspan<8, 4>(), OS::get_process_id());
   34|  26.2k|      constexpr size_t offset = 12;
   35|       |#else
   36|       |      constexpr size_t offset = 0;
   37|       |#endif
   38|       |
   39|  26.2k|#if defined(BOTAN_HAS_SYSTEM_RNG)
   40|  26.2k|      system_rng().randomize(std::span{additional_input}.subspan<offset>());
   41|       |#else
   42|       |      BOTAN_UNUSED(offset);
   43|       |#endif
   44|       |
   45|  26.2k|      this->fill_bytes_with_input(output, additional_input);
   46|  26.2k|   } else {
   47|      0|      this->fill_bytes_with_input(output, {});
   48|      0|   }
   49|  26.2k|}
_ZN5Botan21RandomNumberGenerator15reseed_from_rngERS0_m:
   63|  13.1k|void RandomNumberGenerator::reseed_from_rng(RandomNumberGenerator& rng, size_t poll_bits) {
   64|  13.1k|   if(this->accepts_input()) {
  ------------------
  |  Branch (64:7): [True: 13.1k, False: 0]
  ------------------
   65|  13.1k|      this->add_entropy(rng.random_vec(poll_bits / 8));
   66|  13.1k|   }
   67|  13.1k|}

_ZN5Botan12Stateful_RNG5clearEv:
   14|  13.1k|void Stateful_RNG::clear() {
   15|  13.1k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   16|  13.1k|   m_reseed_counter = 0;
   17|  13.1k|   m_last_pid = 0;
   18|  13.1k|   clear_state();
   19|  13.1k|}
_ZN5Botan12Stateful_RNG12force_reseedEv:
   21|  13.1k|void Stateful_RNG::force_reseed() {
   22|  13.1k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   23|  13.1k|   m_reseed_counter = 0;
   24|  13.1k|}
_ZNK5Botan12Stateful_RNG9is_seededEv:
   26|  65.6k|bool Stateful_RNG::is_seeded() const {
   27|  65.6k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   28|  65.6k|   return m_reseed_counter > 0;
   29|  65.6k|}
_ZN5Botan12Stateful_RNG23generate_batched_outputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
   38|  39.3k|void Stateful_RNG::generate_batched_output(std::span<uint8_t> output, std::span<const uint8_t> input) {
   39|  39.3k|   BOTAN_ASSERT_NOMSG(!output.empty());
  ------------------
  |  |   62|  39.3k|   do {                                                                     \
  |  |   63|  39.3k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 39.3k]
  |  |  ------------------
  |  |   64|  39.3k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|  39.3k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
   40|       |
   41|  39.3k|   const size_t max_per_request = max_number_of_bytes_per_request();
   42|       |
   43|  39.3k|   if(max_per_request == 0) {
  ------------------
  |  Branch (43:7): [True: 0, False: 39.3k]
  ------------------
   44|       |      // no limit
   45|      0|      reseed_check();
   46|      0|      this->generate_output(output, input);
   47|  39.3k|   } else {
   48|  78.7k|      while(!output.empty()) {
  ------------------
  |  Branch (48:13): [True: 39.3k, False: 39.3k]
  ------------------
   49|  39.3k|         const size_t this_req = std::min(max_per_request, output.size());
   50|       |
   51|  39.3k|         reseed_check();
   52|  39.3k|         this->generate_output(output.subspan(0, this_req), input);
   53|       |
   54|       |         // only include the input for the first iteration
   55|  39.3k|         input = {};
   56|       |
   57|  39.3k|         output = output.subspan(this_req);
   58|  39.3k|      }
   59|  39.3k|   }
   60|  39.3k|}
_ZN5Botan12Stateful_RNG21fill_bytes_with_inputENSt3__14spanIhLm18446744073709551615EEENS2_IKhLm18446744073709551615EEE:
   62|  52.4k|void Stateful_RNG::fill_bytes_with_input(std::span<uint8_t> output, std::span<const uint8_t> input) {
   63|  52.4k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   64|       |
   65|  52.4k|   if(output.empty()) {
  ------------------
  |  Branch (65:7): [True: 13.1k, False: 39.3k]
  ------------------
   66|       |      // Special case for exclusively adding entropy to the stateful RNG.
   67|  13.1k|      this->update(input);
   68|       |
   69|  13.1k|      if(8 * input.size() >= security_level()) {
  ------------------
  |  Branch (69:10): [True: 13.1k, False: 0]
  ------------------
   70|  13.1k|         reset_reseed_counter();
   71|  13.1k|      }
   72|  39.3k|   } else {
   73|  39.3k|      generate_batched_output(output, input);
   74|  39.3k|   }
   75|  52.4k|}
_ZN5Botan12Stateful_RNG15reseed_from_rngERNS_21RandomNumberGeneratorEm:
   89|  13.1k|void Stateful_RNG::reseed_from_rng(RandomNumberGenerator& rng, size_t poll_bits) {
   90|  13.1k|   lock_guard_type<recursive_mutex_type> lock(m_mutex);
   91|       |
   92|  13.1k|   RandomNumberGenerator::reseed_from_rng(rng, poll_bits);
   93|       |
   94|  13.1k|   if(poll_bits >= security_level()) {
  ------------------
  |  Branch (94:7): [True: 13.1k, False: 0]
  ------------------
   95|  13.1k|      reset_reseed_counter();
   96|  13.1k|   }
   97|  13.1k|}
_ZN5Botan12Stateful_RNG20reset_reseed_counterEv:
   99|  26.2k|void Stateful_RNG::reset_reseed_counter() {
  100|       |   // Lock is held whenever this function is called
  101|  26.2k|   m_reseed_counter = 1;
  102|  26.2k|}
_ZN5Botan12Stateful_RNG12reseed_checkEv:
  104|  39.3k|void Stateful_RNG::reseed_check() {
  105|       |   // Lock is held whenever this function is called
  106|       |
  107|  39.3k|   const uint32_t cur_pid = OS::get_process_id();
  108|       |
  109|  39.3k|   const bool fork_detected = (m_last_pid > 0) && (cur_pid != m_last_pid);
  ------------------
  |  Branch (109:31): [True: 26.2k, False: 13.1k]
  |  Branch (109:51): [True: 0, False: 26.2k]
  ------------------
  110|       |
  111|  39.3k|   if(is_seeded() == false || fork_detected || (m_reseed_interval > 0 && m_reseed_counter >= m_reseed_interval)) {
  ------------------
  |  Branch (111:7): [True: 13.1k, False: 26.2k]
  |  Branch (111:31): [True: 0, False: 26.2k]
  |  Branch (111:49): [True: 26.2k, False: 0]
  |  Branch (111:74): [True: 0, False: 26.2k]
  ------------------
  112|  13.1k|      m_reseed_counter = 0;
  113|  13.1k|      m_last_pid = cur_pid;
  114|       |
  115|  13.1k|      if(m_underlying_rng) {
  ------------------
  |  Branch (115:10): [True: 13.1k, False: 0]
  ------------------
  116|  13.1k|         reseed_from_rng(*m_underlying_rng, security_level());
  117|  13.1k|      }
  118|       |
  119|  13.1k|      if(m_entropy_sources) {
  ------------------
  |  Branch (119:10): [True: 0, False: 13.1k]
  ------------------
  120|      0|         reseed(*m_entropy_sources, security_level());
  121|      0|      }
  122|       |
  123|  13.1k|      if(!is_seeded()) {
  ------------------
  |  Branch (123:10): [True: 0, False: 13.1k]
  ------------------
  124|      0|         if(fork_detected) {
  ------------------
  |  Branch (124:13): [True: 0, False: 0]
  ------------------
  125|      0|            throw Invalid_State("Detected use of fork but cannot reseed DRBG");
  126|      0|         } else {
  127|      0|            throw PRNG_Unseeded(name());
  128|      0|         }
  129|      0|      }
  130|  26.2k|   } else {
  131|  26.2k|      BOTAN_ASSERT(m_reseed_counter != 0, "RNG is seeded");
  ------------------
  |  |   53|  26.2k|   do {                                                                                 \
  |  |   54|  26.2k|      if(!(expr))                                                                       \
  |  |  ------------------
  |  |  |  Branch (54:10): [True: 0, False: 26.2k]
  |  |  ------------------
  |  |   55|  26.2k|         Botan::assertion_failure(#expr, assertion_made, __func__, __FILE__, __LINE__); \
  |  |   56|  26.2k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (56:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  132|  26.2k|      m_reseed_counter += 1;
  133|  26.2k|   }
  134|  39.3k|}

_ZN5Botan10system_rngEv:
  371|  39.3k|RandomNumberGenerator& system_rng() {
  372|  39.3k|   static System_RNG_Impl g_system_rng;
  373|  39.3k|   return g_system_rng;
  374|  39.3k|}
system_rng.cpp:_ZN5Botan12_GLOBAL__N_115System_RNG_Impl21fill_bytes_with_inputENSt3__14spanIhLm18446744073709551615EEENS3_IKhLm18446744073709551615EEE:
  213|  39.3k|      void fill_bytes_with_input(std::span<uint8_t> output, std::span<const uint8_t> /* ignored */) override {
  214|  39.3k|         const unsigned int flags = 0;
  215|       |
  216|  39.3k|         uint8_t* buf = output.data();
  217|  39.3k|         size_t len = output.size();
  218|  78.7k|         while(len > 0) {
  ------------------
  |  Branch (218:16): [True: 39.3k, False: 39.3k]
  ------------------
  219|       |   #if defined(__GLIBC__) && __GLIBC__ == 2 && __GLIBC_MINOR__ < 25
  220|       |            const ssize_t got = ::syscall(SYS_getrandom, buf, len, flags);
  221|       |   #else
  222|  39.3k|            const ssize_t got = ::getrandom(buf, len, flags);
  223|  39.3k|   #endif
  224|       |
  225|  39.3k|            if(got < 0) {
  ------------------
  |  Branch (225:16): [True: 0, False: 39.3k]
  ------------------
  226|      0|               if(errno == EINTR) {
  ------------------
  |  Branch (226:19): [True: 0, False: 0]
  ------------------
  227|      0|                  continue;
  228|      0|               }
  229|      0|               throw System_Error("System_RNG getrandom failed", errno);
  230|      0|            }
  231|       |
  232|  39.3k|            buf += got;
  233|  39.3k|            len -= got;
  234|  39.3k|         }
  235|  39.3k|      }

_ZN5Botan15allocate_memoryEmm:
   21|   196k|BOTAN_MALLOC_FN void* allocate_memory(size_t elems, size_t elem_size) {
   22|   196k|   if(elems == 0 || elem_size == 0) {
  ------------------
  |  Branch (22:7): [True: 0, False: 196k]
  |  Branch (22:21): [True: 0, False: 196k]
  ------------------
   23|      0|      return nullptr;
   24|      0|   }
   25|       |
   26|       |   // Some calloc implementations do not check for overflow (?!?)
   27|   196k|   if(!checked_mul(elems, elem_size).has_value()) {
  ------------------
  |  Branch (27:7): [True: 0, False: 196k]
  ------------------
   28|      0|      throw std::bad_alloc();
   29|      0|   }
   30|       |
   31|   196k|#if defined(BOTAN_HAS_LOCKING_ALLOCATOR)
   32|   196k|   if(void* p = mlock_allocator::instance().allocate(elems, elem_size)) {
  ------------------
  |  Branch (32:13): [True: 196k, False: 0]
  ------------------
   33|   196k|      return p;
   34|   196k|   }
   35|      0|#endif
   36|       |
   37|       |#if defined(BOTAN_TARGET_OS_HAS_ALLOC_CONCEAL)
   38|       |   void* ptr = ::calloc_conceal(elems, elem_size);
   39|       |#else
   40|      0|   void* ptr = std::calloc(elems, elem_size);  // NOLINT(*-no-malloc)
   41|      0|#endif
   42|      0|   if(!ptr) {
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
   43|      0|      [[unlikely]] throw std::bad_alloc();
   44|      0|   }
   45|      0|   return ptr;
   46|      0|}
_ZN5Botan17deallocate_memoryEPvmm:
   48|   196k|void deallocate_memory(void* p, size_t elems, size_t elem_size) {
   49|   196k|   if(p == nullptr) {
  ------------------
  |  Branch (49:7): [True: 0, False: 196k]
  ------------------
   50|      0|      [[unlikely]] return;
   51|      0|   }
   52|       |
   53|   196k|   secure_scrub_memory(p, elems * elem_size);
   54|       |
   55|   196k|#if defined(BOTAN_HAS_LOCKING_ALLOCATOR)
   56|   196k|   if(mlock_allocator::instance().deallocate(p, elems, elem_size)) {
  ------------------
  |  Branch (56:7): [True: 196k, False: 0]
  ------------------
   57|   196k|      return;
   58|   196k|   }
   59|      0|#endif
   60|       |
   61|      0|   std::free(p);  // NOLINT(*-no-malloc)
   62|      0|}

_ZN5Botan5CPUID10CPUID_DataC2Ev:
   79|      1|CPUID::CPUID_Data::CPUID_Data() {
   80|      1|#if defined(BOTAN_HAS_CPUID_DETECTION)
   81|      1|   m_processor_features = detect_cpu_features(~cleared_cpuid_bits());
   82|       |#else
   83|       |   m_processor_features = 0;
   84|       |#endif
   85|      1|}
cpuid.cpp:_ZN5Botan12_GLOBAL__N_118cleared_cpuid_bitsEv:
   58|      1|uint32_t cleared_cpuid_bits() {
   59|      1|   uint32_t cleared = 0;
   60|       |
   61|      1|   #if defined(BOTAN_HAS_OS_UTILS)
   62|      1|   std::string clear_cpuid_env;
   63|      1|   if(OS::read_env_variable(clear_cpuid_env, "BOTAN_CLEAR_CPUID")) {
  ------------------
  |  Branch (63:7): [True: 0, False: 1]
  ------------------
   64|      0|      for(const auto& cpuid : split_on(clear_cpuid_env, ',')) {
  ------------------
  |  Branch (64:29): [True: 0, False: 0]
  ------------------
   65|      0|         if(auto bit = CPUID::bit_from_string(cpuid)) {
  ------------------
  |  Branch (65:18): [True: 0, False: 0]
  ------------------
   66|      0|            cleared |= bit->as_u32();
   67|      0|         }
   68|      0|      }
   69|      0|   }
   70|      1|   #endif
   71|       |
   72|      1|   return cleared;
   73|      1|}

_ZN5Botan5CPUID10CPUID_Data19detect_cpu_featuresEj:
   61|      1|uint32_t CPUID::CPUID_Data::detect_cpu_features(uint32_t allowed) {
   62|      1|   enum class x86_CPUID_1_bits : uint64_t {
   63|      1|      RDTSC = (1ULL << 4),
   64|      1|      SSE2 = (1ULL << 26),
   65|      1|      CLMUL = (1ULL << 33),
   66|      1|      SSSE3 = (1ULL << 41),
   67|      1|      SSE41 = (1ULL << 51),
   68|      1|      AESNI = (1ULL << 57),
   69|       |      // AVX + OSXSAVE
   70|      1|      OSXSAVE = (1ULL << 59) | (1ULL << 60),
   71|      1|      RDRAND = (1ULL << 62)
   72|      1|   };
   73|       |
   74|      1|   enum class x86_CPUID_7_bits : uint64_t {
   75|      1|      BMI1 = (1ULL << 3),
   76|      1|      AVX2 = (1ULL << 5),
   77|      1|      BMI2 = (1ULL << 8),
   78|      1|      BMI_1_AND_2 = BMI1 | BMI2,
   79|      1|      AVX512_F = (1ULL << 16),
   80|      1|      AVX512_DQ = (1ULL << 17),
   81|      1|      RDSEED = (1ULL << 18),
   82|      1|      ADX = (1ULL << 19),
   83|      1|      AVX512_IFMA = (1ULL << 21),
   84|      1|      SHA = (1ULL << 29),
   85|      1|      AVX512_BW = (1ULL << 30),
   86|      1|      AVX512_VL = (1ULL << 31),
   87|      1|      AVX512_VBMI = (1ULL << 33),
   88|      1|      AVX512_VBMI2 = (1ULL << 38),
   89|      1|      GFNI = (1ULL << 40),
   90|      1|      AVX512_VAES = (1ULL << 41),
   91|      1|      AVX512_VCLMUL = (1ULL << 42),
   92|      1|      AVX512_VBITALG = (1ULL << 44),
   93|       |
   94|       |      /*
   95|       |      We only enable AVX512 support if all of the below flags are available
   96|       |
   97|       |      This is more than we strictly need for most uses, however it also has
   98|       |      the effect of preventing execution of AVX512 codepaths on cores that
   99|       |      have serious downclocking problems when AVX512 code executes,
  100|       |      especially Intel Skylake.
  101|       |
  102|       |      VBMI2/VBITALG are the key flags here as they restrict us to Intel Ice
  103|       |      Lake/Rocket Lake, or AMD Zen4, all of which do not have penalties for
  104|       |      executing AVX512.
  105|       |
  106|       |      There is nothing stopping some future processor from supporting the
  107|       |      above flags and having AVX512 penalties, but maybe you should not have
  108|       |      bought such a processor.
  109|       |      */
  110|      1|      AVX512_PROFILE =
  111|      1|         AVX512_F | AVX512_DQ | AVX512_IFMA | AVX512_BW | AVX512_VL | AVX512_VBMI | AVX512_VBMI2 | AVX512_VBITALG,
  112|      1|   };
  113|       |
  114|       |   // NOLINTNEXTLINE(performance-enum-size)
  115|      1|   enum class x86_CPUID_7_1_bits : uint64_t {
  116|      1|      SHA512 = (1 << 0),
  117|      1|      SM3 = (1 << 1),
  118|      1|      SM4 = (1 << 2),
  119|      1|   };
  120|       |
  121|      1|   uint32_t feat = 0;
  122|      1|   uint32_t cpuid[4] = {0};
  123|      1|   bool has_os_ymm_support = false;
  124|      1|   bool has_os_zmm_support = false;
  125|       |
  126|       |   // CPUID 0: vendor identification, max sublevel
  127|      1|   invoke_cpuid(0, cpuid);
  128|       |
  129|      1|   const uint32_t max_supported_sublevel = cpuid[0];
  130|       |
  131|      1|   if(max_supported_sublevel >= 1) {
  ------------------
  |  Branch (131:7): [True: 1, False: 0]
  ------------------
  132|       |      // CPUID 1: feature bits
  133|      1|      invoke_cpuid(1, cpuid);
  134|      1|      const uint64_t flags0 = (static_cast<uint64_t>(cpuid[2]) << 32) | cpuid[3];
  135|       |
  136|      1|      feat |= if_set(flags0, x86_CPUID_1_bits::RDTSC, CPUFeature::Bit::RDTSC, allowed);
  137|       |
  138|      1|      feat |= if_set(flags0, x86_CPUID_1_bits::RDRAND, CPUFeature::Bit::RDRAND, allowed);
  139|       |
  140|      1|      feat |= if_set(flags0, x86_CPUID_1_bits::SSE2, CPUFeature::Bit::SSE2, allowed);
  141|       |
  142|      1|      if(feat & CPUFeature::Bit::SSE2) {
  ------------------
  |  Branch (142:10): [True: 1, False: 0]
  ------------------
  143|      1|         feat |= if_set(flags0, x86_CPUID_1_bits::SSSE3, CPUFeature::Bit::SSSE3, allowed);
  144|       |
  145|      1|         if(feat & CPUFeature::Bit::SSSE3) {
  ------------------
  |  Branch (145:13): [True: 1, False: 0]
  ------------------
  146|      1|            feat |= if_set(flags0, x86_CPUID_1_bits::CLMUL, CPUFeature::Bit::CLMUL, allowed);
  147|      1|            feat |= if_set(flags0, x86_CPUID_1_bits::AESNI, CPUFeature::Bit::AESNI, allowed);
  148|      1|         }
  149|       |
  150|      1|         const uint64_t osxsave64 = static_cast<uint64_t>(x86_CPUID_1_bits::OSXSAVE);
  151|      1|         if((flags0 & osxsave64) == osxsave64) {
  ------------------
  |  Branch (151:13): [True: 1, False: 0]
  ------------------
  152|      1|            const uint64_t xcr_flags = xgetbv();
  153|      1|            if((xcr_flags & 0x6) == 0x6) {
  ------------------
  |  Branch (153:16): [True: 1, False: 0]
  ------------------
  154|      1|               has_os_ymm_support = true;
  155|      1|               has_os_zmm_support = (xcr_flags & 0xE0) == 0xE0;
  156|      1|            }
  157|      1|         }
  158|      1|      }
  159|      1|   }
  160|       |
  161|      1|   if(max_supported_sublevel >= 7) {
  ------------------
  |  Branch (161:7): [True: 1, False: 0]
  ------------------
  162|      1|      clear_mem(cpuid, 4);
  163|      1|      invoke_cpuid_sublevel(7, 0, cpuid);
  164|       |
  165|      1|      const uint64_t flags7 = (static_cast<uint64_t>(cpuid[2]) << 32) | cpuid[1];
  166|       |
  167|      1|      clear_mem(cpuid, 4);
  168|      1|      invoke_cpuid_sublevel(7, 1, cpuid);
  169|      1|      const uint32_t flags7_1 = cpuid[0];
  170|       |
  171|      1|      feat |= if_set(flags7, x86_CPUID_7_bits::RDSEED, CPUFeature::Bit::RDSEED, allowed);
  172|      1|      feat |= if_set(flags7, x86_CPUID_7_bits::ADX, CPUFeature::Bit::ADX, allowed);
  173|       |
  174|       |      /*
  175|       |      We only set the BMI bit if both BMI1 and BMI2 are supported, since
  176|       |      typically we want to use both extensions in the same code.
  177|       |      */
  178|      1|      feat |= if_set(flags7, x86_CPUID_7_bits::BMI_1_AND_2, CPUFeature::Bit::BMI, allowed);
  179|       |
  180|      1|      if(feat & CPUFeature::Bit::SSSE3) {
  ------------------
  |  Branch (180:10): [True: 1, False: 0]
  ------------------
  181|      1|         feat |= if_set(flags7, x86_CPUID_7_bits::SHA, CPUFeature::Bit::SHA, allowed);
  182|      1|         feat |= if_set(flags7_1, x86_CPUID_7_1_bits::SM3, CPUFeature::Bit::SM3, allowed);
  183|      1|      }
  184|       |
  185|      1|      if(has_os_ymm_support) {
  ------------------
  |  Branch (185:10): [True: 1, False: 0]
  ------------------
  186|      1|         feat |= if_set(flags7, x86_CPUID_7_bits::AVX2, CPUFeature::Bit::AVX2, allowed);
  187|       |
  188|      1|         if(feat & CPUFeature::Bit::AVX2) {
  ------------------
  |  Branch (188:13): [True: 1, False: 0]
  ------------------
  189|      1|            feat |= if_set(flags7, x86_CPUID_7_bits::GFNI, CPUFeature::Bit::GFNI, allowed);
  190|      1|            feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VAES, CPUFeature::Bit::AVX2_AES, allowed);
  191|      1|            feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VCLMUL, CPUFeature::Bit::AVX2_CLMUL, allowed);
  192|      1|            feat |= if_set(flags7_1, x86_CPUID_7_1_bits::SHA512, CPUFeature::Bit::SHA512, allowed);
  193|      1|            feat |= if_set(flags7_1, x86_CPUID_7_1_bits::SM4, CPUFeature::Bit::SM4, allowed);
  194|       |
  195|      1|            if(has_os_zmm_support) {
  ------------------
  |  Branch (195:16): [True: 0, False: 1]
  ------------------
  196|      0|               feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_PROFILE, CPUFeature::Bit::AVX512, allowed);
  197|       |
  198|      0|               if(feat & CPUFeature::Bit::AVX512) {
  ------------------
  |  Branch (198:19): [True: 0, False: 0]
  ------------------
  199|      0|                  feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VAES, CPUFeature::Bit::AVX512_AES, allowed);
  200|      0|                  feat |= if_set(flags7, x86_CPUID_7_bits::AVX512_VCLMUL, CPUFeature::Bit::AVX512_CLMUL, allowed);
  201|      0|               }
  202|      0|            }
  203|      1|         }
  204|      1|      }
  205|      1|   }
  206|       |
  207|       |/*
  208|       |   * If we don't have access to CPUID, we can still safely assume that
  209|       |   * any x86-64 processor has SSE2 and RDTSC
  210|       |   */
  211|      1|#if defined(BOTAN_TARGET_ARCH_IS_X86_64)
  212|      1|   if(feat == 0) {
  ------------------
  |  Branch (212:7): [True: 0, False: 1]
  ------------------
  213|      0|      feat |= CPUFeature::Bit::SSE2 & allowed;
  214|      0|      feat |= CPUFeature::Bit::RDTSC & allowed;
  215|      0|   }
  216|      1|#endif
  217|       |
  218|      1|   return feat;
  219|      1|}
cpuid_x86.cpp:_ZN5Botan12_GLOBAL__N_112invoke_cpuidEjPj:
   25|      2|void invoke_cpuid(uint32_t type, uint32_t out[4]) {
   26|      2|   clear_mem(out, 4);
   27|       |
   28|      2|#if defined(BOTAN_USE_GCC_INLINE_ASM)
   29|      2|   asm volatile("cpuid\n\t" : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3]) : "0"(type));
   30|       |
   31|       |#elif defined(BOTAN_BUILD_COMPILER_IS_MSVC)
   32|       |   __cpuid((int*)out, type);
   33|       |
   34|       |#else
   35|       |   BOTAN_UNUSED(type);
   36|       |   #warning "No way of calling x86 cpuid instruction for this compiler"
   37|       |#endif
   38|      2|}
cpuid_x86.cpp:_ZN5Botan12_GLOBAL__N_16xgetbvEv:
   55|      1|BOTAN_FUNC_ISA("xsave") uint64_t xgetbv() {
   56|      1|   return _xgetbv(0);
   57|      1|}
cpuid_x86.cpp:_ZN5Botan12_GLOBAL__N_121invoke_cpuid_sublevelEjjPj:
   40|      2|void invoke_cpuid_sublevel(uint32_t type, uint32_t level, uint32_t out[4]) {
   41|      2|   clear_mem(out, 4);
   42|       |
   43|      2|#if defined(BOTAN_USE_GCC_INLINE_ASM)
   44|      2|   asm volatile("cpuid\n\t" : "=a"(out[0]), "=b"(out[1]), "=c"(out[2]), "=d"(out[3]) : "0"(type), "2"(level));
   45|       |
   46|       |#elif defined(BOTAN_BUILD_COMPILER_IS_MSVC)
   47|       |   __cpuidex((int*)out, type, level);
   48|       |
   49|       |#else
   50|       |   BOTAN_UNUSED(type, level);
   51|       |   #warning "No way of calling x86 cpuid instruction for this compiler"
   52|       |#endif
   53|      2|}

_ZN5Botan15mlock_allocator8allocateEmm:
   17|   196k|void* mlock_allocator::allocate(size_t num_elems, size_t elem_size) {
   18|   196k|   if(!m_pool) {
  ------------------
  |  Branch (18:7): [True: 0, False: 196k]
  ------------------
   19|      0|      return nullptr;
   20|      0|   }
   21|       |
   22|   196k|   if(auto n = checked_mul(num_elems, elem_size)) {
  ------------------
  |  Branch (22:12): [True: 196k, False: 0]
  ------------------
   23|   196k|      return m_pool->allocate(n.value());
   24|   196k|   } else {
   25|       |      // overflow!
   26|      0|      return nullptr;
   27|      0|   }
   28|   196k|}
_ZN5Botan15mlock_allocator10deallocateEPvmm:
   30|   196k|bool mlock_allocator::deallocate(void* p, size_t num_elems, size_t elem_size) noexcept {
   31|   196k|   if(!m_pool) {
  ------------------
  |  Branch (31:7): [True: 0, False: 196k]
  ------------------
   32|      0|      return false;
   33|      0|   }
   34|       |
   35|   196k|   if(auto n = checked_mul(num_elems, elem_size)) {
  ------------------
  |  Branch (35:12): [True: 196k, False: 0]
  ------------------
   36|   196k|      return m_pool->deallocate(p, n.value());
   37|   196k|   } else {
   38|       |      /*
   39|       |      We return nullptr in allocate if there was an overflow, so if an
   40|       |      overflow occurs here we know the pointer was not allocated by this pool.
   41|       |      */
   42|      0|      return false;
   43|      0|   }
   44|   196k|}
_ZN5Botan15mlock_allocatorC2Ev:
   46|      2|mlock_allocator::mlock_allocator() {
   47|      2|   const size_t mem_to_lock = OS::get_memory_locking_limit();
   48|      2|   const size_t page_size = OS::system_page_size();
   49|       |
   50|      2|   if(mem_to_lock > 0 && mem_to_lock % page_size == 0) {
  ------------------
  |  Branch (50:7): [True: 2, False: 0]
  |  Branch (50:26): [True: 2, False: 0]
  ------------------
   51|      2|      m_locked_pages = OS::allocate_locked_pages(mem_to_lock / page_size);
   52|       |
   53|      2|      if(!m_locked_pages.empty()) {
  ------------------
  |  Branch (53:10): [True: 2, False: 0]
  ------------------
   54|      2|         m_pool = std::make_unique<Memory_Pool>(m_locked_pages, page_size);
   55|      2|      }
   56|      2|   }
   57|      2|}
_ZN5Botan15mlock_allocator8instanceEv:
   74|   393k|mlock_allocator& mlock_allocator::instance() {
   75|   393k|   return g_mlock_allocator;
   76|   393k|}

_ZN5Botan11Memory_PoolC2ERKNSt3__16vectorIPvNS1_9allocatorIS3_EEEEm:
  295|      2|Memory_Pool::Memory_Pool(const std::vector<void*>& pages, size_t page_size) : m_page_size(page_size) {
  296|      2|   m_min_page_ptr = ~static_cast<uintptr_t>(0);
  297|      2|   m_max_page_ptr = 0;
  298|       |
  299|    256|   for(auto page : pages) {
  ------------------
  |  Branch (299:18): [True: 256, False: 2]
  ------------------
  300|    256|      const uintptr_t p = reinterpret_cast<uintptr_t>(page);
  301|       |
  302|    256|      m_min_page_ptr = std::min(p, m_min_page_ptr);
  303|    256|      m_max_page_ptr = std::max(p, m_max_page_ptr);
  304|       |
  305|    256|      clear_bytes(page, m_page_size);
  306|       |#if defined(BOTAN_MEM_POOL_USE_MMU_PROTECTIONS)
  307|       |      OS::page_prohibit_access(page);
  308|       |#endif
  309|    256|      m_free_pages.push_back(static_cast<uint8_t*>(page));
  310|    256|   }
  311|       |
  312|       |   /*
  313|       |   Right now this points to the start of the last page, adjust it to instead
  314|       |   point to the first byte of the following page
  315|       |   */
  316|      2|   m_max_page_ptr += page_size;
  317|      2|}
_ZN5Botan11Memory_Pool8allocateEm:
  328|   196k|void* Memory_Pool::allocate(size_t n) {
  329|   196k|   if(n > m_page_size) {
  ------------------
  |  Branch (329:7): [True: 0, False: 196k]
  ------------------
  330|      0|      return nullptr;
  331|      0|   }
  332|       |
  333|   196k|   const size_t n_bucket = choose_bucket(n);
  334|       |
  335|   196k|   if(n_bucket > 0) {
  ------------------
  |  Branch (335:7): [True: 196k, False: 0]
  ------------------
  336|   196k|      lock_guard_type<mutex_type> lock(m_mutex);
  337|       |
  338|   196k|      std::deque<Bucket>& buckets = m_buckets_for[n_bucket];
  339|       |
  340|       |      /*
  341|       |      It would be optimal to pick the bucket with the most usage,
  342|       |      since a bucket with say 1 item allocated out of it has a high
  343|       |      chance of becoming later freed and then the whole page can be
  344|       |      recycled.
  345|       |      */
  346|   196k|      for(auto& bucket : buckets) {
  ------------------
  |  Branch (346:24): [True: 131k, False: 65.6k]
  ------------------
  347|   131k|         if(uint8_t* p = bucket.alloc()) {
  ------------------
  |  Branch (347:22): [True: 131k, False: 0]
  ------------------
  348|   131k|            return p;
  349|   131k|         }
  350|       |
  351|       |         // If the bucket is full, maybe move it to the end of the list?
  352|       |         // Otoh bucket search should be very fast
  353|   131k|      }
  354|       |
  355|  65.6k|      if(!m_free_pages.empty()) {
  ------------------
  |  Branch (355:10): [True: 65.6k, False: 0]
  ------------------
  356|  65.6k|         uint8_t* ptr = m_free_pages[0];
  357|  65.6k|         m_free_pages.pop_front();
  358|       |#if defined(BOTAN_MEM_POOL_USE_MMU_PROTECTIONS)
  359|       |         OS::page_allow_access(ptr);
  360|       |#endif
  361|  65.6k|         buckets.push_front(Bucket(ptr, m_page_size, n_bucket));
  362|  65.6k|         void* p = buckets[0].alloc();
  363|  65.6k|         BOTAN_ASSERT_NOMSG(p != nullptr);
  ------------------
  |  |   62|  65.6k|   do {                                                                     \
  |  |   63|  65.6k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 65.6k]
  |  |  ------------------
  |  |   64|  65.6k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|  65.6k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  364|  65.6k|         return p;
  365|  65.6k|      }
  366|  65.6k|   }
  367|       |
  368|       |   // out of room
  369|      0|   return nullptr;
  370|   196k|}
_ZN5Botan11Memory_Pool10deallocateEPvm:
  372|   196k|bool Memory_Pool::deallocate(void* p, size_t len) noexcept {
  373|       |   // Do a fast range check first, before taking the lock
  374|   196k|   const uintptr_t p_val = reinterpret_cast<uintptr_t>(p);
  375|   196k|   if(p_val < m_min_page_ptr || p_val > m_max_page_ptr) {
  ------------------
  |  Branch (375:7): [True: 0, False: 196k]
  |  Branch (375:33): [True: 0, False: 196k]
  ------------------
  376|      0|      return false;
  377|      0|   }
  378|       |
  379|   196k|   const size_t n_bucket = choose_bucket(len);
  380|       |
  381|   196k|   if(n_bucket != 0) {
  ------------------
  |  Branch (381:7): [True: 196k, False: 0]
  ------------------
  382|   196k|      try {
  383|   196k|         lock_guard_type<mutex_type> lock(m_mutex);
  384|       |
  385|   196k|         std::deque<Bucket>& buckets = m_buckets_for[n_bucket];
  386|       |
  387|   196k|         for(size_t i = 0; i != buckets.size(); ++i) {
  ------------------
  |  Branch (387:28): [True: 196k, False: 0]
  ------------------
  388|   196k|            Bucket& bucket = buckets[i];
  389|   196k|            if(bucket.free(p)) {
  ------------------
  |  Branch (389:16): [True: 196k, False: 0]
  ------------------
  390|   196k|               if(bucket.empty()) {
  ------------------
  |  Branch (390:19): [True: 65.6k, False: 131k]
  ------------------
  391|       |#if defined(BOTAN_MEM_POOL_USE_MMU_PROTECTIONS)
  392|       |                  OS::page_prohibit_access(bucket.ptr());
  393|       |#endif
  394|  65.6k|                  m_free_pages.push_back(bucket.ptr());
  395|       |
  396|  65.6k|                  if(i != buckets.size() - 1) {
  ------------------
  |  Branch (396:22): [True: 0, False: 65.6k]
  ------------------
  397|      0|                     std::swap(buckets.back(), buckets[i]);
  398|      0|                  }
  399|  65.6k|                  buckets.pop_back();
  400|  65.6k|               }
  401|   196k|               return true;
  402|   196k|            }
  403|   196k|         }
  404|   196k|      } catch(...) {
  405|       |         /*
  406|       |         * The only exception throws that can occur in the above code are from
  407|       |         * either the STL or BOTAN_ASSERT failures. In either case, such an
  408|       |         * error indicates a logic error or data corruption in the memory
  409|       |         * allocator such that it is no longer safe to continue executing.
  410|       |         *
  411|       |         * Since this function is noexcept, simply letting the exception escape
  412|       |         * is sufficient for terminate to be called. However in this scenario
  413|       |         * it is implementation defined if any stack unwinding is performed.
  414|       |         * Since stack unwinding could cause further memory deallocations this
  415|       |         * could result in further corruption in this allocator state. To prevent
  416|       |         * this, call terminate directly.
  417|       |         */
  418|      0|         std::terminate();
  419|      0|      }
  420|   196k|   }
  421|       |
  422|      0|   return false;
  423|   196k|}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_113choose_bucketEm:
  110|   393k|size_t choose_bucket(size_t n) {
  111|   393k|   const size_t MINIMUM_ALLOCATION = 16;
  112|   393k|   const size_t MAXIMUM_ALLOCATION = 256;
  113|       |
  114|   393k|   if(n < MINIMUM_ALLOCATION || n > MAXIMUM_ALLOCATION) {
  ------------------
  |  Branch (114:7): [True: 0, False: 393k]
  |  Branch (114:33): [True: 0, False: 393k]
  ------------------
  115|      0|      return 0;
  116|      0|   }
  117|       |
  118|       |   // Need to tune these
  119|       |
  120|   393k|   const size_t buckets[] = {
  121|   393k|      16,
  122|   393k|      24,
  123|   393k|      32,
  124|   393k|      48,
  125|   393k|      64,
  126|   393k|      80,
  127|   393k|      96,
  128|   393k|      112,
  129|   393k|      128,
  130|   393k|      160,
  131|   393k|      192,
  132|   393k|      256,
  133|   393k|      0,
  134|   393k|   };
  135|       |
  136|  2.02M|   for(size_t i = 0; buckets[i]; ++i) {
  ------------------
  |  Branch (136:22): [True: 2.02M, False: 0]
  ------------------
  137|  2.02M|      if(n <= buckets[i]) {
  ------------------
  |  Branch (137:10): [True: 393k, False: 1.62M]
  ------------------
  138|   393k|         return buckets[i];
  139|   393k|      }
  140|  2.02M|   }
  141|       |
  142|      0|   return 0;
  143|   393k|}
_ZN5Botan6Bucket5allocEv:
  245|   196k|      uint8_t* alloc() {
  246|   196k|         if(m_is_full) {
  ------------------
  |  Branch (246:13): [True: 0, False: 196k]
  ------------------
  247|       |            // I know I am full
  248|      0|            return nullptr;
  249|      0|         }
  250|       |
  251|   196k|         size_t offset;
  252|   196k|         if(!m_bitmap.find_free(&offset)) {
  ------------------
  |  Branch (252:13): [True: 0, False: 196k]
  ------------------
  253|       |            // I just found out I am full
  254|      0|            m_is_full = true;
  255|      0|            return nullptr;
  256|      0|         }
  257|       |
  258|   196k|         BOTAN_ASSERT(offset * m_item_size < m_page_size, "Offset is in range");
  ------------------
  |  |   53|   196k|   do {                                                                                 \
  |  |   54|   196k|      if(!(expr))                                                                       \
  |  |  ------------------
  |  |  |  Branch (54:10): [True: 0, False: 196k]
  |  |  ------------------
  |  |   55|   196k|         Botan::assertion_failure(#expr, assertion_made, __func__, __FILE__, __LINE__); \
  |  |   56|   196k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (56:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  259|   196k|         return m_range + m_item_size * offset;
  260|   196k|      }
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_16BitMap9find_freeEPm:
  218|   196k|bool BitMap::find_free(size_t* bit) {
  219|   196k|   for(size_t i = 0; i != m_bits.size(); ++i) {
  ------------------
  |  Branch (219:22): [True: 196k, False: 0]
  ------------------
  220|   196k|      const bitmask_type mask = (i == m_bits.size() - 1) ? m_last_mask : m_main_mask;
  ------------------
  |  Branch (220:33): [True: 157k, False: 39.3k]
  ------------------
  221|   196k|      if((m_bits[i] & mask) != mask) {
  ------------------
  |  Branch (221:10): [True: 196k, False: 0]
  ------------------
  222|   196k|         const size_t free_bit = find_set_bit(~m_bits[i]);
  223|   196k|         const bitmask_type bmask = static_cast<bitmask_type>(1) << (free_bit % BITMASK_BITS);
  224|   196k|         BOTAN_ASSERT_NOMSG((m_bits[i] & bmask) == 0);
  ------------------
  |  |   62|   196k|   do {                                                                     \
  |  |   63|   196k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 196k]
  |  |  ------------------
  |  |   64|   196k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   196k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  225|   196k|         m_bits[i] |= bmask;
  226|   196k|         *bit = BITMASK_BITS * i + free_bit;
  227|   196k|         return true;
  228|   196k|      }
  229|   196k|   }
  230|       |
  231|      0|   return false;
  232|   196k|}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_112find_set_bitImEEmT_:
  153|   196k|size_t find_set_bit(T b) {
  154|   196k|   size_t s = 8 * sizeof(T) / 2;
  155|   196k|   size_t bit = 0;
  156|       |
  157|       |   // In this context we don't need to be const-time
  158|  1.37M|   while(s > 0) {
  ------------------
  |  Branch (158:10): [True: 1.18M, False: 196k]
  ------------------
  159|  1.18M|      const T mask = (static_cast<T>(1) << s) - 1;
  160|  1.18M|      if((b & mask) == 0) {
  ------------------
  |  Branch (160:10): [True: 183k, False: 997k]
  ------------------
  161|   183k|         bit += s;
  162|   183k|         b >>= s;
  163|   183k|      }
  164|  1.18M|      s /= 2;
  165|  1.18M|   }
  166|       |
  167|   196k|   return bit;
  168|   196k|}
_ZN5Botan6BucketC2EPhmm:
  239|  65.6k|            m_item_size(item_size),
  240|  65.6k|            m_page_size(mem_size),
  241|  65.6k|            m_range(mem),
  242|  65.6k|            m_bitmap(mem_size / item_size),
  243|  65.6k|            m_is_full(false) {}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_16BitMapC2Em:
  172|  65.6k|      explicit BitMap(size_t bits) : m_len(bits) {
  173|  65.6k|         m_bits.resize((bits + BITMASK_BITS - 1) / BITMASK_BITS);
  174|       |         // MSVC warns if the cast isn't there, clang-tidy warns that the cast is pointless
  175|  65.6k|         m_main_mask = static_cast<bitmask_type>(~0);  // NOLINT(bugprone-misplaced-widening-cast)
  176|  65.6k|         m_last_mask = m_main_mask;
  177|       |
  178|  65.6k|         if(bits % BITMASK_BITS != 0) {
  ------------------
  |  Branch (178:13): [True: 13.1k, False: 52.4k]
  ------------------
  179|  13.1k|            m_last_mask = (static_cast<bitmask_type>(1) << (bits % BITMASK_BITS)) - 1;
  180|  13.1k|         }
  181|  65.6k|      }
_ZN5Botan6Bucket4freeEPv:
  262|   196k|      bool free(void* p) {
  263|   196k|         if(!in_this_bucket(p)) {
  ------------------
  |  Branch (263:13): [True: 0, False: 196k]
  ------------------
  264|      0|            return false;
  265|      0|         }
  266|       |
  267|       |         /*
  268|       |         Zero also any trailing bytes, which should not have been written to,
  269|       |         but maybe the user was bad and wrote past the end.
  270|       |         */
  271|   196k|         std::memset(p, 0, m_item_size);
  272|       |
  273|   196k|         const size_t offset = (reinterpret_cast<uintptr_t>(p) - reinterpret_cast<uintptr_t>(m_range)) / m_item_size;
  274|       |
  275|   196k|         m_bitmap.free(offset);
  276|   196k|         m_is_full = false;
  277|       |
  278|   196k|         return true;
  279|   196k|      }
_ZNK5Botan6Bucket14in_this_bucketEPv:
  281|   196k|      bool in_this_bucket(void* p) const { return ptr_in_pool(m_range, m_page_size, p, m_item_size); }
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_111ptr_in_poolEPKvmS2_m:
  145|   196k|inline bool ptr_in_pool(const void* pool_ptr, size_t poolsize, const void* buf_ptr, size_t bufsize) {
  146|   196k|   const uintptr_t pool = reinterpret_cast<uintptr_t>(pool_ptr);
  147|   196k|   const uintptr_t buf = reinterpret_cast<uintptr_t>(buf_ptr);
  148|   196k|   return (buf >= pool) && (buf + bufsize <= pool + poolsize);
  ------------------
  |  Branch (148:11): [True: 196k, False: 0]
  |  Branch (148:28): [True: 196k, False: 0]
  ------------------
  149|   196k|}
mem_pool.cpp:_ZN5Botan12_GLOBAL__N_16BitMap4freeEm:
  185|   196k|      void free(size_t bit) {
  186|   196k|         BOTAN_ASSERT_NOMSG(bit <= m_len);
  ------------------
  |  |   62|   196k|   do {                                                                     \
  |  |   63|   196k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 196k]
  |  |  ------------------
  |  |   64|   196k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   196k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  187|   196k|         const size_t w = bit / BITMASK_BITS;
  188|   196k|         BOTAN_ASSERT_NOMSG(w < m_bits.size());
  ------------------
  |  |   62|   196k|   do {                                                                     \
  |  |   63|   196k|      if(!(expr))                                                           \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 196k]
  |  |  ------------------
  |  |   64|   196k|         Botan::assertion_failure(#expr, "", __func__, __FILE__, __LINE__); \
  |  |   65|   196k|   } while(0)
  |  |  ------------------
  |  |  |  Branch (65:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
  189|   196k|         const bitmask_type mask = static_cast<bitmask_type>(1) << (bit % BITMASK_BITS);
  190|   196k|         m_bits[w] = m_bits[w] & (~mask);
  191|   196k|      }
_ZNK5Botan6Bucket5emptyEv:
  283|   196k|      bool empty() const { return m_bitmap.empty(); }
mem_pool.cpp:_ZNK5Botan12_GLOBAL__N_16BitMap5emptyEv:
  193|   196k|      bool empty() const {
  194|   236k|         for(auto bitset : m_bits) {
  ------------------
  |  Branch (194:26): [True: 236k, False: 65.6k]
  ------------------
  195|   236k|            if(bitset != 0) {
  ------------------
  |  Branch (195:16): [True: 131k, False: 104k]
  ------------------
  196|   131k|               return false;
  197|   131k|            }
  198|   236k|         }
  199|       |
  200|  65.6k|         return true;
  201|   196k|      }
_ZNK5Botan6Bucket3ptrEv:
  285|  65.6k|      uint8_t* ptr() const { return m_range; }

_ZN5Botan19secure_scrub_memoryEPvm:
   24|   152M|void secure_scrub_memory(void* ptr, size_t n) {
   25|       |#if defined(BOTAN_TARGET_OS_HAS_RTLSECUREZEROMEMORY)
   26|       |   ::RtlSecureZeroMemory(ptr, n);
   27|       |
   28|       |#elif defined(BOTAN_TARGET_OS_HAS_EXPLICIT_BZERO)
   29|       |   ::explicit_bzero(ptr, n);
   30|       |
   31|       |#elif defined(BOTAN_TARGET_OS_HAS_EXPLICIT_MEMSET)
   32|       |   (void)::explicit_memset(ptr, 0, n);
   33|       |
   34|       |#else
   35|       |   /*
   36|       |   * Call memset through a static volatile pointer, which the compiler should
   37|       |   * not elide. This construct should be safe in conforming compilers, but who
   38|       |   * knows. This has been checked to generate the expected code, which saves the
   39|       |   * memset address in the data segment and unconditionally loads and jumps to
   40|       |   * that address, with the following targets:
   41|       |   *
   42|       |   * x86-64: Clang 19, GCC 6, 11, 13, 14
   43|       |   * riscv64: GCC 14
   44|       |   * aarch64: GCC 14
   45|       |   * armv7: GCC 14
   46|       |   *
   47|       |   * Actually all of them generated the expected jump even without marking the
   48|       |   * function pointer as volatile. However this seems worth including as an
   49|       |   * additional precaution.
   50|       |   */
   51|       |   static void* (*const volatile memset_ptr)(void*, int, size_t) = std::memset;
   52|       |   (memset_ptr)(ptr, 0, n);
   53|       |#endif
   54|   152M|}

_ZN5Botan2OS14get_process_idEv:
   77|  65.6k|uint32_t OS::get_process_id() {
   78|  65.6k|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
   79|  65.6k|   return ::getpid();
   80|       |#elif defined(BOTAN_TARGET_OS_HAS_WIN32)
   81|       |   return ::GetCurrentProcessId();
   82|       |#elif defined(BOTAN_TARGET_OS_IS_LLVM) || defined(BOTAN_TARGET_OS_IS_NONE)
   83|       |   return 0;  // truly no meaningful value
   84|       |#else
   85|       |   #error "Missing get_process_id"
   86|       |#endif
   87|  65.6k|}
_ZN5Botan2OS21get_cpu_cycle_counterEv:
  169|  26.2k|uint64_t OS::get_cpu_cycle_counter() {
  170|  26.2k|   uint64_t rtc = 0;
  171|       |
  172|       |#if defined(BOTAN_TARGET_OS_HAS_WIN32)
  173|       |   LARGE_INTEGER tv;
  174|       |   ::QueryPerformanceCounter(&tv);
  175|       |   rtc = tv.QuadPart;
  176|       |
  177|       |#elif defined(BOTAN_USE_GCC_INLINE_ASM)
  178|       |
  179|  26.2k|   #if defined(BOTAN_TARGET_ARCH_IS_X86_64)
  180|       |
  181|  26.2k|   uint32_t rtc_low = 0, rtc_high = 0;
  182|  26.2k|   asm volatile("rdtsc" : "=d"(rtc_high), "=a"(rtc_low));
  183|  26.2k|   rtc = (static_cast<uint64_t>(rtc_high) << 32) | rtc_low;
  184|       |
  185|       |   #elif defined(BOTAN_TARGET_CPU_IS_X86_FAMILY) && defined(BOTAN_HAS_CPUID)
  186|       |
  187|       |   if(CPUID::has(CPUID::Feature::RDTSC)) {
  188|       |      uint32_t rtc_low = 0, rtc_high = 0;
  189|       |      asm volatile("rdtsc" : "=d"(rtc_high), "=a"(rtc_low));
  190|       |      rtc = (static_cast<uint64_t>(rtc_high) << 32) | rtc_low;
  191|       |   }
  192|       |
  193|       |   #elif defined(BOTAN_TARGET_ARCH_IS_PPC64)
  194|       |
  195|       |   for(;;) {
  196|       |      uint32_t rtc_low = 0, rtc_high = 0, rtc_high2 = 0;
  197|       |      asm volatile("mftbu %0" : "=r"(rtc_high));
  198|       |      asm volatile("mftb %0" : "=r"(rtc_low));
  199|       |      asm volatile("mftbu %0" : "=r"(rtc_high2));
  200|       |
  201|       |      if(rtc_high == rtc_high2) {
  202|       |         rtc = (static_cast<uint64_t>(rtc_high) << 32) | rtc_low;
  203|       |         break;
  204|       |      }
  205|       |   }
  206|       |
  207|       |   #elif defined(BOTAN_TARGET_ARCH_IS_ALPHA)
  208|       |   asm volatile("rpcc %0" : "=r"(rtc));
  209|       |
  210|       |      // OpenBSD does not trap access to the %tick register
  211|       |   #elif defined(BOTAN_TARGET_ARCH_IS_SPARC64) && !defined(BOTAN_TARGET_OS_IS_OPENBSD)
  212|       |   asm volatile("rd %%tick, %0" : "=r"(rtc));
  213|       |
  214|       |   #elif defined(BOTAN_TARGET_ARCH_IS_IA64)
  215|       |   asm volatile("mov %0=ar.itc" : "=r"(rtc));
  216|       |
  217|       |   #elif defined(BOTAN_TARGET_ARCH_IS_S390X)
  218|       |   asm volatile("stck 0(%0)" : : "a"(&rtc) : "memory", "cc");
  219|       |
  220|       |   #elif defined(BOTAN_TARGET_ARCH_IS_HPPA)
  221|       |   asm volatile("mfctl 16,%0" : "=r"(rtc));  // 64-bit only?
  222|       |
  223|       |   #else
  224|       |      //#warning "OS::get_cpu_cycle_counter not implemented"
  225|       |   #endif
  226|       |
  227|  26.2k|#endif
  228|       |
  229|  26.2k|   return rtc;
  230|  26.2k|}
_ZN5Botan2OS25get_high_resolution_clockEv:
  264|  26.2k|uint64_t OS::get_high_resolution_clock() {
  265|  26.2k|   if(uint64_t cpu_clock = OS::get_cpu_cycle_counter()) {
  ------------------
  |  Branch (265:16): [True: 26.2k, False: 0]
  ------------------
  266|  26.2k|      return cpu_clock;
  267|  26.2k|   }
  268|       |
  269|       |#if defined(BOTAN_TARGET_OS_IS_EMSCRIPTEN)
  270|       |   return emscripten_get_now();
  271|       |#endif
  272|       |
  273|       |   /*
  274|       |   If we got here either we either don't have an asm instruction
  275|       |   above, or (for x86) RDTSC is not available at runtime. Try some
  276|       |   clock_gettimes and return the first one that works, or otherwise
  277|       |   fall back to std::chrono.
  278|       |   */
  279|       |
  280|      0|#if defined(BOTAN_TARGET_OS_HAS_CLOCK_GETTIME)
  281|       |
  282|       |   // The ordering here is somewhat arbitrary...
  283|      0|   const clockid_t clock_types[] = {
  284|       |   #if defined(CLOCK_MONOTONIC_HR)
  285|       |      CLOCK_MONOTONIC_HR,
  286|       |   #endif
  287|      0|   #if defined(CLOCK_MONOTONIC_RAW)
  288|      0|      CLOCK_MONOTONIC_RAW,
  289|      0|   #endif
  290|      0|   #if defined(CLOCK_MONOTONIC)
  291|      0|      CLOCK_MONOTONIC,
  292|      0|   #endif
  293|      0|   #if defined(CLOCK_PROCESS_CPUTIME_ID)
  294|      0|      CLOCK_PROCESS_CPUTIME_ID,
  295|      0|   #endif
  296|      0|   #if defined(CLOCK_THREAD_CPUTIME_ID)
  297|      0|      CLOCK_THREAD_CPUTIME_ID,
  298|      0|   #endif
  299|      0|   };
  300|       |
  301|      0|   for(clockid_t clock : clock_types) {
  ------------------
  |  Branch (301:24): [True: 0, False: 0]
  ------------------
  302|      0|      struct timespec ts;
  303|      0|      if(::clock_gettime(clock, &ts) == 0) {
  ------------------
  |  Branch (303:10): [True: 0, False: 0]
  ------------------
  304|      0|         return (static_cast<uint64_t>(ts.tv_sec) * 1000000000) + static_cast<uint64_t>(ts.tv_nsec);
  305|      0|      }
  306|      0|   }
  307|      0|#endif
  308|       |
  309|      0|#if defined(BOTAN_TARGET_OS_HAS_SYSTEM_CLOCK)
  310|       |   // Plain C++11 fallback
  311|      0|   auto now = std::chrono::high_resolution_clock::now().time_since_epoch();
  312|      0|   return std::chrono::duration_cast<std::chrono::nanoseconds>(now).count();
  313|       |#else
  314|       |   return 0;
  315|       |#endif
  316|      0|}
_ZN5Botan2OS16system_page_sizeEv:
  354|    516|size_t OS::system_page_size() {
  355|    516|   const size_t default_page_size = 4096;
  356|       |
  357|    516|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
  358|    516|   long p = ::sysconf(_SC_PAGESIZE);
  359|    516|   if(p > 1) {
  ------------------
  |  Branch (359:7): [True: 516, False: 0]
  ------------------
  360|    516|      return static_cast<size_t>(p);
  361|    516|   } else {
  362|      0|      return default_page_size;
  363|      0|   }
  364|       |#elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  365|       |   BOTAN_UNUSED(default_page_size);
  366|       |   SYSTEM_INFO sys_info;
  367|       |   ::GetSystemInfo(&sys_info);
  368|       |   return sys_info.dwPageSize;
  369|       |#else
  370|       |   return default_page_size;
  371|       |#endif
  372|    516|}
_ZN5Botan2OS24get_memory_locking_limitEv:
  374|      2|size_t OS::get_memory_locking_limit() {
  375|       |   /*
  376|       |   * Linux defaults to only 64 KiB of mlockable memory per process (too small)
  377|       |   * but BSDs offer a small fraction of total RAM (more than we need). Bound the
  378|       |   * total mlock size to 512 KiB which is enough to run the entire test suite
  379|       |   * without spilling to non-mlock memory (and thus presumably also enough for
  380|       |   * many useful programs), but small enough that we should not cause problems
  381|       |   * even if many processes are mlocking on the same machine.
  382|       |   */
  383|      2|   const size_t max_locked_kb = 512;
  384|       |
  385|       |   /*
  386|       |   * If RLIMIT_MEMLOCK is not defined, likely the OS does not support
  387|       |   * unprivileged mlock calls.
  388|       |   */
  389|      2|#if defined(RLIMIT_MEMLOCK) && defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)
  390|      2|   const size_t mlock_requested =
  391|      2|      std::min<size_t>(read_env_variable_sz("BOTAN_MLOCK_POOL_SIZE", max_locked_kb), max_locked_kb);
  392|       |
  393|      2|   if(mlock_requested > 0) {
  ------------------
  |  Branch (393:7): [True: 2, False: 0]
  ------------------
  394|      2|      struct ::rlimit limits;
  395|       |
  396|      2|      ::getrlimit(RLIMIT_MEMLOCK, &limits);
  397|       |
  398|      2|      if(limits.rlim_cur < limits.rlim_max) {
  ------------------
  |  Branch (398:10): [True: 0, False: 2]
  ------------------
  399|      0|         limits.rlim_cur = limits.rlim_max;
  400|      0|         ::setrlimit(RLIMIT_MEMLOCK, &limits);
  401|      0|         ::getrlimit(RLIMIT_MEMLOCK, &limits);
  402|      0|      }
  403|       |
  404|      2|      return std::min<size_t>(limits.rlim_cur, mlock_requested * 1024);
  405|      2|   }
  406|       |
  407|       |#elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  408|       |   const size_t mlock_requested =
  409|       |      std::min<size_t>(read_env_variable_sz("BOTAN_MLOCK_POOL_SIZE", max_locked_kb), max_locked_kb);
  410|       |
  411|       |   SIZE_T working_min = 0, working_max = 0;
  412|       |   if(!::GetProcessWorkingSetSize(::GetCurrentProcess(), &working_min, &working_max)) {
  413|       |      return 0;
  414|       |   }
  415|       |
  416|       |   // According to Microsoft MSDN:
  417|       |   // The maximum number of pages that a process can lock is equal to the number of pages in its minimum working set minus a small overhead
  418|       |   // In the book "Windows Internals Part 2": the maximum lockable pages are minimum working set size - 8 pages
  419|       |   // But the information in the book seems to be inaccurate/outdated
  420|       |   // I've tested this on Windows 8.1 x64, Windows 10 x64 and Windows 7 x86
  421|       |   // On all three OS the value is 11 instead of 8
  422|       |   const size_t overhead = OS::system_page_size() * 11;
  423|       |   if(working_min > overhead) {
  424|       |      const size_t lockable_bytes = working_min - overhead;
  425|       |      return std::min<size_t>(lockable_bytes, mlock_requested * 1024);
  426|       |   }
  427|       |#else
  428|       |   // Not supported on this platform
  429|       |   BOTAN_UNUSED(max_locked_kb);
  430|       |#endif
  431|       |
  432|      0|   return 0;
  433|      2|}
_ZN5Botan2OS17read_env_variableERNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEENS1_17basic_string_viewIcS4_EE:
  435|      3|bool OS::read_env_variable(std::string& value_out, std::string_view name_view) {
  436|      3|   value_out = "";
  437|       |
  438|      3|   if(running_in_privileged_state()) {
  ------------------
  |  Branch (438:7): [True: 0, False: 3]
  ------------------
  439|      0|      return false;
  440|      0|   }
  441|       |
  442|       |#if defined(BOTAN_TARGET_OS_HAS_WIN32) && defined(BOTAN_BUILD_COMPILER_IS_MSVC)
  443|       |   const std::string name(name_view);
  444|       |   char val[128] = {0};
  445|       |   size_t req_size = 0;
  446|       |   if(getenv_s(&req_size, val, sizeof(val), name.c_str()) == 0) {
  447|       |      // Microsoft's implementation always writes a terminating \0,
  448|       |      // and includes it in the reported length of the environment variable
  449|       |      // if a value exists.
  450|       |      if(req_size > 0 && val[req_size - 1] == '\0') {
  451|       |         value_out = std::string(val);
  452|       |      } else {
  453|       |         value_out = std::string(val, req_size);
  454|       |      }
  455|       |      return true;
  456|       |   }
  457|       |#else
  458|      3|   const std::string name(name_view);
  459|      3|   if(const char* val = std::getenv(name.c_str())) {
  ------------------
  |  Branch (459:19): [True: 0, False: 3]
  ------------------
  460|      0|      value_out = val;
  461|      0|      return true;
  462|      0|   }
  463|      3|#endif
  464|       |
  465|      3|   return false;
  466|      3|}
_ZN5Botan2OS20read_env_variable_szENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEEm:
  468|      2|size_t OS::read_env_variable_sz(std::string_view name, size_t def) {
  469|      2|   std::string value;
  470|      2|   if(read_env_variable(value, name) && !value.empty()) {
  ------------------
  |  Branch (470:7): [True: 0, False: 2]
  |  Branch (470:41): [True: 0, False: 0]
  ------------------
  471|      0|      try {
  472|      0|         const size_t val = std::stoul(value, nullptr);
  473|      0|         return val;
  474|      0|      } catch(std::exception&) { /* ignore it */
  475|      0|      }
  476|      0|   }
  477|       |
  478|      2|   return def;
  479|      2|}
_ZN5Botan2OS21allocate_locked_pagesEm:
  508|      2|std::vector<void*> OS::allocate_locked_pages(size_t count) {
  509|      2|   std::vector<void*> result;
  510|       |
  511|      2|#if(defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)) || \
  512|      2|   defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  513|       |
  514|      2|   result.reserve(count);
  515|       |
  516|      2|   const size_t page_size = OS::system_page_size();
  517|       |
  518|      2|   #if defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)
  519|      2|   static const int locked_fd = get_locked_fd();
  520|      2|   #endif
  521|       |
  522|    258|   for(size_t i = 0; i != count; ++i) {
  ------------------
  |  Branch (522:22): [True: 256, False: 2]
  ------------------
  523|    256|      void* ptr = nullptr;
  524|       |
  525|    256|   #if defined(BOTAN_TARGET_OS_HAS_POSIX1) && defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)
  526|       |
  527|    256|      int mmap_flags = MAP_PRIVATE;
  528|       |
  529|    256|      #if defined(MAP_ANONYMOUS)
  530|    256|      mmap_flags |= MAP_ANONYMOUS;
  531|       |      #elif defined(MAP_ANON)
  532|       |      mmap_flags |= MAP_ANON;
  533|       |      #endif
  534|       |
  535|       |      #if defined(MAP_CONCEAL)
  536|       |      mmap_flags |= MAP_CONCEAL;
  537|       |      #elif defined(MAP_NOCORE)
  538|       |      mmap_flags |= MAP_NOCORE;
  539|       |      #endif
  540|       |
  541|    256|      int mmap_prot = PROT_READ | PROT_WRITE;
  542|       |
  543|       |      #if defined(PROT_MAX)
  544|       |      mmap_prot |= PROT_MAX(mmap_prot);
  545|       |      #endif
  546|       |
  547|    256|      ptr = ::mmap(nullptr,
  548|    256|                   3 * page_size,
  549|    256|                   mmap_prot,
  550|    256|                   mmap_flags,
  551|    256|                   /*fd=*/locked_fd,
  552|    256|                   /*offset=*/0);
  553|       |
  554|    256|      if(ptr == MAP_FAILED) {
  ------------------
  |  Branch (554:10): [True: 0, False: 256]
  ------------------
  555|      0|         continue;
  556|      0|      }
  557|       |
  558|       |      // lock the data page
  559|    256|      if(::mlock(static_cast<uint8_t*>(ptr) + page_size, page_size) != 0) {
  ------------------
  |  Branch (559:10): [True: 0, False: 256]
  ------------------
  560|      0|         ::munmap(ptr, 3 * page_size);
  561|      0|         continue;
  562|      0|      }
  563|       |
  564|    256|      #if defined(MADV_DONTDUMP)
  565|       |      // we ignore errors here, as DONTDUMP is just a bonus
  566|    256|      ::madvise(static_cast<uint8_t*>(ptr) + page_size, page_size, MADV_DONTDUMP);
  567|    256|      #endif
  568|       |
  569|       |   #elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  570|       |      ptr = ::VirtualAlloc(nullptr, 3 * page_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  571|       |
  572|       |      if(ptr == nullptr)
  573|       |         continue;
  574|       |
  575|       |      if(::VirtualLock(static_cast<uint8_t*>(ptr) + page_size, page_size) == 0) {
  576|       |         ::VirtualFree(ptr, 0, MEM_RELEASE);
  577|       |         continue;
  578|       |      }
  579|       |   #endif
  580|       |
  581|    256|      std::memset(ptr, 0, 3 * page_size);  // zero data page and both guard pages
  582|       |
  583|       |      // Attempts to name the data page
  584|    256|      page_named(ptr, 3 * page_size);
  585|       |      // Make guard page preceeding the data page
  586|    256|      page_prohibit_access(static_cast<uint8_t*>(ptr));
  587|       |      // Make guard page following the data page
  588|    256|      page_prohibit_access(static_cast<uint8_t*>(ptr) + 2 * page_size);
  589|       |
  590|    256|      result.push_back(static_cast<uint8_t*>(ptr) + page_size);
  591|    256|   }
  592|       |#else
  593|       |   BOTAN_UNUSED(count);
  594|       |#endif
  595|       |
  596|      2|   return result;
  597|      2|}
_ZN5Botan2OS20page_prohibit_accessEPv:
  613|    512|void OS::page_prohibit_access(void* page) {
  614|    512|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
  615|    512|   const size_t page_size = OS::system_page_size();
  616|    512|   ::mprotect(page, page_size, PROT_NONE);
  617|       |#elif defined(BOTAN_TARGET_OS_HAS_VIRTUAL_LOCK)
  618|       |   const size_t page_size = OS::system_page_size();
  619|       |   DWORD old_perms = 0;
  620|       |   ::VirtualProtect(page, page_size, PAGE_NOACCESS, &old_perms);
  621|       |   BOTAN_UNUSED(old_perms);
  622|       |#else
  623|       |   BOTAN_UNUSED(page);
  624|       |#endif
  625|    512|}
_ZN5Botan2OS10page_namedEPvm:
  649|    256|void OS::page_named(void* page, size_t size) {
  650|       |#if defined(BOTAN_TARGET_OS_HAS_PRCTL) && defined(PR_SET_VMA) && defined(PR_SET_VMA_ANON_NAME)
  651|       |   static constexpr char name[] = "Botan mlock pool";
  652|       |   int r = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, reinterpret_cast<uintptr_t>(page), size, name);
  653|       |   BOTAN_UNUSED(r);
  654|       |#else
  655|    256|   BOTAN_UNUSED(page, size);
  ------------------
  |  |  120|    256|#define BOTAN_UNUSED Botan::ignore_params
  ------------------
  656|    256|#endif
  657|    256|}
os_utils.cpp:_ZN5Botan12_GLOBAL__N_110get_auxvalENSt3__18optionalImEE:
  119|      3|std::optional<unsigned long> get_auxval(std::optional<unsigned long> id) {
  120|      3|   if(id) {
  ------------------
  |  Branch (120:7): [True: 3, False: 0]
  ------------------
  121|      3|#if defined(BOTAN_TARGET_OS_HAS_GETAUXVAL)
  122|      3|      return ::getauxval(*id);
  123|       |#elif defined(BOTAN_TARGET_OS_HAS_ELF_AUX_INFO)
  124|       |      unsigned long auxinfo = 0;
  125|       |      if(::elf_aux_info(static_cast<int>(*id), &auxinfo, sizeof(auxinfo)) == 0) {
  126|       |         return auxinfo;
  127|       |      }
  128|       |#endif
  129|      3|   }
  130|       |
  131|      0|   return {};
  132|      3|}
os_utils.cpp:_ZN5Botan12_GLOBAL__N_127running_in_privileged_stateEv:
  153|      3|bool running_in_privileged_state() {
  154|      3|#if defined(AT_SECURE)
  155|      3|   if(auto at_secure = get_auxval(AT_SECURE)) {
  ------------------
  |  Branch (155:12): [True: 3, False: 0]
  ------------------
  156|      3|      return at_secure != 0;
  157|      3|   }
  158|      0|#endif
  159|       |
  160|      0|#if defined(BOTAN_TARGET_OS_HAS_POSIX1)
  161|      0|   return (::getuid() != ::geteuid()) || (::getgid() != ::getegid());
  ------------------
  |  Branch (161:11): [True: 0, False: 0]
  |  Branch (161:42): [True: 0, False: 0]
  ------------------
  162|       |#else
  163|       |   return false;
  164|       |#endif
  165|      3|}
os_utils.cpp:_ZN5Botan12_GLOBAL__N_113get_locked_fdEv:
  485|      2|int get_locked_fd() {
  486|       |   #if defined(BOTAN_TARGET_OS_IS_IOS) || defined(BOTAN_TARGET_OS_IS_MACOS)
  487|       |   // On Darwin, tagging anonymous pages allows vmmap to track these.
  488|       |   // Allowed from 240 to 255 for userland applications
  489|       |   static constexpr int default_locked_fd = 255;
  490|       |   int locked_fd = default_locked_fd;
  491|       |
  492|       |   if(size_t locked_fdl = OS::read_env_variable_sz("BOTAN_LOCKED_FD", default_locked_fd)) {
  493|       |      if(locked_fdl < 240 || locked_fdl > 255) {
  494|       |         locked_fdl = default_locked_fd;
  495|       |      }
  496|       |      locked_fd = static_cast<int>(locked_fdl);
  497|       |   }
  498|       |   return VM_MAKE_TAG(locked_fd);
  499|       |   #else
  500|      2|   return -1;
  501|      2|   #endif
  502|      2|}

_ZN5Botan9SCAN_NameC2ENSt3__117basic_string_viewIcNS1_11char_traitsIcEEEE:
   58|  13.1k|SCAN_Name::SCAN_Name(std::string_view algo_spec) : m_orig_algo_spec(algo_spec), m_alg_name(), m_args(), m_mode_info() {
   59|  13.1k|   if(algo_spec.empty()) {
  ------------------
  |  Branch (59:7): [True: 0, False: 13.1k]
  ------------------
   60|      0|      throw Invalid_Argument("Expected algorithm name, got empty string");
   61|      0|   }
   62|       |
   63|  13.1k|   std::vector<std::pair<size_t, std::string>> name;
   64|  13.1k|   size_t level = 0;
   65|  13.1k|   std::pair<size_t, std::string> accum = std::make_pair(level, "");
   66|       |
   67|  13.1k|   const std::string decoding_error = "Bad SCAN name '" + m_orig_algo_spec + "': ";
   68|       |
   69|   170k|   for(char c : algo_spec) {
  ------------------
  |  Branch (69:15): [True: 170k, False: 13.1k]
  ------------------
   70|   170k|      if(c == '/' || c == ',' || c == '(' || c == ')') {
  ------------------
  |  Branch (70:10): [True: 0, False: 170k]
  |  Branch (70:22): [True: 0, False: 170k]
  |  Branch (70:34): [True: 13.1k, False: 157k]
  |  Branch (70:46): [True: 13.1k, False: 144k]
  ------------------
   71|  26.2k|         if(c == '(') {
  ------------------
  |  Branch (71:13): [True: 13.1k, False: 13.1k]
  ------------------
   72|  13.1k|            ++level;
   73|  13.1k|         } else if(c == ')') {
  ------------------
  |  Branch (73:20): [True: 13.1k, False: 0]
  ------------------
   74|  13.1k|            if(level == 0) {
  ------------------
  |  Branch (74:16): [True: 0, False: 13.1k]
  ------------------
   75|      0|               throw Decoding_Error(decoding_error + "Mismatched parens");
   76|      0|            }
   77|  13.1k|            --level;
   78|  13.1k|         }
   79|       |
   80|  26.2k|         if(c == '/' && level > 0) {
  ------------------
  |  Branch (80:13): [True: 0, False: 26.2k]
  |  Branch (80:25): [True: 0, False: 0]
  ------------------
   81|      0|            accum.second.push_back(c);
   82|  26.2k|         } else {
   83|  26.2k|            if(!accum.second.empty()) {
  ------------------
  |  Branch (83:16): [True: 26.2k, False: 0]
  ------------------
   84|  26.2k|               name.push_back(accum);
   85|  26.2k|            }
   86|  26.2k|            accum = std::make_pair(level, "");
   87|  26.2k|         }
   88|   144k|      } else {
   89|   144k|         accum.second.push_back(c);
   90|   144k|      }
   91|   170k|   }
   92|       |
   93|  13.1k|   if(!accum.second.empty()) {
  ------------------
  |  Branch (93:7): [True: 0, False: 13.1k]
  ------------------
   94|      0|      name.push_back(accum);
   95|      0|   }
   96|       |
   97|  13.1k|   if(level != 0) {
  ------------------
  |  Branch (97:7): [True: 0, False: 13.1k]
  ------------------
   98|      0|      throw Decoding_Error(decoding_error + "Missing close paren");
   99|      0|   }
  100|       |
  101|  13.1k|   if(name.empty()) {
  ------------------
  |  Branch (101:7): [True: 0, False: 13.1k]
  ------------------
  102|      0|      throw Decoding_Error(decoding_error + "Empty name");
  103|      0|   }
  104|       |
  105|  13.1k|   m_alg_name = name[0].second;
  106|       |
  107|  13.1k|   bool in_modes = false;
  108|       |
  109|  26.2k|   for(size_t i = 1; i != name.size(); ++i) {
  ------------------
  |  Branch (109:22): [True: 13.1k, False: 13.1k]
  ------------------
  110|  13.1k|      if(name[i].first == 0) {
  ------------------
  |  Branch (110:10): [True: 0, False: 13.1k]
  ------------------
  111|      0|         m_mode_info.push_back(make_arg(name, i));
  112|      0|         in_modes = true;
  113|  13.1k|      } else if(name[i].first == 1 && !in_modes) {
  ------------------
  |  Branch (113:17): [True: 13.1k, False: 0]
  |  Branch (113:39): [True: 13.1k, False: 0]
  ------------------
  114|  13.1k|         m_args.push_back(make_arg(name, i));
  115|  13.1k|      }
  116|  13.1k|   }
  117|  13.1k|}
_ZNK5Botan9SCAN_Name3argEm:
  119|  13.1k|std::string SCAN_Name::arg(size_t i) const {
  120|  13.1k|   if(i >= arg_count()) {
  ------------------
  |  Branch (120:7): [True: 0, False: 13.1k]
  ------------------
  121|      0|      throw Invalid_Argument("SCAN_Name::arg " + std::to_string(i) + " out of range for '" + to_string() + "'");
  122|      0|   }
  123|  13.1k|   return m_args[i];
  124|  13.1k|}
scan_name.cpp:_ZN5Botan12_GLOBAL__N_18make_argERKNSt3__16vectorINS1_4pairImNS1_12basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEEENS7_ISA_EEEEm:
   17|  13.1k|std::string make_arg(const std::vector<std::pair<size_t, std::string>>& name, size_t start) {
   18|  13.1k|   std::string output = name[start].second;
   19|  13.1k|   size_t level = name[start].first;
   20|       |
   21|  13.1k|   size_t paren_depth = 0;
   22|       |
   23|  13.1k|   for(size_t i = start + 1; i != name.size(); ++i) {
  ------------------
  |  Branch (23:30): [True: 0, False: 13.1k]
  ------------------
   24|      0|      if(name[i].first <= name[start].first) {
  ------------------
  |  Branch (24:10): [True: 0, False: 0]
  ------------------
   25|      0|         break;
   26|      0|      }
   27|       |
   28|      0|      if(name[i].first > level) {
  ------------------
  |  Branch (28:10): [True: 0, False: 0]
  ------------------
   29|      0|         output += "(" + name[i].second;
   30|      0|         ++paren_depth;
   31|      0|      } else if(name[i].first < level) {
  ------------------
  |  Branch (31:17): [True: 0, False: 0]
  ------------------
   32|      0|         for(size_t j = name[i].first; j < level; j++) {
  ------------------
  |  Branch (32:40): [True: 0, False: 0]
  ------------------
   33|      0|            output += ")";
   34|      0|            --paren_depth;
   35|      0|         }
   36|      0|         output += "," + name[i].second;
   37|      0|      } else {
   38|      0|         if(output[output.size() - 1] != '(') {
  ------------------
  |  Branch (38:13): [True: 0, False: 0]
  ------------------
   39|      0|            output += ",";
   40|      0|         }
   41|      0|         output += name[i].second;
   42|      0|      }
   43|       |
   44|      0|      level = name[i].first;
   45|      0|   }
   46|       |
   47|  13.1k|   for(size_t i = 0; i != paren_depth; ++i) {
  ------------------
  |  Branch (47:22): [True: 0, False: 13.1k]
  ------------------
   48|      0|      output += ")";
   49|      0|   }
   50|       |
   51|  13.1k|   return output;
   52|  13.1k|}

LLVMFuzzerInitialize:
    9|      2|extern "C" int LLVMFuzzerInitialize() { return 0; }
LLVMFuzzerTestOneInput:
   12|  13.1k|{
   13|  13.1k|    if (Size == 0)
  ------------------
  |  Branch (13:9): [True: 0, False: 13.1k]
  ------------------
   14|      0|    {
   15|      0|        return -1;
   16|      0|    }
   17|       |
   18|  13.1k|    spank_olm::Account account;
   19|  13.1k|    Botan::AutoSeeded_RNG rng;
   20|  13.1k|    account.new_account(rng);
   21|       |
   22|  13.1k|    const std::string_view message(reinterpret_cast<const char *>(Data), Size);
   23|  13.1k|    auto signature = account.sign(rng, message);
   24|       |
   25|       |    // Verify the signature
   26|  13.1k|    Botan::PK_Verifier verifier(account.identity_keys->ed25519_key, "Ed25519ph");
   27|  13.1k|    verifier.update(message);
   28|  13.1k|    assert(verifier.check_signature(signature));
   29|       |
   30|  13.1k|    return 0;
   31|  13.1k|}

_ZN9spank_olm7AccountC2Ev:
   50|  13.1k|        Account() : next_one_time_key_id(0) {}

_ZN9spank_olm14FixedSizeArrayINS_10OneTimeKeyELm100EEC2Ev:
   24|  13.1k|        FixedSizeArray() : current_size(0)
   25|  13.1k|        {
   26|  13.1k|            data = std::make_unique<T*[]>(max_size + 1);
   27|  13.1k|        }
_ZN9spank_olm14FixedSizeArrayINS_10OneTimeKeyELm100EED2Ev:
   49|  13.1k|        {
   50|  13.1k|            clear();
   51|  13.1k|        }
_ZN9spank_olm14FixedSizeArrayINS_10OneTimeKeyELm100EE5clearEv:
  250|  13.1k|        {
  251|  13.1k|            for (std::size_t i = 0; i < current_size; ++i)
  ------------------
  |  Branch (251:37): [True: 0, False: 13.1k]
  ------------------
  252|      0|            {
  253|      0|                delete data[i];
  254|      0|            }
  255|  13.1k|            current_size = 0;
  256|  13.1k|        }

_ZN9spank_olm7Account11new_accountERN5Botan21RandomNumberGeneratorE:
   11|  13.1k|    {
   12|  13.1k|        identity_keys = IdentityKeys{Botan::Ed25519_PrivateKey(rng), Botan::X25519_PrivateKey(rng)};
   13|       |
   14|       |        // Make sure we check the key pairs.
   15|  13.1k|        if (!identity_keys->ed25519_key.check_key(rng, false) || !identity_keys->curve25519_key.check_key(rng, false) ||
  ------------------
  |  Branch (15:13): [True: 0, False: 13.1k]
  |  Branch (15:13): [True: 0, False: 13.1k]
  |  Branch (15:66): [True: 0, False: 13.1k]
  ------------------
   16|  13.1k|            !identity_keys->ed25519_key.public_key()->check_key(rng, false) ||
  ------------------
  |  Branch (16:13): [True: 0, False: 13.1k]
  ------------------
   17|  13.1k|            !identity_keys->curve25519_key.public_key()->check_key(rng, false))
  ------------------
  |  Branch (17:13): [True: 0, False: 13.1k]
  ------------------
   18|      0|        {
   19|      0|            throw SpankOlmErrorKeyGeneration();
   20|      0|        }
   21|  13.1k|    }
_ZNK9spank_olm7Account4signERN5Botan21RandomNumberGeneratorENSt3__117basic_string_viewIcNS4_11char_traitsIcEEEE:
   36|  13.1k|    {
   37|       |        // According to https://botan.randombit.net/handbook/api_ref/pubkey.html#ed25519-ed448-variants
   38|  13.1k|        const std::string padding_scheme = "Ed25519ph";
   39|       |
   40|       |        // Use the Ed25519 key to sign the message using the Botan library.
   41|       |
   42|       |
   43|  13.1k|        Botan::PK_Signer signer(identity_keys->ed25519_key, rng, padding_scheme);
   44|  13.1k|        signer.update(message);
   45|  13.1k|        auto signature = signer.signature(rng);
   46|       |
   47|  13.1k|        return signature;
   48|  13.1k|    }

_ZNK5Botan18Ed25519_PrivateKey20raw_private_key_bitsEv:
  117|  13.1k|      secure_vector<uint8_t> raw_private_key_bits() const override { return m_private; }

_ZN5Botan14Asymmetric_KeyD2Ev:
   62|  78.7k|      virtual ~Asymmetric_Key() = default;

_ZN5Botan11PK_Verifier15check_signatureENSt3__14spanIKhLm18446744073709551615EEE:
  372|  13.1k|      bool check_signature(std::span<const uint8_t> sig) { return check_signature(sig.data(), sig.size()); }

_ZN5Botan16secure_allocatorIhE10deallocateEPhm:
   50|   118k|      void deallocate(T* p, std::size_t n) { deallocate_memory(p, n, sizeof(T)); }
_ZN5Botan16secure_allocatorIhE8allocateEm:
   48|   118k|      T* allocate(std::size_t n) { return static_cast<T*>(allocate_memory(n, sizeof(T))); }
_ZN5BotanneIhhEEbRKNS_16secure_allocatorIT_EERKNS1_IT0_EE:
   59|  13.1k|inline bool operator!=(const secure_allocator<T>&, const secure_allocator<U>&) {
   60|  13.1k|   return false;
   61|  13.1k|}

